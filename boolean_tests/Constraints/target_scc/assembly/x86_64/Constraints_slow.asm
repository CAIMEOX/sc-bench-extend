    ; asmsyntax=nasm
section .note.GNU-stack noalloc noexec nowrite progbits
section .text
extern print_i64
extern println_i64
global asm_main

asm_main:
    ; setup
    ; save registers
    push rbx
    push rbp
    push r12
    push r13
    push r14
    push r15
    ; reserve space for register spills
    sub rsp, 2048
    ; initialize heap pointer
    mov rbx, rdi
    ; initialize free pointer
    mov rbp, rbx
    add rbp, 64
    ; move parameters into place
    mov rdi, rdx
    ; move parameters into place
    mov rdx, rsi
    ; actual code

main_:
    ; create a0: _Cont = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel _Cont_1]
    ; jump main_loop_
    jmp main_loop_

_Cont_1:

_Cont_1_Ret:
    ; exit x0
    mov rax, rdx
    jmp cleanup

abs_:
    ; if i < 0 \{ ... \}
    cmp rdx, 0
    jl lab2
    ; else branch
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

lab2:
    ; then branch
    ; lit x0 <- -1;
    mov r9, -1
    ; x1 <- x0 * i;
    mov r11, r9
    imul r11, rdx
    ; substitute (x1 := x1)(a0 := a0);
    ; #move variables
    mov rdx, r11
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

eq_:
    ; if i1 == i2 \{ ... \}
    cmp rdx, rdi
    je lab3
    ; else branch
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 False
    add rdx, 5
    jmp rdx

lab3:
    ; then branch
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 True
    add rdx, 0
    jmp rdx

and_:
    ; substitute (a0 := a0)(b2 := b2)(b1 := b1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch b1 \{ ... \};
    lea rcx, [rel Bool_4]
    add rcx, r9
    jmp rcx

Bool_4:
    jmp near Bool_4_True
    jmp near Bool_4_False

Bool_4_True:
    ; switch b2 \{ ... \};
    lea rcx, [rel Bool_5]
    add rcx, rdi
    jmp rcx

Bool_5:
    jmp near Bool_5_True
    jmp near Bool_5_False

Bool_5_True:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

Bool_5_False:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

Bool_4_False:
    ; substitute (a0 := a0);
    ; #erase b2
    cmp rsi, 0
    je lab8
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab6
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab7

lab6:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab7:

lab8:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

not_:
    ; substitute (a0 := a0)(b := b);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch b \{ ... \};
    lea rcx, [rel Bool_9]
    add rcx, rdi
    jmp rcx

Bool_9:
    jmp near Bool_9_True
    jmp near Bool_9_False

Bool_9_True:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

Bool_9_False:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

reverse_loop_:
    ; substitute (a0 := a0)(acc := acc)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_10]
    add rcx, r9
    jmp rcx

List_Assign_10:
    jmp near List_Assign_10_Nil
    jmp near List_Assign_10_Cons

List_Assign_10_Nil:
    ; switch acc \{ ... \};
    lea rcx, [rel List_Assign_11]
    add rcx, rdi
    jmp rcx

List_Assign_11:
    jmp near List_Assign_11_Nil
    jmp near List_Assign_11_Cons

List_Assign_11_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_11_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab14
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab12
    ; ####increment refcount
    add qword [r8 + 0], 1

lab12:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab13
    ; ####increment refcount
    add qword [rsi + 0], 1

lab13:
    jmp lab15

lab14:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab15:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Assign_10_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab18
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab16
    ; ####increment refcount
    add qword [r10 + 0], 1

lab16:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab17
    ; ####increment refcount
    add qword [r8 + 0], 1

lab17:
    jmp lab19

lab18:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab19:
    ; substitute (a0 := a0)(as := as)(a := a)(acc := acc);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; let x0: List[Assign] = Cons(a, acc);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab31
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab32

lab31:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab29
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab22
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab20
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab21

lab20:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab21:

lab22:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab25
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab23
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab24

lab23:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab24:

lab25:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab28
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab26
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab27

lab26:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab27:

lab28:
    jmp lab30

lab29:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab30:

lab32:
    ; #load tag
    mov r9, 5
    ; substitute (as := as)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump reverse_loop_
    jmp reverse_loop_

reverse_:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (ls := ls)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump reverse_loop_
    jmp reverse_loop_

level_:
    ; substitute (a0 := a0)(a := a);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch a \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_33:

Assign_33_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab34
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab35

lab34:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab35:
    ; substitute (varr := varr)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

value_:
    ; substitute (a0 := a0)(a := a);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch a \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_36:

Assign_36_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab37
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab38

lab37:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab38:
    ; substitute (value := value)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rdx, r9
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

max_level_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_39]
    add rcx, rdi
    jmp rcx

List_Assign_39:
    jmp near List_Assign_39_Nil
    jmp near List_Assign_39_Cons

List_Assign_39_Nil:
    ; lit x0 <- 0;
    mov rdi, 0
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

List_Assign_39_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab42
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab40
    ; ####increment refcount
    add qword [r8 + 0], 1

lab40:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab41
    ; ####increment refcount
    add qword [rsi + 0], 1

lab41:
    jmp lab43

lab42:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab43:
    ; substitute (a0 := a0)(a := a);
    ; #erase t
    cmp r8, 0
    je lab46
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab44
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab45

lab44:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab45:

lab46:
    ; switch a \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_47:

Assign_47_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab48
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab49

lab48:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab49:
    ; substitute (v := v)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

complete_:
    ; substitute (a0 := a0)(s := s)(csp := csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_50:

CSP_50_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab52
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab51
    ; ####increment refcount
    add qword [r12 + 0], 1

lab51:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab53

lab52:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab53:
    ; substitute (s := s)(a0 := a0)(v := v);
    ; #erase rel
    cmp r12, 0
    je lab56
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab54
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab55

lab54:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab55:

lab56:
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: _Cont = (a0, v)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69

lab68:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58

lab57:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58:

lab59:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61

lab60:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61:

lab62:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab65
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab63
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab64

lab63:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab64:

lab65:
    jmp lab67

lab66:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67:

lab69:
    ; #load tag
    lea rdi, [rel _Cont_70]
    ; jump max_level_
    jmp max_level_

_Cont_70:

_Cont_70_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab72
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab71
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71:
    jmp lab73

lab72:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab73:
    ; substitute (x0 := x0)(v := v)(a0 := a0);
    ; #move variables
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump eq_
    jmp eq_

enum_from_to_:
    ; if from <= to_ \{ ... \}
    cmp rdx, rdi
    jle lab74
    ; else branch
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

lab74:
    ; then branch
    ; substitute (from0 := from)(to_ := to_)(a0 := a0)(from := from);
    ; #move variables
    mov r11, rdx
    ; create a1: List[i64] = (a0, from)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab86
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab87

lab86:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab84
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab77
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab75
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab76

lab75:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab76:

lab77:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab80
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab78
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab79

lab78:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab79:

lab80:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab83
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab81
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab82

lab81:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab82:

lab83:
    jmp lab85

lab84:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab85:

lab87:
    ; #load tag
    lea r9, [rel List_i64_88]
    ; lit x1 <- 1;
    mov r11, 1
    ; x2 <- from0 + x1;
    mov r13, rdx
    add r13, r11
    ; substitute (x2 := x2)(to_ := to_)(a1 := a1);
    ; #move variables
    mov rdx, r13
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_88:
    jmp near List_i64_88_Nil
    jmp near List_i64_88_Cons

List_i64_88_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab90
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab89
    ; ####increment refcount
    add qword [rax + 0], 1

lab89:
    jmp lab91

lab90:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab91:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (from := from)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_88_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab93
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab92
    ; ####increment refcount
    add qword [r8 + 0], 1

lab92:
    jmp lab94

lab93:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab94:
    ; substitute (from := from)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab106
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab107

lab106:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab104
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab97
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab95
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab96

lab95:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab96:

lab97:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab100
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab98
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab99

lab98:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab99:

lab100:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab103
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab101
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab102

lab101:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab102:

lab103:
    jmp lab105

lab104:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab105:

lab107:
    ; #load tag
    mov r9, 5
    ; substitute (from := from)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

safe_:
    ; substitute (a0 := a0)(as2 := as2)(as1 := as1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch as1 \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_108:

Assign_108_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab109
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab110

lab109:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab110:
    ; substitute (a0 := a0)(m := m)(i := i)(as2 := as2);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch as2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_111:

Assign_111_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab112
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab113

lab112:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab113:
    ; substitute (n0 := n)(m0 := m)(i := i)(j := j)(n := n)(a0 := a0)(m := m);
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov [rsp + 2024], rdi
    mov rdx, r13
    ; create a1: Bool = (i, j, n, a0, m)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab125
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab126

lab125:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab123
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab116
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab114
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab115

lab114:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab115:

lab116:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab119
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab117
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab118

lab117:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab118:

lab119:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab122
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab120
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab121

lab120:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab121:

lab122:
    jmp lab124

lab123:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab124:

lab126:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab138
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab139

lab138:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab136
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab128

lab127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab128:

lab129:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab131

lab130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab131:

lab132:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab135
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab133
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab134

lab133:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab134:

lab135:
    jmp lab137

lab136:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab137:

lab139:
    ; #load tag
    lea r9, [rel Bool_140]
    ; create a2: Bool = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab152
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab153

lab152:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab150
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab143
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab141
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab142

lab141:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab142:

lab143:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab146
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab144
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab145

lab144:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab145:

lab146:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab149
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab147
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab148

lab147:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab148:

lab149:
    jmp lab151

lab150:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab151:

lab153:
    ; #load tag
    lea r9, [rel Bool_154]
    ; substitute (m0 := m0)(n0 := n0)(a2 := a2);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump eq_
    jmp eq_

Bool_154:
    jmp near Bool_154_True
    jmp near Bool_154_False

Bool_154_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab156
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab155
    ; ####increment refcount
    add qword [rax + 0], 1

lab155:
    jmp lab157

lab156:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab157:
    ; let x1: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_154_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab159
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab158
    ; ####increment refcount
    add qword [rax + 0], 1

lab158:
    jmp lab160

lab159:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab160:
    ; let x1: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_140:
    jmp near Bool_140_True
    jmp near Bool_140_False

Bool_140_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab162
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab161
    ; ####increment refcount
    add qword [r10 + 0], 1

lab161:
    mov r9, [r8 + 24]
    jmp lab163

lab162:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab163:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 0
    ; substitute (a0 := a0)(i := i)(j := j)(m := m)(n := n)(x0 := x0);
    ; #move variables
    mov rcx, r11
    mov r11, r13
    mov r13, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r10
    ; jump lift_safe_0_
    jmp lift_safe_0_

Bool_140_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab165
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab164
    ; ####increment refcount
    add qword [r10 + 0], 1

lab164:
    mov r9, [r8 + 24]
    jmp lab166

lab165:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab166:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 5
    ; substitute (a0 := a0)(i := i)(j := j)(m := m)(n := n)(x0 := x0);
    ; #move variables
    mov rcx, r11
    mov r11, r13
    mov r13, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r10
    ; jump lift_safe_0_
    jmp lift_safe_0_

lift_safe_0_:
    ; substitute (n := n)(i := i)(j := j)(m := m)(a0 := a0)(x0 := x0);
    ; #move variables
    mov r12, rax
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; create a3: Bool = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab178
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab179

lab178:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab176
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab169
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab167
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab168

lab167:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab168:

lab169:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab172
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab170
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab171

lab170:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab171:

lab172:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab175
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab173
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab174

lab173:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab174:

lab175:
    jmp lab177

lab176:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab177:

lab179:
    ; #load tag
    lea r13, [rel Bool_180]
    ; create a4: Bool = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab192
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab193

lab192:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab190
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab183
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab181
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab182

lab181:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab182:

lab183:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab186
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab184
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab185

lab184:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab185:

lab186:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab189
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab187
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab188

lab187:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab188:

lab189:
    jmp lab191

lab190:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab191:

lab193:
    ; #load tag
    lea r13, [rel Bool_194]
    ; substitute (j := j)(i := i)(n := n)(m := m)(a4 := a4);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a5: _Cont = (n, m, a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab206
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab207

lab206:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab204
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab197
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab195
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab196

lab195:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab196:

lab197:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab200
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab198
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab199

lab198:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab199:

lab200:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab203
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab201
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab202

lab201:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab202:

lab203:
    jmp lab205

lab204:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab205:

lab207:
    ; #load tag
    lea r9, [rel _Cont_208]
    ; x5 <- i - j;
    mov r11, rdi
    sub r11, rdx
    ; substitute (x5 := x5)(a5 := a5);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    mov rdx, r11
    ; jump abs_
    jmp abs_

_Cont_208:

_Cont_208_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab210
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab209
    ; ####increment refcount
    add qword [r10 + 0], 1

lab209:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab211

lab210:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab211:
    ; substitute (m := m)(n := n)(x4 := x4)(a4 := a4);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a6: _Cont = (x4, a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab223
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab224

lab223:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab221
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab214
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab212
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab213

lab212:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab213:

lab214:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab217
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab215
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab216

lab215:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab216:

lab217:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab220
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab218
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab219

lab218:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab219:

lab220:
    jmp lab222

lab221:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab222:

lab224:
    ; #load tag
    lea r9, [rel _Cont_225]
    ; x7 <- m - n;
    mov r11, rdx
    sub r11, rdi
    ; substitute (x7 := x7)(a6 := a6);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    mov rdx, r11
    ; jump abs_
    jmp abs_

_Cont_225:

_Cont_225_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab227
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab226
    ; ####increment refcount
    add qword [r8 + 0], 1

lab226:
    mov rdi, [rsi + 40]
    jmp lab228

lab227:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab228:
    ; substitute (x4 := x4)(x6 := x6)(a4 := a4);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump eq_
    jmp eq_

Bool_194:
    jmp near Bool_194_True
    jmp near Bool_194_False

Bool_194_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab230
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab229
    ; ####increment refcount
    add qword [rax + 0], 1

lab229:
    jmp lab231

lab230:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab231:
    ; let x3: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x3 := x3)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_194_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab233
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab232
    ; ####increment refcount
    add qword [rax + 0], 1

lab232:
    jmp lab234

lab233:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab234:
    ; let x3: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x3 := x3)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_180:
    jmp near Bool_180_True
    jmp near Bool_180_False

Bool_180_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab237
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab235
    ; ####increment refcount
    add qword [rsi + 0], 1

lab235:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab236
    ; ####increment refcount
    add qword [rax + 0], 1

lab236:
    jmp lab238

lab237:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab238:
    ; let x2: Bool = True();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x2 := x2)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump and_
    jmp and_

Bool_180_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab241
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab239
    ; ####increment refcount
    add qword [rsi + 0], 1

lab239:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab240
    ; ####increment refcount
    add qword [rax + 0], 1

lab240:
    jmp lab242

lab241:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab242:
    ; let x2: Bool = False();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x2 := x2)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump and_
    jmp and_

queens_:
    ; create x0: Fun2[Assign, Assign, Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun2_Assign_Assign_Bool_243]
    ; substitute (n := n)(n0 := n)(x0 := x0)(a0 := a0);
    ; #move variables
    mov r11, rdi
    mov rdi, rdx
    mov r10, rsi
    ; invoke a0 CSP
    ; #there is only one clause, so we can jump there directly
    jmp r11

Fun2_Assign_Assign_Bool_243:

Fun2_Assign_Assign_Bool_243_Apply2:
    ; jump safe_
    jmp safe_

mk_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_List_Assign_244]
    add rcx, r9
    jmp rcx

List_List_Assign_244:
    jmp near List_List_Assign_244_Nil
    jmp near List_List_Assign_244_Cons

List_List_Assign_244_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab247
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab245
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab246

lab245:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab246:

lab247:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Assign_244_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab250
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab248
    ; ####increment refcount
    add qword [r10 + 0], 1

lab248:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab249
    ; ####increment refcount
    add qword [r8 + 0], 1

lab249:
    jmp lab251

lab250:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab251:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab252
    ; ####increment refcount
    add qword [rax + 0], 1

lab252:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[List[Assign]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab264
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab265

lab264:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab262
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab255
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab253
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab254

lab253:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab254:

lab255:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab258
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab256
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab257

lab256:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab257:

lab258:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab261
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab259
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab260

lab259:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab260:

lab261:
    jmp lab263

lab262:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab263:

lab265:
    ; #load tag
    lea r9, [rel Node_List_Assign_266]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_List_Assign_266:

Node_List_Assign_266_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab270
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab267
    ; ####increment refcount
    add qword [r12 + 0], 1

lab267:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab268
    ; ####increment refcount
    add qword [r10 + 0], 1

lab268:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab269
    ; ####increment refcount
    add qword [r8 + 0], 1

lab269:
    jmp lab271

lab270:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab271:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[List[Assign]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab283
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab284

lab283:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab281
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab274
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab272
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab273

lab272:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab273:

lab274:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab277
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab275
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab276

lab275:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab276:

lab277:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab280
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab278
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab279

lab278:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab279:

lab280:
    jmp lab282

lab281:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab282:

lab284:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[List[Assign]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab296
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab297

lab296:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab294
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab287
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab285
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab286

lab285:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab286:

lab287:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab290
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab288
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab289

lab288:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab289:

lab290:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab293
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab291
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab292

lab291:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab292:

lab293:
    jmp lab295

lab294:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab295:

lab297:
    ; #load tag
    lea r9, [rel List_Node_List_Assign_298]
    ; jump mk_map_
    jmp mk_map_

List_Node_List_Assign_298:
    jmp near List_Node_List_Assign_298_Nil
    jmp near List_Node_List_Assign_298_Cons

List_Node_List_Assign_298_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab301
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab299
    ; ####increment refcount
    add qword [rsi + 0], 1

lab299:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab300
    ; ####increment refcount
    add qword [rax + 0], 1

lab300:
    jmp lab302

lab301:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab302:
    ; let x1: List[Node[List[Assign]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_List_Assign_298_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab305
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab303
    ; ####increment refcount
    add qword [r10 + 0], 1

lab303:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab304
    ; ####increment refcount
    add qword [r8 + 0], 1

lab304:
    jmp lab306

lab305:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab306:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[List[Assign]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab318
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab319

lab318:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab316
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab309
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab307
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab308

lab307:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab308:

lab309:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab312
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab310
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab311

lab310:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab311:

lab312:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab315
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab313
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab314

lab313:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab314:

lab315:
    jmp lab317

lab316:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab317:

lab319:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

mk_init_tree_:
    ; substitute (f := f)(x3 := x)(a0 := a0)(x := x);
    ; #share x
    cmp rsi, 0
    je lab320
    ; ####increment refcount
    add qword [rsi + 0], 1

lab320:
    ; #move variables
    mov r10, rsi
    mov r11, rdi
    ; create a1: List[Node[List[Assign]]] = (a0, x)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab332
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab333

lab332:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab330
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab323
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab321
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab322

lab321:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab322:

lab323:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab326
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab324
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab325

lab324:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab325:

lab326:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab329
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab327
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab328

lab327:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab328:

lab329:
    jmp lab331

lab330:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab331:

lab333:
    ; #load tag
    lea r9, [rel List_Node_List_Assign_334]
    ; substitute (f0 := f)(x3 := x3)(a1 := a1)(f := f);
    ; #share f
    cmp rax, 0
    je lab335
    ; ####increment refcount
    add qword [rax + 0], 1

lab335:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create x1: Fun[List[Assign], Node[List[Assign]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab347
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab348

lab347:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab345
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab338
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab336
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab337

lab336:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab337:

lab338:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab341
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab339
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab340

lab339:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab340:

lab341:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab344
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab342
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab343

lab342:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab343:

lab344:
    jmp lab346

lab345:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab346:

lab348:
    ; #load tag
    lea r11, [rel Fun_List_Assign_Node_List_Assign_349]
    ; create a3: List[List[Assign]] = (a1, x1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab361
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab362

lab361:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab359
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab352
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab350
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab351

lab350:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab351:

lab352:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab355
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab353
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab354

lab353:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab354:

lab355:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab358
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab356
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab357

lab356:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab357:

lab358:
    jmp lab360

lab359:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab360:

lab362:
    ; #load tag
    lea r9, [rel List_List_Assign_363]
    ; substitute (x3 := x3)(a3 := a3)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_List_Assign_363:
    jmp near List_List_Assign_363_Nil
    jmp near List_List_Assign_363_Cons

List_List_Assign_363_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab366
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab364
    ; ####increment refcount
    add qword [rsi + 0], 1

lab364:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab365
    ; ####increment refcount
    add qword [rax + 0], 1

lab365:
    jmp lab367

lab366:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab367:
    ; let x2: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(x2 := x2)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump mk_map_
    jmp mk_map_

List_List_Assign_363_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab370
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab368
    ; ####increment refcount
    add qword [r10 + 0], 1

lab368:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab369
    ; ####increment refcount
    add qword [r8 + 0], 1

lab369:
    jmp lab371

lab370:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab371:
    ; substitute (x1 := x1)(a1 := a1)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: List[List[Assign]] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab383
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab384

lab383:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab381
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab374
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab372
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab373

lab372:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab373:

lab374:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab377
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab375
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab376

lab375:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab376:

lab377:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab380
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab378
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab379

lab378:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab379:

lab380:
    jmp lab382

lab381:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab382:

lab384:
    ; #load tag
    mov r9, 5
    ; substitute (x1 := x1)(x2 := x2)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump mk_map_
    jmp mk_map_

Fun_List_Assign_Node_List_Assign_349:

Fun_List_Assign_Node_List_Assign_349_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab386
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab385
    ; ####increment refcount
    add qword [r8 + 0], 1

lab385:
    jmp lab387

lab386:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab387:
    ; substitute (f := f)(y := y)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump mk_init_tree_
    jmp mk_init_tree_

List_Node_List_Assign_334:
    jmp near List_Node_List_Assign_334_Nil
    jmp near List_Node_List_Assign_334_Cons

List_Node_List_Assign_334_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab390
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab388
    ; ####increment refcount
    add qword [rsi + 0], 1

lab388:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab389
    ; ####increment refcount
    add qword [rax + 0], 1

lab389:
    jmp lab391

lab390:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab391:
    ; let x0: List[Node[List[Assign]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x := x)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_List_Assign_334_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab394
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab392
    ; ####increment refcount
    add qword [r10 + 0], 1

lab392:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab393
    ; ####increment refcount
    add qword [r8 + 0], 1

lab393:
    jmp lab395

lab394:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab395:
    ; substitute (x := x)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[List[Assign]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab407
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab408

lab407:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab405
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab398
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab396
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab397

lab396:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab397:

lab398:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab401
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab399
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab400

lab399:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab400:

lab401:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab404
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab402
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab403

lab402:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab403:

lab404:
    jmp lab406

lab405:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab406:

lab408:
    ; #load tag
    mov r9, 5
    ; substitute (x := x)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

to_assign_:
    ; substitute (a0 := a0)(ss := ss)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_409]
    add rcx, r9
    jmp rcx

List_i64_409:
    jmp near List_i64_409_Nil
    jmp near List_i64_409_Cons

List_i64_409_Nil:
    ; substitute (a0 := a0);
    ; #erase ss
    cmp rsi, 0
    je lab412
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab410
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab411

lab410:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab411:

lab412:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_409_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab414
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab413
    ; ####increment refcount
    add qword [r10 + 0], 1

lab413:
    mov r9, [r8 + 40]
    jmp lab415

lab414:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab415:
    ; substitute (ss1 := ss)(ss := ss)(j := j)(t1 := t1)(a0 := a0);
    ; #share ss
    cmp rsi, 0
    je lab416
    ; ####increment refcount
    add qword [rsi + 0], 1

lab416:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, rsi
    mov rdx, rdi
    ; create a1: _Cont = (ss, j, t1, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab428
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab429

lab428:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab426
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab419
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab417
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab418

lab417:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab418:

lab419:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab422
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab420
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab421

lab420:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab421:

lab422:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab425
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab423
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab424

lab423:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab424:

lab425:
    jmp lab427

lab426:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab427:

lab429:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab441
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab442

lab441:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab439
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab432
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab430
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab431

lab430:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab431:

lab432:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab435
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab433
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab434

lab433:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab434:

lab435:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab438
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab436
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab437

lab436:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab437:

lab438:
    jmp lab440

lab439:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab440:

lab442:
    ; #load tag
    lea rdi, [rel _Cont_443]
    ; jump max_level_
    jmp max_level_

_Cont_443:

_Cont_443_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab447
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab444
    ; ####increment refcount
    add qword [rsi + 0], 1

lab444:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab445
    ; ####increment refcount
    add qword [r12 + 0], 1

lab445:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab446
    ; ####increment refcount
    add qword [r10 + 0], 1

lab446:
    mov r9, [r8 + 24]
    jmp lab448

lab447:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab448:
    ; lit x1 <- 1;
    mov r15, 1
    ; x2 <- x0 + x1;
    mov rcx, rdx
    add rcx, r15
    mov [rsp + 2024], rcx
    ; substitute (a0 := a0)(ss := ss)(t1 := t1)(x2 := x2)(j := j);
    ; #move variables
    mov rdx, r13
    mov r13, r9
    mov r8, r10
    mov r9, r11
    mov rax, r12
    mov r11, [rsp + 2024]
    ; let x3: Assign = Assign(x2, j);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab460
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab461

lab460:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab458
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab451
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab449
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab450

lab449:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab450:

lab451:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab454
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab452
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab453

lab452:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab453:

lab454:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab457
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab455
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab456

lab455:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab456:

lab457:
    jmp lab459

lab458:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab459:

lab461:
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(ss := ss)(t1 := t1)(x3 := x3)(ss0 := ss);
    ; #share ss
    cmp rsi, 0
    je lab462
    ; ####increment refcount
    add qword [rsi + 0], 1

lab462:
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    ; let x4: List[Assign] = Cons(x3, ss0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab474
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab475

lab474:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab472
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab465
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab463
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab464

lab463:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab464:

lab465:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab468
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab466
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab467

lab466:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab467:

lab468:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab471
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab469
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab470

lab469:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab470:

lab471:
    jmp lab473

lab472:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab473:

lab475:
    ; #load tag
    mov r11, 5
    ; substitute (t1 := t1)(ss := ss)(a0 := a0)(x4 := x4);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a2: List[List[Assign]] = (a0, x4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab487
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab488

lab487:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab485
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab478
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab476
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab477

lab476:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab477:

lab478:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab481
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab479
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab480

lab479:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab480:

lab481:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab484
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab482
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab483

lab482:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab483:

lab484:
    jmp lab486

lab485:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab486:

lab488:
    ; #load tag
    lea r9, [rel List_List_Assign_489]
    ; jump to_assign_
    jmp to_assign_

List_List_Assign_489:
    jmp near List_List_Assign_489_Nil
    jmp near List_List_Assign_489_Cons

List_List_Assign_489_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab492
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab490
    ; ####increment refcount
    add qword [rsi + 0], 1

lab490:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab491
    ; ####increment refcount
    add qword [rax + 0], 1

lab491:
    jmp lab493

lab492:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab493:
    ; let x5: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x4 := x4)(x5 := x5)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_489_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab496
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab494
    ; ####increment refcount
    add qword [r10 + 0], 1

lab494:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab495
    ; ####increment refcount
    add qword [r8 + 0], 1

lab495:
    jmp lab497

lab496:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab497:
    ; substitute (x4 := x4)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x5: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab509
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab510

lab509:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab507
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab500
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab498
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab499

lab498:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab499:

lab500:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab503
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab501
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab502

lab501:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab502:

lab503:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab506
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab504
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab505

lab504:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab505:

lab506:
    jmp lab508

lab507:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab508:

lab510:
    ; #load tag
    mov r9, 5
    ; substitute (x4 := x4)(x5 := x5)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

mk_tree_:
    ; substitute (a0 := a0)(csp := csp);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_511:

CSP_511_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab513
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab512
    ; ####increment refcount
    add qword [r10 + 0], 1

lab512:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab514

lab513:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab514:
    ; substitute (a0 := a0)(vars := vars)(vals := vals);
    ; #erase rel
    cmp r10, 0
    je lab517
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab515
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab516

lab515:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab516:

lab517:
    ; create next: Fun[List[Assign], List[List[Assign]]] = (vars, vals)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab529
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab530

lab529:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab527
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab520
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab518
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab519

lab518:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab519:

lab520:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab523
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab521
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab522

lab521:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab522:

lab523:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab526
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab524
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab525

lab524:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab525:

lab526:
    jmp lab528

lab527:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab528:

lab530:
    ; #load tag
    lea rdi, [rel Fun_List_Assign_List_List_Assign_531]
    ; let x3: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (next := next)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump mk_init_tree_
    jmp mk_init_tree_

Fun_List_Assign_List_List_Assign_531:

Fun_List_Assign_List_List_Assign_531_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab532
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab533

lab532:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab533:
    ; substitute (ss0 := ss)(a1 := a1)(vars := vars)(vals := vals)(ss := ss);
    ; #share ss
    cmp rax, 0
    je lab534
    ; ####increment refcount
    add qword [rax + 0], 1

lab534:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    ; create a2: _Cont = (a1, vars, vals, ss)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab546
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab547

lab546:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab544
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab537
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab535
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab536

lab535:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab536:

lab537:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab540
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab538
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab539

lab538:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab539:

lab540:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab543
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab541
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab542

lab541:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab542:

lab543:
    jmp lab545

lab544:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab545:

lab547:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab559
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab560

lab559:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab557
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab550
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab548
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab549

lab548:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab549:

lab550:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab553
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab551
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab552

lab551:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab552:

lab553:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab556
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab554
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab555

lab554:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab555:

lab556:
    jmp lab558

lab557:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab558:

lab560:
    ; #load tag
    lea rdi, [rel _Cont_561]
    ; jump max_level_
    jmp max_level_

_Cont_561:

_Cont_561_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab564
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab562
    ; ####increment refcount
    add qword [rsi + 0], 1

lab562:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab563
    ; ####increment refcount
    add qword [r12 + 0], 1

lab563:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab565

lab564:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab565:
    ; if x0 < vars \{ ... \}
    cmp rdx, r9
    jl lab566
    ; else branch
    ; substitute (a1 := a1);
    ; #erase ss
    cmp r12, 0
    je lab569
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab567
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab568

lab567:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab568:

lab569:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a1 Nil
    add rdx, 0
    jmp rdx

lab566:
    ; then branch
    ; substitute (vals := vals)(a1 := a1)(ss := ss);
    ; #move variables
    mov rdx, r11
    mov r8, r12
    mov r9, r13
    ; create a3: List[i64] = (a1, ss)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab581
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab582

lab581:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab579
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab572
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab570
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab571

lab570:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab571:

lab572:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab575
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab573
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab574

lab573:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab574:

lab575:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab578
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab576
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab577

lab576:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab577:

lab578:
    jmp lab580

lab579:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab580:

lab582:
    ; #load tag
    lea rdi, [rel List_i64_583]
    ; lit x2 <- 1;
    mov r9, 1
    ; substitute (x2 := x2)(vals := vals)(a3 := a3);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_583:
    jmp near List_i64_583_Nil
    jmp near List_i64_583_Cons

List_i64_583_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab586
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab584
    ; ####increment refcount
    add qword [rsi + 0], 1

lab584:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab585
    ; ####increment refcount
    add qword [rax + 0], 1

lab585:
    jmp lab587

lab586:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab587:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(ss := ss)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump to_assign_
    jmp to_assign_

List_i64_583_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab590
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab588
    ; ####increment refcount
    add qword [r10 + 0], 1

lab588:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab589
    ; ####increment refcount
    add qword [r8 + 0], 1

lab589:
    jmp lab591

lab590:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab591:
    ; substitute (ss := ss)(a1 := a1)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab603
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab604

lab603:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab601
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab594
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab592
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab593

lab592:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab593:

lab594:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab597
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab595
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab596

lab595:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab596:

lab597:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab600
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab598
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab599

lab598:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab599:

lab600:
    jmp lab602

lab601:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab602:

lab604:
    ; #load tag
    mov r9, 5
    ; substitute (x1 := x1)(ss := ss)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump to_assign_
    jmp to_assign_

ear_inc_filter_:
    ; substitute (f := f)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_605]
    add rcx, r9
    jmp rcx

List_Assign_605:
    jmp near List_Assign_605_Nil
    jmp near List_Assign_605_Cons

List_Assign_605_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab608
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab606
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab607

lab606:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab607:

lab608:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_605_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab611
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab609
    ; ####increment refcount
    add qword [r10 + 0], 1

lab609:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab610
    ; ####increment refcount
    add qword [r8 + 0], 1

lab610:
    jmp lab612

lab611:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab612:
    ; substitute (f0 := f)(a4 := a)(a := a)(as := as)(f := f)(a0 := a0);
    ; #share a
    cmp r8, 0
    je lab613
    ; ####increment refcount
    add qword [r8 + 0], 1

lab613:
    ; #share f
    cmp rax, 0
    je lab614
    ; ####increment refcount
    add qword [rax + 0], 1

lab614:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; create a2: Bool = (a, as, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab626
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab627

lab626:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab624
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab617
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab615
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab616

lab615:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab616:

lab617:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab620
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab618
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab619

lab618:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab619:

lab620:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab623
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab621
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab622

lab621:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab622:

lab623:
    jmp lab625

lab624:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab625:

lab627:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab639
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab640

lab639:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab637
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab630
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab628
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab629

lab628:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab629:

lab630:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab633
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab631
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab632

lab631:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab632:

lab633:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab636
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab634
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab635

lab634:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab635:

lab636:
    jmp lab638

lab637:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab638:

lab640:
    ; #load tag
    lea r9, [rel Bool_641]
    ; substitute (a4 := a4)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_641:
    jmp near Bool_641_True
    jmp near Bool_641_False

Bool_641_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab646
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab642
    ; ####increment refcount
    add qword [rax + 0], 1

lab642:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab643
    ; ####increment refcount
    add qword [r10 + 0], 1

lab643:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab644
    ; ####increment refcount
    add qword [r8 + 0], 1

lab644:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab645
    ; ####increment refcount
    add qword [rsi + 0], 1

lab645:
    jmp lab647

lab646:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab647:
    ; substitute (f := f)(as := as)(a := a)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Assign] = (a, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab659
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab660

lab659:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab657
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab650
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab648
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab649

lab648:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab649:

lab650:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab653
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab651
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab652

lab651:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab652:

lab653:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab656
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab654
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab655

lab654:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab655:

lab656:
    jmp lab658

lab657:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab658:

lab660:
    ; #load tag
    lea r9, [rel List_Assign_661]
    ; jump ear_inc_filter_
    jmp ear_inc_filter_

List_Assign_661:
    jmp near List_Assign_661_Nil
    jmp near List_Assign_661_Cons

List_Assign_661_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab664
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab662
    ; ####increment refcount
    add qword [rsi + 0], 1

lab662:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab663
    ; ####increment refcount
    add qword [rax + 0], 1

lab663:
    jmp lab665

lab664:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab665:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a := a)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Assign_661_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab668
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab666
    ; ####increment refcount
    add qword [r10 + 0], 1

lab666:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab667
    ; ####increment refcount
    add qword [r8 + 0], 1

lab667:
    jmp lab669

lab668:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab669:
    ; substitute (a0 := a0)(a := a)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab681
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab682

lab681:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab679
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab672
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab670
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab671

lab670:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab671:

lab672:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab675
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab673
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab674

lab673:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab674:

lab675:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab678
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab676
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab677

lab676:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab677:

lab678:
    jmp lab680

lab679:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab680:

lab682:
    ; #load tag
    mov r9, 5
    ; substitute (a := a)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_641_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab687
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab683
    ; ####increment refcount
    add qword [rax + 0], 1

lab683:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab684
    ; ####increment refcount
    add qword [r10 + 0], 1

lab684:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab685
    ; ####increment refcount
    add qword [r8 + 0], 1

lab685:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab686
    ; ####increment refcount
    add qword [rsi + 0], 1

lab686:
    jmp lab688

lab687:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab688:
    ; substitute (f := f)(as := as)(a0 := a0);
    ; #erase a
    cmp rax, 0
    je lab691
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab689
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab690

lab689:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab690:

lab691:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump ear_inc_filter_
    jmp ear_inc_filter_

earliest_inconsistency_:
    ; substitute (a0 := a0)(aas := aas)(csp := csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_692:

CSP_692_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab694
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab693
    ; ####increment refcount
    add qword [r12 + 0], 1

lab693:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab695

lab694:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab695:
    ; substitute (a0 := a0)(rel := rel)(aas := aas);
    ; #move variables
    mov r8, rsi
    mov r9, rdi
    mov rsi, r12
    mov rdi, r13
    ; switch aas \{ ... \};
    lea rcx, [rel List_Assign_696]
    add rcx, r9
    jmp rcx

List_Assign_696:
    jmp near List_Assign_696_Nil
    jmp near List_Assign_696_Cons

List_Assign_696_Nil:
    ; substitute (a0 := a0);
    ; #erase rel
    cmp rsi, 0
    je lab699
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab697
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab698

lab697:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab698:

lab699:
    ; invoke a0 None
    add rdx, 0
    jmp rdx

List_Assign_696_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab702
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab700
    ; ####increment refcount
    add qword [r10 + 0], 1

lab700:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab701
    ; ####increment refcount
    add qword [r8 + 0], 1

lab701:
    jmp lab703

lab702:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab703:
    ; substitute (a0 := a0)(as_ := as_)(a8 := a)(a := a)(rel := rel);
    ; #share a
    cmp r8, 0
    je lab704
    ; ####increment refcount
    add qword [r8 + 0], 1

lab704:
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    mov rsi, r10
    mov r10, r8
    mov rdi, r11
    mov r11, r9
    ; create x0: Fun[Assign, Bool] = (a, rel)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab716
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab717

lab716:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab714
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab707
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab705
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab706

lab705:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab706:

lab707:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab710
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab708
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab709

lab708:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab709:

lab710:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab713
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab711
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab712

lab711:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab712:

lab713:
    jmp lab715

lab714:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab715:

lab717:
    ; #load tag
    lea r11, [rel Fun_Assign_Bool_718]
    ; substitute (as_ := as_)(a0 := a0)(a8 := a8)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a5: List[Assign] = (a0, a8, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab730
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab731

lab730:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab728
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab721
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab719
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab720

lab719:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab720:

lab721:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab724
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab722
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab723

lab722:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab723:

lab724:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab727
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab725
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab726

lab725:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab726:

lab727:
    jmp lab729

lab728:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab729:

lab731:
    ; #load tag
    lea rdi, [rel List_Assign_732]
    ; jump reverse_
    jmp reverse_

List_Assign_732:
    jmp near List_Assign_732_Nil
    jmp near List_Assign_732_Cons

List_Assign_732_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab736
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab733
    ; ####increment refcount
    add qword [r8 + 0], 1

lab733:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab734
    ; ####increment refcount
    add qword [rsi + 0], 1

lab734:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab735
    ; ####increment refcount
    add qword [rax + 0], 1

lab735:
    jmp lab737

lab736:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab737:
    ; let x1: List[Assign] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a8 := a8)(a0 := a0)(x0 := x0)(x1 := x1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_earliest_inconsistency_0_
    jmp lift_earliest_inconsistency_0_

List_Assign_732_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab741
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab738
    ; ####increment refcount
    add qword [r12 + 0], 1

lab738:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab739
    ; ####increment refcount
    add qword [r10 + 0], 1

lab739:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab740
    ; ####increment refcount
    add qword [r8 + 0], 1

lab740:
    jmp lab742

lab741:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab742:
    ; substitute (x0 := x0)(a8 := a8)(a0 := a0)(a7 := a7)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x1: List[Assign] = Cons(a7, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab754
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab755

lab754:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab752
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab745
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab743
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab744

lab743:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab744:

lab745:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab748
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab746
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab747

lab746:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab747:

lab748:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab751
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab749
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab750

lab749:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab750:

lab751:
    jmp lab753

lab752:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab753:

lab755:
    ; #load tag
    mov r11, 5
    ; substitute (a8 := a8)(a0 := a0)(x0 := x0)(x1 := x1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_earliest_inconsistency_0_
    jmp lift_earliest_inconsistency_0_

Fun_Assign_Bool_718:

Fun_Assign_Bool_718_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab758
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab756
    ; ####increment refcount
    add qword [r10 + 0], 1

lab756:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab757
    ; ####increment refcount
    add qword [r8 + 0], 1

lab757:
    jmp lab759

lab758:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab759:
    ; substitute (x := x)(rel := rel)(a := a)(a3 := a3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a4: Bool = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab771
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab772

lab771:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab769
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab762
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab760
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab761

lab760:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab761:

lab762:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab765
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab763
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab764

lab763:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab764:

lab765:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab768
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab766
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab767

lab766:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab767:

lab768:
    jmp lab770

lab769:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab770:

lab772:
    ; #load tag
    lea r11, [rel Bool_773]
    ; substitute (a := a)(x := x)(a4 := a4)(rel := rel);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke rel Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

Bool_773:
    jmp near Bool_773_True
    jmp near Bool_773_False

Bool_773_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab775
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab774
    ; ####increment refcount
    add qword [rax + 0], 1

lab774:
    jmp lab776

lab775:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab776:
    ; let x5: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x5 := x5)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_773_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab778
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab777
    ; ####increment refcount
    add qword [rax + 0], 1

lab777:
    jmp lab779

lab778:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab779:
    ; let x5: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x5 := x5)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

lift_earliest_inconsistency_0_:
    ; substitute (x1 := x1)(x0 := x0)(a0 := a0)(a := a);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a6: List[Assign] = (a0, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab791
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab792

lab791:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab789
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab782
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab780
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab781

lab780:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab781:

lab782:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab785
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab783
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab784

lab783:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab784:

lab785:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab788
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab786
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab787

lab786:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab787:

lab788:
    jmp lab790

lab789:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab790:

lab792:
    ; #load tag
    lea r9, [rel List_Assign_793]
    ; substitute (x0 := x0)(x1 := x1)(a6 := a6);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump ear_inc_filter_
    jmp ear_inc_filter_

List_Assign_793:
    jmp near List_Assign_793_Nil
    jmp near List_Assign_793_Cons

List_Assign_793_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab796
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab794
    ; ####increment refcount
    add qword [rsi + 0], 1

lab794:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab795
    ; ####increment refcount
    add qword [rax + 0], 1

lab795:
    jmp lab797

lab796:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab797:
    ; substitute (a0 := a0);
    ; #erase a
    cmp rsi, 0
    je lab800
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab798
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab799

lab798:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab799:

lab800:
    ; invoke a0 None
    add rdx, 0
    jmp rdx

List_Assign_793_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab803
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab801
    ; ####increment refcount
    add qword [r10 + 0], 1

lab801:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab802
    ; ####increment refcount
    add qword [r8 + 0], 1

lab802:
    jmp lab804

lab803:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab804:
    ; substitute (a := a)(b := b)(a0 := a0);
    ; #erase bs_
    cmp rsi, 0
    je lab807
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab805
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab806

lab805:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab806:

lab807:
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r10
    mov rdx, r11
    ; create a1: _Cont = (b, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab819
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab820

lab819:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab817
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab810
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab808
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab809

lab808:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab809:

lab810:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab813
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab811
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab812

lab811:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab812:

lab813:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab816
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab814
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab815

lab814:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab815:

lab816:
    jmp lab818

lab817:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab818:

lab820:
    ; #load tag
    lea rdi, [rel _Cont_821]
    ; jump level_
    jmp level_

_Cont_821:

_Cont_821_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab824
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab822
    ; ####increment refcount
    add qword [r8 + 0], 1

lab822:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab823
    ; ####increment refcount
    add qword [rsi + 0], 1

lab823:
    jmp lab825

lab824:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab825:
    ; substitute (b := b)(x2 := x2)(a0 := a0);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; create a2: _Cont = (x2, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab837
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab838

lab837:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab835
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab828
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab826
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab827

lab826:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab827:

lab828:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab831
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab829
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab830

lab829:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab830:

lab831:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab834
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab832
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab833

lab832:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab833:

lab834:
    jmp lab836

lab835:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab836:

lab838:
    ; #load tag
    lea rdi, [rel _Cont_839]
    ; jump level_
    jmp level_

_Cont_839:

_Cont_839_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab841
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab840
    ; ####increment refcount
    add qword [r8 + 0], 1

lab840:
    mov rdi, [rsi + 40]
    jmp lab842

lab841:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab842:
    ; substitute (a0 := a0)(x2 := x2)(x3 := x3);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r8
    ; let x4: Pair[i64, i64] = Tup(x2, x3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab854
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab855

lab854:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab852
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab845
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab843
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab844

lab843:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab844:

lab845:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab848
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab846
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab847

lab846:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab847:

lab848:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab851
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab849
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab850

lab849:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab850:

lab851:
    jmp lab853

lab852:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab853:

lab855:
    ; #load tag
    mov rdi, 0
    ; substitute (x4 := x4)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Some
    add rdi, 5
    jmp rdi

known_conflict_:
    ; substitute (a0 := a0)(c := c);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_856]
    add rcx, rdi
    jmp rcx

ConflictSet_856:
    jmp near ConflictSet_856_Known
    jmp near ConflictSet_856_Unknown

ConflictSet_856_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab858
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab857
    ; ####increment refcount
    add qword [rsi + 0], 1

lab857:
    jmp lab859

lab858:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab859:
    ; switch vs \{ ... \};
    lea rcx, [rel List_i64_860]
    add rcx, rdi
    jmp rcx

List_i64_860:
    jmp near List_i64_860_Nil
    jmp near List_i64_860_Cons

List_i64_860_Nil:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

List_i64_860_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab862
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab861
    ; ####increment refcount
    add qword [r8 + 0], 1

lab861:
    mov rdi, [rsi + 40]
    jmp lab863

lab862:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab863:
    ; substitute (a0 := a0);
    ; #erase vs0
    cmp r8, 0
    je lab866
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab864
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab865

lab864:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab865:

lab866:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

ConflictSet_856_Unknown:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

known_solution_:
    ; substitute (a0 := a0)(c := c);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_867]
    add rcx, rdi
    jmp rcx

ConflictSet_867:
    jmp near ConflictSet_867_Known
    jmp near ConflictSet_867_Unknown

ConflictSet_867_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab869
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab868
    ; ####increment refcount
    add qword [rsi + 0], 1

lab868:
    jmp lab870

lab869:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab870:
    ; switch vs \{ ... \};
    lea rcx, [rel List_i64_871]
    add rcx, rdi
    jmp rcx

List_i64_871:
    jmp near List_i64_871_Nil
    jmp near List_i64_871_Cons

List_i64_871_Nil:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_i64_871_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab873
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab872
    ; ####increment refcount
    add qword [r8 + 0], 1

lab872:
    mov rdi, [rsi + 40]
    jmp lab874

lab873:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab874:
    ; substitute (a0 := a0);
    ; #erase vs0
    cmp r8, 0
    je lab877
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab875
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab876

lab875:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab876:

lab877:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

ConflictSet_867_Unknown:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

check_complete_:
    ; create a1: Bool = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab889
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab890

lab889:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab887
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab880
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab878
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab879

lab878:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab879:

lab880:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab883
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab881
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab882

lab881:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab882:

lab883:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab886
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab884
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab885

lab884:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab885:

lab886:
    jmp lab888

lab887:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab888:

lab890:
    ; #load tag
    lea r9, [rel Bool_891]
    ; jump complete_
    jmp complete_

Bool_891:
    jmp near Bool_891_True
    jmp near Bool_891_False

Bool_891_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab893
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab892
    ; ####increment refcount
    add qword [rax + 0], 1

lab892:
    jmp lab894

lab893:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab894:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Known
    add rdi, 0
    jmp rdi

Bool_891_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab896
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab895
    ; ####increment refcount
    add qword [rax + 0], 1

lab895:
    jmp lab897

lab896:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab897:
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

search_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_898]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_898:
    jmp near List_Node_Pair_List_Assign_ConflictSet_898_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_898_Cons

List_Node_Pair_List_Assign_ConflictSet_898_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab901
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab899
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab900

lab899:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab900:

lab901:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_898_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab904
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab902
    ; ####increment refcount
    add qword [r10 + 0], 1

lab902:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab903
    ; ####increment refcount
    add qword [r8 + 0], 1

lab903:
    jmp lab905

lab904:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab905:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab906
    ; ####increment refcount
    add qword [rax + 0], 1

lab906:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab918
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab919

lab918:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab916
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab909
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab907
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab908

lab907:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab908:

lab909:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab912
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab910
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab911

lab910:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab911:

lab912:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab915
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab913
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab914

lab913:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab914:

lab915:
    jmp lab917

lab916:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab917:

lab919:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_920]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_920:

Node_Pair_List_Assign_ConflictSet_920_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab924
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab921
    ; ####increment refcount
    add qword [r12 + 0], 1

lab921:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab922
    ; ####increment refcount
    add qword [r10 + 0], 1

lab922:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab923
    ; ####increment refcount
    add qword [r8 + 0], 1

lab923:
    jmp lab925

lab924:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab925:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab937
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab938

lab937:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab935
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab928
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab926
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab927

lab926:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab927:

lab928:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab931
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab929
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab930

lab929:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab930:

lab931:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab934
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab932
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab933

lab932:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab933:

lab934:
    jmp lab936

lab935:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab936:

lab938:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab950
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab951

lab950:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab948
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab941
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab939
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab940

lab939:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab940:

lab941:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab944
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab942
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab943

lab942:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab943:

lab944:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab947
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab945
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab946

lab945:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab946:

lab947:
    jmp lab949

lab948:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab949:

lab951:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_952]
    ; jump search_map_
    jmp search_map_

List_Node_Pair_List_Assign_ConflictSet_952:
    jmp near List_Node_Pair_List_Assign_ConflictSet_952_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_952_Cons

List_Node_Pair_List_Assign_ConflictSet_952_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab955
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab953
    ; ####increment refcount
    add qword [rsi + 0], 1

lab953:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab954
    ; ####increment refcount
    add qword [rax + 0], 1

lab954:
    jmp lab956

lab955:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab956:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_952_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab959
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab957
    ; ####increment refcount
    add qword [r10 + 0], 1

lab957:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab958
    ; ####increment refcount
    add qword [r8 + 0], 1

lab958:
    jmp lab960

lab959:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab960:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab972
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab973

lab972:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab970
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab963
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab961
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab962

lab961:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab962:

lab963:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab965

lab964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab965:

lab966:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab969
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab967
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab968

lab967:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab968:

lab969:
    jmp lab971

lab970:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab971:

lab973:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_filter_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_974]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_974:
    jmp near List_Node_Pair_List_Assign_ConflictSet_974_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_974_Cons

List_Node_Pair_List_Assign_ConflictSet_974_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab977
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab975
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab976

lab975:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab976:

lab977:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_974_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab980
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab978
    ; ####increment refcount
    add qword [r10 + 0], 1

lab978:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab979
    ; ####increment refcount
    add qword [r8 + 0], 1

lab979:
    jmp lab981

lab980:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab981:
    ; substitute (f0 := f)(p0 := p)(p := p)(ps := ps)(f := f)(a0 := a0);
    ; #share f
    cmp rax, 0
    je lab982
    ; ####increment refcount
    add qword [rax + 0], 1

lab982:
    ; #share p
    cmp r8, 0
    je lab983
    ; ####increment refcount
    add qword [r8 + 0], 1

lab983:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; create a2: Bool = (p, ps, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab995
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab996

lab995:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab993
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab986
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab984
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab985

lab984:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab985:

lab986:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab989
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab987
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab988

lab987:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab988:

lab989:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab992
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab990
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab991

lab990:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab991:

lab992:
    jmp lab994

lab993:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab994:

lab996:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1008
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1009

lab1008:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1006
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab999
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab997
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab998

lab997:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab998:

lab999:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1002
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1000
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1001

lab1000:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1001:

lab1002:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1005
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1003
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1004

lab1003:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1004:

lab1005:
    jmp lab1007

lab1006:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1007:

lab1009:
    ; #load tag
    lea r9, [rel Bool_1010]
    ; substitute (p0 := p0)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_1010:
    jmp near Bool_1010_True
    jmp near Bool_1010_False

Bool_1010_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1015
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1011
    ; ####increment refcount
    add qword [rax + 0], 1

lab1011:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab1012
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1012:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab1013
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1013:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab1014
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1014:
    jmp lab1016

lab1015:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab1016:
    ; substitute (f := f)(ps := ps)(p := p)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Node[Pair[List[Assign], ConflictSet]]] = (p, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1028
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1029

lab1028:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1026
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1019
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1017
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1018

lab1017:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1018:

lab1019:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1022
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1020
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1021

lab1020:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1021:

lab1022:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1025
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1023
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1024

lab1023:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1024:

lab1025:
    jmp lab1027

lab1026:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1027:

lab1029:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_1030]
    ; jump search_filter_
    jmp search_filter_

List_Node_Pair_List_Assign_ConflictSet_1030:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1030_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1030_Cons

List_Node_Pair_List_Assign_ConflictSet_1030_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1033
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1031
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1031:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1032
    ; ####increment refcount
    add qword [rax + 0], 1

lab1032:
    jmp lab1034

lab1033:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1034:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (p := p)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1030_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1037
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1035
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1035:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1036
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1036:
    jmp lab1038

lab1037:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1038:
    ; substitute (a0 := a0)(p := p)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1050
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1051

lab1050:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1048
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1041
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1039
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1040

lab1039:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1040:

lab1041:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1044
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1042
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1043

lab1042:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1043:

lab1044:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1047
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1045
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1046

lab1045:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1046:

lab1047:
    jmp lab1049

lab1048:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1049:

lab1051:
    ; #load tag
    mov r9, 5
    ; substitute (p := p)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_1010_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1056
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1052
    ; ####increment refcount
    add qword [rax + 0], 1

lab1052:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab1053
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1053:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab1054
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1054:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab1055
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1055:
    jmp lab1057

lab1056:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab1057:
    ; substitute (f := f)(ps := ps)(a0 := a0);
    ; #erase p
    cmp rax, 0
    je lab1060
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1058
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1059

lab1058:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1059:

lab1060:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump search_filter_
    jmp search_filter_

search_label_:
    ; substitute (a0 := a0)(n := n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_1061:

Node_Pair_List_Assign_ConflictSet_1061_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1064
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1062
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1062:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1063
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1063:
    jmp lab1065

lab1064:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1065:
    ; substitute (a0 := a0)(p := p);
    ; #erase cs
    cmp r8, 0
    je lab1068
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab1066
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab1067

lab1066:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab1067:

lab1068:
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_1069:

Pair_List_Assign_ConflictSet_1069_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1072
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1070
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1070:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1071
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1071:
    jmp lab1073

lab1072:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1073:
    ; substitute (a1 := a1)(b0 := b0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

search_fold_tree_:
    ; substitute (f := f)(a0 := a0)(n := n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_1074:

Node_Pair_List_Assign_ConflictSet_1074_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1077
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1075
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1075:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1076
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1076:
    jmp lab1078

lab1077:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1078:
    ; substitute (f0 := f)(c := c)(l := l)(a0 := a0)(f := f);
    ; #share f
    cmp rax, 0
    je lab1079
    ; ####increment refcount
    add qword [rax + 0], 1

lab1079:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a1: List[Node[Pair[List[Assign], ConflictSet]]] = (l, a0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1091
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1092

lab1091:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1089
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1082
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1080
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1081

lab1080:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1081:

lab1082:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1085
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1083
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1084

lab1083:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1084:

lab1085:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1088
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1086
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1087

lab1086:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1087:

lab1088:
    jmp lab1090

lab1089:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1090:

lab1092:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_1093]
    ; substitute (a1 := a1)(c := c)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x1: Fun[Node[Pair[List[Assign], ConflictSet]], Node[Pair[List[Assign], ConflictSet]]] = (f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1105
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1106

lab1105:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1103
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1096
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1094
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1095

lab1094:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1095:

lab1096:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1099
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1097
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1098

lab1097:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1098:

lab1099:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1102
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1100
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1101

lab1100:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1101:

lab1102:
    jmp lab1104

lab1103:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1104:

lab1106:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1107]
    ; substitute (x1 := x1)(c := c)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_map_
    jmp search_map_

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1107:

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1107_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1109
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1108
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1108:
    jmp lab1110

lab1109:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1110:
    ; substitute (f0 := f0)(x := x)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_fold_tree_
    jmp search_fold_tree_

List_Node_Pair_List_Assign_ConflictSet_1093:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1093_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1093_Cons

List_Node_Pair_List_Assign_ConflictSet_1093_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1114
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab1111
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1111:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab1112
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1112:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab1113
    ; ####increment refcount
    add qword [rax + 0], 1

lab1113:
    jmp lab1115

lab1114:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab1115:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (l := l)(x0 := x0)(a0 := a0)(f := f);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

List_Node_Pair_List_Assign_ConflictSet_1093_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1119
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1116
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1116:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1117
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1117:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1118
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1118:
    jmp lab1120

lab1119:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1120:
    ; substitute (f := f)(a0 := a0)(l := l)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1132
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1133

lab1132:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1130
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1123
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1121
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1122

lab1121:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1122:

lab1123:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1126
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1124
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1125

lab1124:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1125:

lab1126:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1128

lab1127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1128:

lab1129:
    jmp lab1131

lab1130:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1131:

lab1133:
    ; #load tag
    mov r11, 5
    ; substitute (l := l)(x0 := x0)(a0 := a0)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke f Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

search_filter_tree_:
    ; substitute (a0 := a0)(n := n)(p := p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create f: Fun2[Pair[List[Assign], ConflictSet], List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]] = (p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1145
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1146

lab1145:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1143
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1136
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1134
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1135

lab1134:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1135:

lab1136:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1139
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1137
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1138

lab1137:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1138:

lab1139:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1142
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1140
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1141

lab1140:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1141:

lab1142:
    jmp lab1144

lab1143:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1144:

lab1146:
    ; #load tag
    lea r9, [rel Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1147]
    ; substitute (f := f)(n := n)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_fold_tree_
    jmp search_fold_tree_

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1147:

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1147_Apply2:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab1149
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab1148
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1148:
    jmp lab1150

lab1149:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab1150:
    ; substitute (p := p)(cs := cs)(a1 := a1)(a := a);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a1, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1162
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1163

lab1162:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1160
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1153
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1151
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1152

lab1151:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1152:

lab1153:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1156
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1154
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1155

lab1154:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1155:

lab1156:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1159
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1157
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1158

lab1157:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1158:

lab1159:
    jmp lab1161

lab1160:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1161:

lab1163:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_1164]
    ; substitute (a2 := a2)(cs := cs)(p := p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x1: Fun[Node[Pair[List[Assign], ConflictSet]], Bool] = (p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1176
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1177

lab1176:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1174
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1167
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1165
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1166

lab1165:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1166:

lab1167:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1170
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1168
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1169

lab1168:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1169:

lab1170:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1173
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1171
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1172

lab1171:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1172:

lab1173:
    jmp lab1175

lab1174:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1175:

lab1177:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Bool_1178]
    ; substitute (x1 := x1)(cs := cs)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_filter_
    jmp search_filter_

Fun_Node_Pair_List_Assign_ConflictSet_Bool_1178:

Fun_Node_Pair_List_Assign_ConflictSet_Bool_1178_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1180
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1179
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1179:
    jmp lab1181

lab1180:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1181:
    ; create a4: Pair[List[Assign], ConflictSet] = (a3, p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1193
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1194

lab1193:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1191
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1184
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1182
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1183

lab1182:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1183:

lab1184:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1187
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1185
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1186

lab1185:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1186:

lab1187:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1190
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1188
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1189

lab1188:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1189:

lab1190:
    jmp lab1192

lab1191:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1192:

lab1194:
    ; #load tag
    lea rdi, [rel Pair_List_Assign_ConflictSet_1195]
    ; jump search_label_
    jmp search_label_

Pair_List_Assign_ConflictSet_1195:

Pair_List_Assign_ConflictSet_1195_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1198
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1196
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1196:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1197
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1197:
    jmp lab1199

lab1198:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1199:
    ; substitute (p := p)(a3 := a3)(a6 := a6)(b0 := b0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: Pair[List[Assign], ConflictSet] = Tup(a6, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1211
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1212

lab1211:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1209
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1202
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1200
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1201

lab1200:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1201:

lab1202:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1205
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1203
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1204

lab1203:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1204:

lab1205:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1208
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1206
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1207

lab1206:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1207:

lab1208:
    jmp lab1210

lab1209:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1210:

lab1212:
    ; #load tag
    mov r9, 0
    ; substitute (x2 := x2)(a3 := a3)(p := p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke p Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1164:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1164_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1164_Cons

List_Node_Pair_List_Assign_ConflictSet_1164_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1215
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1213
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1213:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1214
    ; ####increment refcount
    add qword [rax + 0], 1

lab1214:
    jmp lab1216

lab1215:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1216:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a := a)(x0 := x0)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1164_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1219
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1217
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1217:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1218
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1218:
    jmp lab1220

lab1219:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1220:
    ; substitute (a := a)(a1 := a1)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1232
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1233

lab1232:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1230
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1223
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1221
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1222

lab1221:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1222:

lab1223:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1226
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1224
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1225

lab1224:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1225:

lab1226:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1229
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1227
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1228

lab1227:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1228:

lab1229:
    jmp lab1231

lab1230:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1231:

lab1233:
    ; #load tag
    mov r9, 5
    ; substitute (a := a)(x0 := x0)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

search_prune_:
    ; substitute (a0 := a0)(n := n)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x0: Fun[Pair[List[Assign], ConflictSet], Bool] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1245
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1246

lab1245:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1243
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1236
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1234
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1235

lab1234:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1235:

lab1236:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1239
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1237
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1238

lab1237:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1238:

lab1239:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1242
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1240
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1241

lab1240:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1241:

lab1242:
    jmp lab1244

lab1243:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1244:

lab1246:
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_ConflictSet_Bool_1247]
    ; substitute (x0 := x0)(n := n)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_filter_tree_
    jmp search_filter_tree_

Fun_Pair_List_Assign_ConflictSet_Bool_1247:

Fun_Pair_List_Assign_ConflictSet_Bool_1247_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1249
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1248
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1248:
    jmp lab1250

lab1249:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1250:
    ; substitute (x := x)(f := f)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a2: Bool = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1262
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1263

lab1262:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1260
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1253
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1251
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1252

lab1251:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1252:

lab1253:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1256
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1254
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1255

lab1254:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1255:

lab1256:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1259
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1257
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1258

lab1257:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1258:

lab1259:
    jmp lab1261

lab1260:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1261:

lab1263:
    ; #load tag
    lea r9, [rel Bool_1264]
    ; substitute (x := x)(a2 := a2)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_1264:
    jmp near Bool_1264_True
    jmp near Bool_1264_False

Bool_1264_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1266
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1265
    ; ####increment refcount
    add qword [rax + 0], 1

lab1265:
    jmp lab1267

lab1266:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1267:
    ; let x1: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_1264_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1269
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1268
    ; ####increment refcount
    add qword [rax + 0], 1

lab1268:
    jmp lab1270

lab1269:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1270:
    ; let x1: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

search_map2_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_1271]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_1271:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1271_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1271_Cons

List_Node_Pair_List_Assign_ConflictSet_1271_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab1274
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1272
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1273

lab1272:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1273:

lab1274:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_1271_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1277
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1275
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1275:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1276
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1276:
    jmp lab1278

lab1277:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1278:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab1279
    ; ####increment refcount
    add qword [rax + 0], 1

lab1279:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: List[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1291
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1292

lab1291:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1289
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1282
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1280
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1281

lab1280:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1281:

lab1282:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1285
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1283
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1284

lab1283:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1284:

lab1285:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1288
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1286
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1287

lab1286:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1287:

lab1288:
    jmp lab1290

lab1289:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1290:

lab1292:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1293]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Pair_List_Assign_ConflictSet_1293:
    jmp near List_Pair_List_Assign_ConflictSet_1293_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1293_Cons

List_Pair_List_Assign_ConflictSet_1293_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1297
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab1294
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1294:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab1295
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1295:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab1296
    ; ####increment refcount
    add qword [rax + 0], 1

lab1296:
    jmp lab1298

lab1297:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab1298:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_search_map2_0_
    jmp lift_search_map2_0_

List_Pair_List_Assign_ConflictSet_1293_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1302
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1299
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1299:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1300
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1300:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1301
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1301:
    jmp lab1303

lab1302:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1303:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1315
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1316

lab1315:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1313
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1306
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1304
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1305

lab1304:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1305:

lab1306:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1309
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1307
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1308

lab1307:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1308:

lab1309:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1312
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1310
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1311

lab1310:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1311:

lab1312:
    jmp lab1314

lab1313:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1314:

lab1316:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_search_map2_0_
    jmp lift_search_map2_0_

lift_search_map2_0_:
    ; substitute (ps := ps)(f := f)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a2: List[List[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1328
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1329

lab1328:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1326
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1319
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1317
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1318

lab1317:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1318:

lab1319:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1322
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1320
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1321

lab1320:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1321:

lab1322:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1325
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1323
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1324

lab1323:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1324:

lab1325:
    jmp lab1327

lab1326:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1327:

lab1329:
    ; #load tag
    lea r9, [rel List_List_Pair_List_Assign_ConflictSet_1330]
    ; substitute (f := f)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_map2_
    jmp search_map2_

List_List_Pair_List_Assign_ConflictSet_1330:
    jmp near List_List_Pair_List_Assign_ConflictSet_1330_Nil
    jmp near List_List_Pair_List_Assign_ConflictSet_1330_Cons

List_List_Pair_List_Assign_ConflictSet_1330_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1333
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1331
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1331:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1332
    ; ####increment refcount
    add qword [rax + 0], 1

lab1332:
    jmp lab1334

lab1333:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1334:
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Pair_List_Assign_ConflictSet_1330_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1337
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1335
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1335:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1336
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1336:
    jmp lab1338

lab1337:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1338:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1350
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1351

lab1350:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1348
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1341
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1339
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1340

lab1339:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1340:

lab1341:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1344
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1342
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1343

lab1342:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1343:

lab1344:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1347
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1345
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1346

lab1345:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1346:

lab1347:
    jmp lab1349

lab1348:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1349:

lab1351:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_rev_loop_:
    ; substitute (a0 := a0)(l2 := l2)(l1 := l1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch l1 \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_1352]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_1352:
    jmp near List_Pair_List_Assign_ConflictSet_1352_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1352_Cons

List_Pair_List_Assign_ConflictSet_1352_Nil:
    ; switch l2 \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_1353]
    add rcx, rdi
    jmp rcx

List_Pair_List_Assign_ConflictSet_1353:
    jmp near List_Pair_List_Assign_ConflictSet_1353_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1353_Cons

List_Pair_List_Assign_ConflictSet_1353_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_List_Assign_ConflictSet_1353_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1356
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1354
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1354:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1355
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1355:
    jmp lab1357

lab1356:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1357:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_1352_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1360
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1358
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1358:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1359
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1359:
    jmp lab1361

lab1360:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1361:
    ; substitute (a0 := a0)(ps := ps)(p := p)(l2 := l2);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(p, l2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1373
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1374

lab1373:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1371
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1364
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1362
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1363

lab1362:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1363:

lab1364:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1367
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1365
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1366

lab1365:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1366:

lab1367:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1370
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1368
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1369

lab1368:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1369:

lab1370:
    jmp lab1372

lab1371:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1372:

lab1374:
    ; #load tag
    mov r9, 5
    ; substitute (ps := ps)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_rev_loop_
    jmp search_rev_loop_

search_rev_:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l := l)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_rev_loop_
    jmp search_rev_loop_

search_concat_loop_:
    ; substitute (a0 := a0)(acc := acc)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Pair_List_Assign_ConflictSet_1375]
    add rcx, r9
    jmp rcx

List_List_Pair_List_Assign_ConflictSet_1375:
    jmp near List_List_Pair_List_Assign_ConflictSet_1375_Nil
    jmp near List_List_Pair_List_Assign_ConflictSet_1375_Cons

List_List_Pair_List_Assign_ConflictSet_1375_Nil:
    ; substitute (acc := acc)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_rev_
    jmp search_rev_

List_List_Pair_List_Assign_ConflictSet_1375_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1378
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1376
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1376:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1377
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1377:
    jmp lab1379

lab1378:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1379:
    ; substitute (l := l)(acc := acc)(a0 := a0)(ls0 := ls0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Pair[List[Assign], ConflictSet]] = (a0, ls0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1391
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1392

lab1391:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1389
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1382
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1380
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1381

lab1380:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1381:

lab1382:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1385
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1383
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1384

lab1383:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1384:

lab1385:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1388
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1386
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1387

lab1386:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1387:

lab1388:
    jmp lab1390

lab1389:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1390:

lab1392:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1393]
    ; jump search_rev_loop_
    jmp search_rev_loop_

List_Pair_List_Assign_ConflictSet_1393:
    jmp near List_Pair_List_Assign_ConflictSet_1393_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1393_Cons

List_Pair_List_Assign_ConflictSet_1393_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1396
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1394
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1394:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1395
    ; ####increment refcount
    add qword [rax + 0], 1

lab1395:
    jmp lab1397

lab1396:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1397:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (ls0 := ls0)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_concat_loop_
    jmp search_concat_loop_

List_Pair_List_Assign_ConflictSet_1393_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1400
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1398
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1398:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1399
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1399:
    jmp lab1401

lab1400:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1401:
    ; substitute (ls0 := ls0)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1413
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1414

lab1413:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1411
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1404
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1402
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1403

lab1402:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1403:

lab1404:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1407
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1405
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1406

lab1405:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1406:

lab1407:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1410
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1408
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1409

lab1408:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1409:

lab1410:
    jmp lab1412

lab1411:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1412:

lab1414:
    ; #load tag
    mov r9, 5
    ; substitute (ls0 := ls0)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_concat_loop_
    jmp search_concat_loop_

search_concat_:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (ls := ls)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_concat_loop_
    jmp search_concat_loop_

search_leaves_:
    ; substitute (a0 := a0)(n := n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_1415:

Node_Pair_List_Assign_ConflictSet_1415_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1418
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1416
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1416:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1417
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1417:
    jmp lab1419

lab1418:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1419:
    ; switch cs \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_1420]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_1420:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1420_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1420_Cons

List_Node_Pair_List_Assign_ConflictSet_1420_Nil:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (leaf := leaf)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1420_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1423
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1421
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1421:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1422
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1422:
    jmp lab1424

lab1423:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1424:
    ; substitute (cs0 := cs0)(c := c)(a0 := a0);
    ; #erase leaf
    cmp rsi, 0
    je lab1427
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab1425
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab1426

lab1425:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab1426:

lab1427:
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rdi, r9
    mov r9, rdx
    mov rax, r10
    mov rdx, r11
    ; create a1: List[List[Pair[List[Assign], ConflictSet]]] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1439
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1440

lab1439:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1437
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1430
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1428
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1429

lab1428:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1429:

lab1430:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1433
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1431
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1432

lab1431:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1432:

lab1433:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1436
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1434
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1435

lab1434:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1435:

lab1436:
    jmp lab1438

lab1437:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1438:

lab1440:
    ; #load tag
    lea r9, [rel List_List_Pair_List_Assign_ConflictSet_1441]
    ; create x2: Fun[Node[Pair[List[Assign], ConflictSet]], List[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Node_Pair_List_Assign_ConflictSet_List_Pair_List_Assign_ConflictSet_1442]
    ; substitute (x2 := x2)(a1 := a1)(c := c)(cs0 := cs0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; let x3: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(c, cs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1454
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1455

lab1454:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1452
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1445
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1443
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1444

lab1443:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1444:

lab1445:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1448
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1446
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1447

lab1446:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1447:

lab1448:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1451
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1449
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1450

lab1449:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1450:

lab1451:
    jmp lab1453

lab1452:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1453:

lab1455:
    ; #load tag
    mov r9, 5
    ; substitute (x2 := x2)(x3 := x3)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_map2_
    jmp search_map2_

Fun_Node_Pair_List_Assign_ConflictSet_List_Pair_List_Assign_ConflictSet_1442:

Fun_Node_Pair_List_Assign_ConflictSet_List_Pair_List_Assign_ConflictSet_1442_Apply:
    ; jump search_leaves_
    jmp search_leaves_

List_List_Pair_List_Assign_ConflictSet_1441:
    jmp near List_List_Pair_List_Assign_ConflictSet_1441_Nil
    jmp near List_List_Pair_List_Assign_ConflictSet_1441_Cons

List_List_Pair_List_Assign_ConflictSet_1441_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1457
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1456
    ; ####increment refcount
    add qword [rax + 0], 1

lab1456:
    jmp lab1458

lab1457:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1458:
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_concat_
    jmp search_concat_

List_List_Pair_List_Assign_ConflictSet_1441_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1460
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1459
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1459:
    jmp lab1461

lab1460:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1461:
    ; substitute (a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1473
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1474

lab1473:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1471
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1464
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1462
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1463

lab1462:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1463:

lab1464:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1467
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1465
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1466

lab1465:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1466:

lab1467:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1470
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1468
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1469

lab1468:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1469:

lab1470:
    jmp lab1472

lab1471:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1472:

lab1474:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_concat_
    jmp search_concat_

search_map3_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_1475]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_1475:
    jmp near List_Pair_List_Assign_ConflictSet_1475_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1475_Cons

List_Pair_List_Assign_ConflictSet_1475_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab1478
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1476
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1477

lab1476:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1477:

lab1478:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_List_Assign_ConflictSet_1475_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1481
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1479
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1479:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1480
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1480:
    jmp lab1482

lab1481:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1482:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab1483
    ; ####increment refcount
    add qword [rax + 0], 1

lab1483:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: List[Assign] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1495
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1496

lab1495:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1493
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1486
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1484
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1485

lab1484:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1485:

lab1486:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1489
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1487
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1488

lab1487:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1488:

lab1489:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1492
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1490
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1491

lab1490:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1491:

lab1492:
    jmp lab1494

lab1493:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1494:

lab1496:
    ; #load tag
    lea r9, [rel List_Assign_1497]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Assign_1497:
    jmp near List_Assign_1497_Nil
    jmp near List_Assign_1497_Cons

List_Assign_1497_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1501
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab1498
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1498:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab1499
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1499:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab1500
    ; ####increment refcount
    add qword [rax + 0], 1

lab1500:
    jmp lab1502

lab1501:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab1502:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_search_map3_0_
    jmp lift_search_map3_0_

List_Assign_1497_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1506
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1503
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1503:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1504
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1504:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1505
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1505:
    jmp lab1507

lab1506:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1507:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1519
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1520

lab1519:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1517
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1510
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1508
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1509

lab1508:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1509:

lab1510:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1513
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1511
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1512

lab1511:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1512:

lab1513:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1516
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1514
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1515

lab1514:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1515:

lab1516:
    jmp lab1518

lab1517:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1518:

lab1520:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_search_map3_0_
    jmp lift_search_map3_0_

lift_search_map3_0_:
    ; substitute (ps := ps)(f := f)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a2: List[List[Assign]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1532
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1533

lab1532:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1530
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1523
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1521
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1522

lab1521:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1522:

lab1523:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1526
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1524
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1525

lab1524:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1525:

lab1526:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1529
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1527
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1528

lab1527:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1528:

lab1529:
    jmp lab1531

lab1530:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1531:

lab1533:
    ; #load tag
    lea r9, [rel List_List_Assign_1534]
    ; substitute (f := f)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_map3_
    jmp search_map3_

List_List_Assign_1534:
    jmp near List_List_Assign_1534_Nil
    jmp near List_List_Assign_1534_Cons

List_List_Assign_1534_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1537
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1535
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1535:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1536
    ; ####increment refcount
    add qword [rax + 0], 1

lab1536:
    jmp lab1538

lab1537:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1538:
    ; let x1: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_1534_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1541
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1539
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1539:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1540
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1540:
    jmp lab1542

lab1541:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1542:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1554
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1555

lab1554:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1552
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1545
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1543
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1544

lab1543:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1544:

lab1545:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1548
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1546
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1547

lab1546:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1547:

lab1548:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1551
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1549
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1550

lab1549:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1550:

lab1551:
    jmp lab1553

lab1552:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1553:

lab1555:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_filter2_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_1556]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_1556:
    jmp near List_Pair_List_Assign_ConflictSet_1556_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1556_Cons

List_Pair_List_Assign_ConflictSet_1556_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab1559
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1557
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1558

lab1557:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1558:

lab1559:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_List_Assign_ConflictSet_1556_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1562
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1560
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1560:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1561
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1561:
    jmp lab1563

lab1562:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1563:
    ; substitute (f0 := f)(p0 := p)(p := p)(ps := ps)(f := f)(a0 := a0);
    ; #share f
    cmp rax, 0
    je lab1564
    ; ####increment refcount
    add qword [rax + 0], 1

lab1564:
    ; #share p
    cmp r8, 0
    je lab1565
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1565:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; create a2: Bool = (p, ps, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1577
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1578

lab1577:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1575
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1568
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1566
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1567

lab1566:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1567:

lab1568:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1571
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1569
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1570

lab1569:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1570:

lab1571:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1574
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1572
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1573

lab1572:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1573:

lab1574:
    jmp lab1576

lab1575:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1576:

lab1578:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1590
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1591

lab1590:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1588
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1581
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1579
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1580

lab1579:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1580:

lab1581:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1584
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1582
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1583

lab1582:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1583:

lab1584:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1587
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1585
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1586

lab1585:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1586:

lab1587:
    jmp lab1589

lab1588:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1589:

lab1591:
    ; #load tag
    lea r9, [rel Bool_1592]
    ; substitute (p0 := p0)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_1592:
    jmp near Bool_1592_True
    jmp near Bool_1592_False

Bool_1592_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1597
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1593
    ; ####increment refcount
    add qword [rax + 0], 1

lab1593:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab1594
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1594:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab1595
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1595:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab1596
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1596:
    jmp lab1598

lab1597:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab1598:
    ; substitute (f := f)(ps := ps)(p := p)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Pair[List[Assign], ConflictSet]] = (p, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1610
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1611

lab1610:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1608
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1601
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1599
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1600

lab1599:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1600:

lab1601:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1604
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1602
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1603

lab1602:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1603:

lab1604:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1607
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1605
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1606

lab1605:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1606:

lab1607:
    jmp lab1609

lab1608:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1609:

lab1611:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1612]
    ; jump search_filter2_
    jmp search_filter2_

List_Pair_List_Assign_ConflictSet_1612:
    jmp near List_Pair_List_Assign_ConflictSet_1612_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1612_Cons

List_Pair_List_Assign_ConflictSet_1612_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1615
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1613
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1613:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1614
    ; ####increment refcount
    add qword [rax + 0], 1

lab1614:
    jmp lab1616

lab1615:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1616:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (p := p)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_1612_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1619
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1617
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1617:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1618
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1618:
    jmp lab1620

lab1619:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1620:
    ; substitute (a0 := a0)(p := p)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1632
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1633

lab1632:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1630
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1623
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1621
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1622

lab1621:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1622:

lab1623:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1626
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1624
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1625

lab1624:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1625:

lab1626:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1629
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1627
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1628

lab1627:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1628:

lab1629:
    jmp lab1631

lab1630:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1631:

lab1633:
    ; #load tag
    mov r9, 5
    ; substitute (p := p)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_1592_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1638
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1634
    ; ####increment refcount
    add qword [rax + 0], 1

lab1634:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab1635
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1635:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab1636
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1636:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab1637
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1637:
    jmp lab1639

lab1638:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab1639:
    ; substitute (f := f)(ps := ps)(a0 := a0);
    ; #erase p
    cmp rax, 0
    je lab1642
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1640
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1641

lab1640:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1641:

lab1642:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump search_filter2_
    jmp search_filter2_

search_fst_:
    ; substitute (a0 := a0)(p := p);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_1643:

Pair_List_Assign_ConflictSet_1643_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1646
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1644
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1644:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1645
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1645:
    jmp lab1647

lab1646:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1647:
    ; substitute (a0 := a0)(l := l);
    ; #erase c
    cmp r8, 0
    je lab1650
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab1648
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab1649

lab1648:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab1649:

lab1650:
    ; switch l \{ ... \};
    lea rcx, [rel List_Assign_1651]
    add rcx, rdi
    jmp rcx

List_Assign_1651:
    jmp near List_Assign_1651_Nil
    jmp near List_Assign_1651_Cons

List_Assign_1651_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_1651_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1654
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1652
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1652:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1653
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1653:
    jmp lab1655

lab1654:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1655:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_snd_:
    ; substitute (a0 := a0)(p := p);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_1656:

Pair_List_Assign_ConflictSet_1656_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1659
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1657
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1657:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1658
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1658:
    jmp lab1660

lab1659:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1660:
    ; substitute (a0 := a0)(c := c);
    ; #erase l
    cmp rsi, 0
    je lab1663
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab1661
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab1662

lab1661:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab1662:

lab1663:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_1664]
    add rcx, rdi
    jmp rcx

ConflictSet_1664:
    jmp near ConflictSet_1664_Known
    jmp near ConflictSet_1664_Unknown

ConflictSet_1664_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1666
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab1665
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1665:
    jmp lab1667

lab1666:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab1667:
    ; substitute (vs0 := vs0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Known
    add rdi, 0
    jmp rdi

ConflictSet_1664_Unknown:
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

search_:
    ; create x2: Fun[Pair[List[Assign], ConflictSet], List[Assign]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_List_Assign_ConflictSet_List_Assign_1668]
    ; create a2: List[Pair[List[Assign], ConflictSet]] = (a0, x2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1680
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1681

lab1680:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1678
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1671
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1669
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1670

lab1669:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1670:

lab1671:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1674
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1672
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1673

lab1672:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1673:

lab1674:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1677
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1675
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1676

lab1675:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1676:

lab1677:
    jmp lab1679

lab1678:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1679:

lab1681:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1682]
    ; create x4: Fun[Pair[List[Assign], ConflictSet], Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_List_Assign_ConflictSet_Bool_1683]
    ; create a5: List[Pair[List[Assign], ConflictSet]] = (a2, x4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1695
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1696

lab1695:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1693
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1686
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1684
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1685

lab1684:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1685:

lab1686:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1689
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1687
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1688

lab1687:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1688:

lab1689:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1692
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1690
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1691

lab1690:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1691:

lab1692:
    jmp lab1694

lab1693:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1694:

lab1696:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1697]
    ; create a6: Node[Pair[List[Assign], ConflictSet]] = (a5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1709
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1710

lab1709:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1707
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1700
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1698
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1699

lab1698:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1699:

lab1700:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1703
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1701
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1702

lab1701:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1702:

lab1703:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1706
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1704
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1705

lab1704:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1705:

lab1706:
    jmp lab1708

lab1707:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1708:

lab1710:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_1711]
    ; create x7: Fun[Pair[List[Assign], ConflictSet], Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_List_Assign_ConflictSet_Bool_1712]
    ; create a9: Node[Pair[List[Assign], ConflictSet]] = (a6, x7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1724
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1725

lab1724:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1722
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1715
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1713
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1714

lab1713:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1714:

lab1715:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1718
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1716
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1717

lab1716:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1717:

lab1718:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1721
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1719
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1720

lab1719:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1720:

lab1721:
    jmp lab1723

lab1722:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1723:

lab1725:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_1726]
    ; substitute (csp0 := csp)(csp := csp)(a9 := a9)(labeler := labeler);
    ; #share csp
    cmp rsi, 0
    je lab1727
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1727:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov rdx, rdi
    ; create a10: Node[List[Assign]] = (csp, a9, labeler)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1739
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1740

lab1739:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1737
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1730
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1728
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1729

lab1728:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1729:

lab1730:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1733
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1731
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1732

lab1731:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1732:

lab1733:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1736
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1734
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1735

lab1734:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1735:

lab1736:
    jmp lab1738

lab1737:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1738:

lab1740:
    ; #load tag
    lea rdi, [rel Node_List_Assign_1741]
    ; jump mk_tree_
    jmp mk_tree_

Node_List_Assign_1741:

Node_List_Assign_1741_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1745
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1742
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1742:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1743
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1743:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1744
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1744:
    jmp lab1746

lab1745:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1746:
    ; substitute (labeler := labeler)(a9 := a9)(csp := csp)(lab2 := lab2)(children2 := children2);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x9: Node[List[Assign]] = Node(lab2, children2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1758
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1759

lab1758:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1756
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1749
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1747
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1748

lab1747:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1748:

lab1749:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1752
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1750
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1751

lab1750:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1751:

lab1752:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1755
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1753
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1754

lab1753:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1754:

lab1755:
    jmp lab1757

lab1756:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1757:

lab1759:
    ; #load tag
    mov r11, 0
    ; substitute (csp := csp)(x9 := x9)(a9 := a9)(labeler := labeler);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke labeler Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

Node_Pair_List_Assign_ConflictSet_1726:

Node_Pair_List_Assign_ConflictSet_1726_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1762
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1760
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1760:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1761
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1761:
    jmp lab1763

lab1762:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1763:
    ; substitute (x7 := x7)(a6 := a6)(lab1 := lab1)(children1 := children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x8: Node[Pair[List[Assign], ConflictSet]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1775
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1776

lab1775:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1773
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1766
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1764
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1765

lab1764:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1765:

lab1766:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1769
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1767
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1768

lab1767:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1768:

lab1769:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1772
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1770
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1771

lab1770:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1771:

lab1772:
    jmp lab1774

lab1773:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1774:

lab1776:
    ; #load tag
    mov r9, 0
    ; substitute (x7 := x7)(x8 := x8)(a6 := a6);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_prune_
    jmp search_prune_

Fun_Pair_List_Assign_ConflictSet_Bool_1712:

Fun_Pair_List_Assign_ConflictSet_Bool_1712_Apply:
    ; create a8: ConflictSet = (a7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1788
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1789

lab1788:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1786
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1779
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1777
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1778

lab1777:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1778:

lab1779:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1782
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1780
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1781

lab1780:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1781:

lab1782:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1785
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1783
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1784

lab1783:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1784:

lab1785:
    jmp lab1787

lab1786:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1787:

lab1789:
    ; #load tag
    lea rdi, [rel ConflictSet_1790]
    ; jump search_snd_
    jmp search_snd_

ConflictSet_1790:
    jmp near ConflictSet_1790_Known
    jmp near ConflictSet_1790_Unknown

ConflictSet_1790_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1792
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab1791
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1791:
    jmp lab1793

lab1792:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab1793:
    ; substitute (a7 := a7)(vs1 := vs1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x10: ConflictSet = Known(vs1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1805
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1806

lab1805:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1803
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1796
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1794
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1795

lab1794:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1795:

lab1796:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1799
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1797
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1798

lab1797:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1798:

lab1799:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1802
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1800
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1801

lab1800:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1801:

lab1802:
    jmp lab1804

lab1803:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1804:

lab1806:
    ; #load tag
    mov rdi, 0
    ; substitute (x10 := x10)(a7 := a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_conflict_
    jmp known_conflict_

ConflictSet_1790_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1808
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1807
    ; ####increment refcount
    add qword [rax + 0], 1

lab1807:
    jmp lab1809

lab1808:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1809:
    ; let x10: ConflictSet = Unknown();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x10 := x10)(a7 := a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_conflict_
    jmp known_conflict_

Node_Pair_List_Assign_ConflictSet_1711:

Node_Pair_List_Assign_ConflictSet_1711_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1811
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1810
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1810:
    jmp lab1812

lab1811:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1812:
    ; substitute (a5 := a5)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x6: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1824
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1825

lab1824:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1822
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1815
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1813
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1814

lab1813:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1814:

lab1815:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1818
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1816
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1817

lab1816:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1817:

lab1818:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1821
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1819
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1820

lab1819:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1820:

lab1821:
    jmp lab1823

lab1822:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1823:

lab1825:
    ; #load tag
    mov rdi, 0
    ; substitute (x6 := x6)(a5 := a5);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_leaves_
    jmp search_leaves_

List_Pair_List_Assign_ConflictSet_1697:
    jmp near List_Pair_List_Assign_ConflictSet_1697_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1697_Cons

List_Pair_List_Assign_ConflictSet_1697_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1828
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1826
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1826:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1827
    ; ####increment refcount
    add qword [rax + 0], 1

lab1827:
    jmp lab1829

lab1828:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1829:
    ; let x5: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x4 := x4)(x5 := x5)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_filter2_
    jmp search_filter2_

List_Pair_List_Assign_ConflictSet_1697_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1832
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1830
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1830:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1831
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1831:
    jmp lab1833

lab1832:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1833:
    ; substitute (x4 := x4)(a2 := a2)(a12 := a12)(as1 := as1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x5: List[Pair[List[Assign], ConflictSet]] = Cons(a12, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1845
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1846

lab1845:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1843
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1835

lab1834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1835:

lab1836:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1839
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1837
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1838

lab1837:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1838:

lab1839:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1842
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1840
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1841

lab1840:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1841:

lab1842:
    jmp lab1844

lab1843:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1844:

lab1846:
    ; #load tag
    mov r9, 5
    ; substitute (x4 := x4)(x5 := x5)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_filter2_
    jmp search_filter2_

Fun_Pair_List_Assign_ConflictSet_Bool_1683:

Fun_Pair_List_Assign_ConflictSet_Bool_1683_Apply:
    ; create a4: ConflictSet = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1858
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1859

lab1858:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1856
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1849
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1847
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1848

lab1847:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1848:

lab1849:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1852
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1850
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1851

lab1850:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1851:

lab1852:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1855
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1853
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1854

lab1853:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1854:

lab1855:
    jmp lab1857

lab1856:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1857:

lab1859:
    ; #load tag
    lea rdi, [rel ConflictSet_1860]
    ; jump search_snd_
    jmp search_snd_

ConflictSet_1860:
    jmp near ConflictSet_1860_Known
    jmp near ConflictSet_1860_Unknown

ConflictSet_1860_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1862
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab1861
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1861:
    jmp lab1863

lab1862:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab1863:
    ; substitute (a3 := a3)(vs0 := vs0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x11: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1875
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1876

lab1875:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1873
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1866
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1864
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1865

lab1864:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1865:

lab1866:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1869
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1867
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1868

lab1867:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1868:

lab1869:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1872
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1870
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1871

lab1870:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1871:

lab1872:
    jmp lab1874

lab1873:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1874:

lab1876:
    ; #load tag
    mov rdi, 0
    ; substitute (x11 := x11)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_solution_
    jmp known_solution_

ConflictSet_1860_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1878
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1877
    ; ####increment refcount
    add qword [rax + 0], 1

lab1877:
    jmp lab1879

lab1878:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1879:
    ; let x11: ConflictSet = Unknown();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x11 := x11)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_solution_
    jmp known_solution_

List_Pair_List_Assign_ConflictSet_1682:
    jmp near List_Pair_List_Assign_ConflictSet_1682_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1682_Cons

List_Pair_List_Assign_ConflictSet_1682_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1882
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1880
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1880:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1881
    ; ####increment refcount
    add qword [rax + 0], 1

lab1881:
    jmp lab1883

lab1882:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1883:
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x2 := x2)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_map3_
    jmp search_map3_

List_Pair_List_Assign_ConflictSet_1682_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1886
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1884
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1884:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1885
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1885:
    jmp lab1887

lab1886:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1887:
    ; substitute (x2 := x2)(a0 := a0)(a11 := a11)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Cons(a11, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1899
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1900

lab1899:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1897
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1890
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1888
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1889

lab1888:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1889:

lab1890:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1893
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1891
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1892

lab1891:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1892:

lab1893:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1896
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1894
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1895

lab1894:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1895:

lab1896:
    jmp lab1898

lab1897:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1898:

lab1900:
    ; #load tag
    mov r9, 5
    ; substitute (x2 := x2)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_map3_
    jmp search_map3_

Fun_Pair_List_Assign_ConflictSet_List_Assign_1668:

Fun_Pair_List_Assign_ConflictSet_List_Assign_1668_Apply:
    ; jump search_fst_
    jmp search_fst_

bt_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_List_Assign_1901]
    add rcx, r9
    jmp rcx

List_Node_List_Assign_1901:
    jmp near List_Node_List_Assign_1901_Nil
    jmp near List_Node_List_Assign_1901_Cons

List_Node_List_Assign_1901_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab1904
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1902
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1903

lab1902:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1903:

lab1904:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_List_Assign_1901_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1907
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1905
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1905:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1906
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1906:
    jmp lab1908

lab1907:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1908:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab1909
    ; ####increment refcount
    add qword [rax + 0], 1

lab1909:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1921
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1922

lab1921:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1919
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1912
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1910
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1911

lab1910:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1911:

lab1912:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1915
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1913
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1914

lab1913:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1914:

lab1915:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1918
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1916
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1917

lab1916:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1917:

lab1918:
    jmp lab1920

lab1919:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1920:

lab1922:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_1923]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_1923:

Node_Pair_List_Assign_ConflictSet_1923_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1927
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1924
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1924:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1925
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1925:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1926
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1926:
    jmp lab1928

lab1927:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1928:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1940
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1941

lab1940:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1938
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1931
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1929
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1930

lab1929:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1930:

lab1931:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1934
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1932
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1933

lab1932:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1933:

lab1934:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1937
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1935
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1936

lab1935:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1936:

lab1937:
    jmp lab1939

lab1938:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1939:

lab1941:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1953
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1954

lab1953:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1951
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1944
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1942
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1943

lab1942:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1943:

lab1944:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1947
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1945
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1946

lab1945:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1946:

lab1947:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1950
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1948
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1949

lab1948:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1949:

lab1950:
    jmp lab1952

lab1951:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1952:

lab1954:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_1955]
    ; jump bt_map_
    jmp bt_map_

List_Node_Pair_List_Assign_ConflictSet_1955:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1955_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1955_Cons

List_Node_Pair_List_Assign_ConflictSet_1955_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1958
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1956
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1956:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1957
    ; ####increment refcount
    add qword [rax + 0], 1

lab1957:
    jmp lab1959

lab1958:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1959:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1955_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1962
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1960
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1960:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1961
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1961:
    jmp lab1963

lab1962:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1963:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1975
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1976

lab1975:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1973
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1965

lab1964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1965:

lab1966:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1969
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1967
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1968

lab1967:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1968:

lab1969:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1972
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1970
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1971

lab1970:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1971:

lab1972:
    jmp lab1974

lab1973:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1974:

lab1976:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bt_map_tree_:
    ; substitute (f := f)(a0 := a0)(n := n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_List_Assign_1977:

Node_List_Assign_1977_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1980
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1978
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1978:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1979
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1979:
    jmp lab1981

lab1980:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1981:
    ; substitute (f0 := f)(l := l)(a0 := a0)(ls := ls)(f := f);
    ; #share f
    cmp rax, 0
    je lab1982
    ; ####increment refcount
    add qword [rax + 0], 1

lab1982:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[List[Assign], ConflictSet] = (a0, ls, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1994
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1995

lab1994:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1992
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1985
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1983
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1984

lab1983:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1984:

lab1985:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1988
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1986
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1987

lab1986:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1987:

lab1988:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1991
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1989
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1990

lab1989:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1990:

lab1991:
    jmp lab1993

lab1992:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1993:

lab1995:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_1996]
    ; substitute (l := l)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_List_Assign_ConflictSet_1996:

Pair_List_Assign_ConflictSet_1996_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2000
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1997
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1997:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1998
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1998:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1999
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1999:
    jmp lab2001

lab2000:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab2001:
    ; substitute (f := f)(ls := ls)(a0 := a0)(a5 := a5)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2013
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2014

lab2013:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2011
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2004
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2002
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2003

lab2002:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2003:

lab2004:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2007
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2005
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2006

lab2005:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2006:

lab2007:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2010
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2008
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2009

lab2008:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2009:

lab2010:
    jmp lab2012

lab2011:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2012:

lab2014:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2026
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2027

lab2026:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2024
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2017
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2015
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2016

lab2015:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2016:

lab2017:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2020
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2018
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2019

lab2018:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2019:

lab2020:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2023
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2021
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2022

lab2021:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2022:

lab2023:
    jmp lab2025

lab2024:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2025:

lab2027:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_2028]
    ; substitute (a2 := a2)(ls := ls)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x2: Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2040
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2041

lab2040:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2038
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2031
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2029
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2030

lab2029:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2030:

lab2031:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2034
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2032
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2033

lab2032:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2033:

lab2034:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2037
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2035
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2036

lab2035:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2036:

lab2037:
    jmp lab2039

lab2038:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2039:

lab2041:
    ; #load tag
    lea r9, [rel Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_2042]
    ; substitute (x2 := x2)(ls := ls)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bt_map_
    jmp bt_map_

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_2042:

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_2042_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2044
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab2043
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2043:
    jmp lab2045

lab2044:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab2045:
    ; substitute (f := f)(x := x)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bt_map_tree_
    jmp bt_map_tree_

List_Node_Pair_List_Assign_ConflictSet_2028:
    jmp near List_Node_Pair_List_Assign_ConflictSet_2028_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_2028_Cons

List_Node_Pair_List_Assign_ConflictSet_2028_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2048
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2046
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2046:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2047
    ; ####increment refcount
    add qword [rax + 0], 1

lab2047:
    jmp lab2049

lab2048:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2049:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_2028_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2052
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2050
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2050:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2051
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2051:
    jmp lab2053

lab2052:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2053:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2065
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2066

lab2065:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2063
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2056
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2054
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2055

lab2054:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2055:

lab2056:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2059
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2057
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2058

lab2057:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2058:

lab2059:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2062
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2060
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2061

lab2060:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2061:

lab2062:
    jmp lab2064

lab2063:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2064:

lab2066:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bt_:
    ; substitute (a0 := a0)(t := t)(csp := csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create f3: Fun[List[Assign], Pair[List[Assign], ConflictSet]] = (csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2078
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2079

lab2078:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2076
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2069
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2067
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2068

lab2067:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2068:

lab2069:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2072
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2070
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2071

lab2070:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2071:

lab2072:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2075
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2073
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2074

lab2073:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2074:

lab2075:
    jmp lab2077

lab2076:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2077:

lab2079:
    ; #load tag
    lea r9, [rel Fun_List_Assign_Pair_List_Assign_ConflictSet_2080]
    ; substitute (f3 := f3)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bt_map_tree_
    jmp bt_map_tree_

Fun_List_Assign_Pair_List_Assign_ConflictSet_2080:

Fun_List_Assign_Pair_List_Assign_ConflictSet_2080_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2082
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab2081
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2081:
    jmp lab2083

lab2082:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab2083:
    ; substitute (s0 := s)(csp := csp)(a1 := a1)(s := s);
    ; #share s
    cmp rax, 0
    je lab2084
    ; ####increment refcount
    add qword [rax + 0], 1

lab2084:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a2: ConflictSet = (a1, s)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2096
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2097

lab2096:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2094
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2087
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2085
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2086

lab2085:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2086:

lab2087:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2090
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2088
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2089

lab2088:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2089:

lab2090:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2093
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2091
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2092

lab2091:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2092:

lab2093:
    jmp lab2095

lab2094:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2095:

lab2097:
    ; #load tag
    lea r9, [rel ConflictSet_2098]
    ; substitute (s00 := s0)(csp0 := csp)(a2 := a2)(s0 := s0)(csp := csp);
    ; #share csp
    cmp rsi, 0
    je lab2099
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2099:
    ; #share s0
    cmp rax, 0
    je lab2100
    ; ####increment refcount
    add qword [rax + 0], 1

lab2100:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov r12, rsi
    mov r13, rdi
    ; create a3: Option[Pair[i64, i64]] = (a2, s0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2112
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2113

lab2112:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2110
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2103
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2101
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2102

lab2101:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2102:

lab2103:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2106
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2104
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2105

lab2104:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2105:

lab2106:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2109
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2107
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2108

lab2107:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2108:

lab2109:
    jmp lab2111

lab2110:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2111:

lab2113:
    ; #load tag
    lea r9, [rel Option_Pair_i64_i64_2114]
    ; substitute (csp0 := csp0)(s00 := s00)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump earliest_inconsistency_
    jmp earliest_inconsistency_

Option_Pair_i64_i64_2114:
    jmp near Option_Pair_i64_i64_2114_None
    jmp near Option_Pair_i64_i64_2114_Some

Option_Pair_i64_i64_2114_None:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2118
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab2115
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2115:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab2116
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2116:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab2117
    ; ####increment refcount
    add qword [rax + 0], 1

lab2117:
    jmp lab2119

lab2118:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab2119:
    ; substitute (csp := csp)(s0 := s0)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump check_complete_
    jmp check_complete_

Option_Pair_i64_i64_2114_Some:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2123
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2120
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2120:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2121
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2121:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab2122
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2122:
    jmp lab2124

lab2123:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab2124:
    ; substitute (a2 := a2)(p := p);
    ; #erase csp
    cmp r10, 0
    je lab2127
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab2125
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab2126

lab2125:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab2126:

lab2127:
    ; #erase s0
    cmp r8, 0
    je lab2130
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2128
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2129

lab2128:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2129:

lab2130:
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_i64_i64_2131:

Pair_i64_i64_2131_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2132
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab2133

lab2132:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab2133:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; let x2: List[i64] = Cons(b, x1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2145
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2146

lab2145:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2143
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2136
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2134
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2135

lab2134:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2135:

lab2136:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2139
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2137
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2138

lab2137:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2138:

lab2139:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2142
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2140
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2141

lab2140:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2141:

lab2142:
    jmp lab2144

lab2143:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2144:

lab2146:
    ; #load tag
    mov r9, 5
    ; let x3: List[i64] = Cons(a, x2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2158
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2159

lab2158:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2156
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2149
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2147
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2148

lab2147:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2148:

lab2149:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2152
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2150
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2151

lab2150:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2151:

lab2152:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2155
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2153
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2154

lab2153:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2154:

lab2155:
    jmp lab2157

lab2156:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2157:

lab2159:
    ; #load tag
    mov rdi, 5
    ; substitute (x3 := x3)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a2 Known
    add rdi, 0
    jmp rdi

ConflictSet_2098:
    jmp near ConflictSet_2098_Known
    jmp near ConflictSet_2098_Unknown

ConflictSet_2098_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2162
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab2160
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2160:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab2161
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2161:
    jmp lab2163

lab2162:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab2163:
    ; substitute (s := s)(a1 := a1)(vs0 := vs0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2175
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2176

lab2175:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2173
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2166
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2164
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2165

lab2164:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2165:

lab2166:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2169
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2167
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2168

lab2167:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2168:

lab2169:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2172
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2170
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2171

lab2170:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2171:

lab2172:
    jmp lab2174

lab2173:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2174:

lab2176:
    ; #load tag
    mov r9, 0
    ; substitute (s := s)(x0 := x0)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a1 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

ConflictSet_2098_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2179
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2177
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2177:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2178
    ; ####increment refcount
    add qword [rax + 0], 1

lab2178:
    jmp lab2180

lab2179:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2180:
    ; let x0: ConflictSet = Unknown();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 5
    ; substitute (s := s)(x0 := x0)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

to_unknown_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_2181]
    add rcx, rdi
    jmp rcx

List_i64_2181:
    jmp near List_i64_2181_Nil
    jmp near List_i64_2181_Cons

List_i64_2181_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_2181_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2183
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab2182
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2182:
    mov rdi, [rsi + 40]
    jmp lab2184

lab2183:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab2184:
    ; substitute (a0 := a0)(t2 := t2);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; let x0: ConflictSet = Unknown();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 5
    ; substitute (t2 := t2)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: List[ConflictSet] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2196
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2197

lab2196:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2194
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2187
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2185
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2186

lab2185:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2186:

lab2187:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2190
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2188
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2189

lab2188:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2189:

lab2190:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2193
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2191
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2192

lab2191:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2192:

lab2193:
    jmp lab2195

lab2194:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2195:

lab2197:
    ; #load tag
    lea rdi, [rel List_ConflictSet_2198]
    ; jump to_unknown_
    jmp to_unknown_

List_ConflictSet_2198:
    jmp near List_ConflictSet_2198_Nil
    jmp near List_ConflictSet_2198_Cons

List_ConflictSet_2198_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2201
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2199
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2199:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2200
    ; ####increment refcount
    add qword [rax + 0], 1

lab2200:
    jmp lab2202

lab2201:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2202:
    ; let x1: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_ConflictSet_2198_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2205
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2203
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2203:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2204
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2204:
    jmp lab2206

lab2205:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2206:
    ; substitute (x0 := x0)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[ConflictSet] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2218
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2219

lab2218:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2216
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2209
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2207
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2208

lab2207:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2208:

lab2209:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2212
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2210
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2211

lab2210:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2211:

lab2212:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2215
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2213
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2214

lab2213:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2214:

lab2215:
    jmp lab2217

lab2216:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2217:

lab2219:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

n_unknown_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_2220]
    add rcx, rdi
    jmp rcx

List_i64_2220:
    jmp near List_i64_2220_Nil
    jmp near List_i64_2220_Cons

List_i64_2220_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_2220_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2222
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab2221
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2221:
    mov rdi, [rsi + 40]
    jmp lab2223

lab2222:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab2223:
    ; substitute (n00 := n0)(n0 := n0)(t1 := t1)(a0 := a0);
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rdx, rdi
    ; create a1: List[ConflictSet] = (n0, t1, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2235
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2236

lab2235:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2233
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2226
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2224
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2225

lab2224:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2225:

lab2226:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2229
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2227
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2228

lab2227:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2228:

lab2229:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2232
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2230
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2231

lab2230:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2231:

lab2232:
    jmp lab2234

lab2233:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2234:

lab2236:
    ; #load tag
    lea rdi, [rel List_ConflictSet_2237]
    ; create a2: List[i64] = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2249
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2250

lab2249:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2247
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2239

lab2238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2239:

lab2240:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2242

lab2241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2242:

lab2243:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2246
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2244
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2245

lab2244:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2245:

lab2246:
    jmp lab2248

lab2247:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2248:

lab2250:
    ; #load tag
    lea rdi, [rel List_i64_2251]
    ; lit x2 <- 1;
    mov r9, 1
    ; substitute (x2 := x2)(n00 := n00)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_2251:
    jmp near List_i64_2251_Nil
    jmp near List_i64_2251_Cons

List_i64_2251_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2253
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab2252
    ; ####increment refcount
    add qword [rax + 0], 1

lab2252:
    jmp lab2254

lab2253:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab2254:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump to_unknown_
    jmp to_unknown_

List_i64_2251_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2256
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab2255
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2255:
    jmp lab2257

lab2256:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab2257:
    ; substitute (a1 := a1)(a6 := a6)(as2 := as2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; let x1: List[i64] = Cons(a6, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2269
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2270

lab2269:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2267
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2259

lab2258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2259:

lab2260:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2263
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2261
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2262

lab2261:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2262:

lab2263:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2266
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2264
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2265

lab2264:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2265:

lab2266:
    jmp lab2268

lab2267:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2268:

lab2270:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump to_unknown_
    jmp to_unknown_

List_ConflictSet_2237:
    jmp near List_ConflictSet_2237_Nil
    jmp near List_ConflictSet_2237_Cons

List_ConflictSet_2237_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2273
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab2271
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2271:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab2272
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2272:
    mov rdx, [rax + 24]
    jmp lab2274

lab2273:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab2274:
    ; let x0: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(n0 := n0)(t1 := t1)(x0 := x0);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump lift_n_unknown_0_
    jmp lift_n_unknown_0_

List_ConflictSet_2237_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2277
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab2275
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2275:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab2276
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2276:
    mov r9, [r8 + 24]
    jmp lab2278

lab2277:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab2278:
    ; substitute (a0 := a0)(t1 := t1)(n0 := n0)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[ConflictSet] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2290
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2291

lab2290:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2288
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2281
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2279
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2280

lab2279:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2280:

lab2281:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2284
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2282
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2283

lab2282:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2283:

lab2284:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2287
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2285
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2286

lab2285:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2286:

lab2287:
    jmp lab2289

lab2288:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2289:

lab2291:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(n0 := n0)(t1 := t1)(x0 := x0);
    ; #move variables
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_n_unknown_0_
    jmp lift_n_unknown_0_

lift_n_unknown_0_:
    ; substitute (t1 := t1)(n0 := n0)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a3: List[List[ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2303
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2304

lab2303:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2301
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2294
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2292
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2293

lab2292:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2293:

lab2294:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2297
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2295
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2296

lab2295:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2296:

lab2297:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2300
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2298
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2299

lab2298:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2299:

lab2300:
    jmp lab2302

lab2301:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2302:

lab2304:
    ; #load tag
    lea r9, [rel List_List_ConflictSet_2305]
    ; jump n_unknown_
    jmp n_unknown_

List_List_ConflictSet_2305:
    jmp near List_List_ConflictSet_2305_Nil
    jmp near List_List_ConflictSet_2305_Cons

List_List_ConflictSet_2305_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2308
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2306
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2306:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2307
    ; ####increment refcount
    add qword [rax + 0], 1

lab2307:
    jmp lab2309

lab2308:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2309:
    ; let x3: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_2305_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2312
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2310
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2310:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2311
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2311:
    jmp lab2313

lab2312:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2313:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2325
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2326

lab2325:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2323
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2316
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2314
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2315

lab2314:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2315:

lab2316:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2319
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2317
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2318

lab2317:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2318:

lab2319:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2322
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2320
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2321

lab2320:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2321:

lab2322:
    jmp lab2324

lab2323:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2324:

lab2326:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

empty_table_:
    ; substitute (a0 := a0)(csp := csp);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_2327:

CSP_2327_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2329
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2328
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2328:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab2330

lab2329:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab2330:
    ; substitute (a0 := a0)(vars := vars)(vals := vals);
    ; #erase rel
    cmp r10, 0
    je lab2333
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab2331
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab2332

lab2331:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab2332:

lab2333:
    ; let x0: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (vals := vals)(vars := vars)(a0 := a0)(x0 := x0);
    ; #move variables
    mov r8, rax
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[List[ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2345
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2346

lab2345:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2343
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2336
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2334
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2335

lab2334:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2335:

lab2336:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2339
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2337
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2338

lab2337:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2338:

lab2339:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2342
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2340
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2341

lab2340:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2341:

lab2342:
    jmp lab2344

lab2343:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2344:

lab2346:
    ; #load tag
    lea r9, [rel List_List_ConflictSet_2347]
    ; substitute (vars := vars)(vals := vals)(a1 := a1);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a2: List[i64] = (vals, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2359
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2360

lab2359:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2357
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2350
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2348
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2349

lab2348:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2349:

lab2350:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2353
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2351
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2352

lab2351:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2352:

lab2353:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2356
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2354
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2355

lab2354:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2355:

lab2356:
    jmp lab2358

lab2357:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2358:

lab2360:
    ; #load tag
    lea rdi, [rel List_i64_2361]
    ; lit x3 <- 1;
    mov r9, 1
    ; substitute (x3 := x3)(vars := vars)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_2361:
    jmp near List_i64_2361_Nil
    jmp near List_i64_2361_Cons

List_i64_2361_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2363
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2362
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2362:
    mov rdx, [rax + 40]
    jmp lab2364

lab2363:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab2364:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x2 := x2)(vals := vals)(a1 := a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump n_unknown_
    jmp n_unknown_

List_i64_2361_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2366
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2365
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2365:
    mov r9, [r8 + 40]
    jmp lab2367

lab2366:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2367:
    ; substitute (a1 := a1)(vals := vals)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x2: List[i64] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2379
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2380

lab2379:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2377
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2370
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2368
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2369

lab2368:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2369:

lab2370:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2373
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2371
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2372

lab2371:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2372:

lab2373:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2376
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2374
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2375

lab2374:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2375:

lab2376:
    jmp lab2378

lab2377:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2378:

lab2380:
    ; #load tag
    mov r9, 5
    ; substitute (x2 := x2)(vals := vals)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump n_unknown_
    jmp n_unknown_

List_List_ConflictSet_2347:
    jmp near List_List_ConflictSet_2347_Nil
    jmp near List_List_ConflictSet_2347_Cons

List_List_ConflictSet_2347_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2383
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2381
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2381:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2382
    ; ####increment refcount
    add qword [rax + 0], 1

lab2382:
    jmp lab2384

lab2383:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2384:
    ; let x1: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_2347_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2387
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2385
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2385:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2386
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2386:
    jmp lab2388

lab2387:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2388:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2400
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2401

lab2400:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2398
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2391
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2389
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2390

lab2389:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2390:

lab2391:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2394
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2392
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2393

lab2392:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2393:

lab2394:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2397
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2395
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2396

lab2395:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2396:

lab2397:
    jmp lab2399

lab2398:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2399:

lab2401:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

to_pair_:
    ; substitute (a0 := a0)(varrr := varrr)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_2402]
    add rcx, r9
    jmp rcx

List_i64_2402:
    jmp near List_i64_2402_Nil
    jmp near List_i64_2402_Cons

List_i64_2402_Nil:
    ; substitute (a0 := a0);
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_2402_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2404
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2403
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2403:
    mov r9, [r8 + 40]
    jmp lab2405

lab2404:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2405:
    ; substitute (a0 := a0)(varrr := varrr)(t2 := t2)(varrr0 := varrr)(valll := valll);
    ; #move variables
    mov r13, r9
    mov r9, r11
    mov r11, rdi
    mov r8, r10
    ; let x0: Pair[i64, i64] = Tup(varrr0, valll);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2417
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2418

lab2417:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2415
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2408
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2406
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2407

lab2406:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2407:

lab2408:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2411
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2409
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2410

lab2409:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2410:

lab2411:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2414
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2412
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2413

lab2412:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2413:

lab2414:
    jmp lab2416

lab2415:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2416:

lab2418:
    ; #load tag
    mov r11, 0
    ; substitute (t2 := t2)(varrr := varrr)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Pair[i64, i64]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2430
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2431

lab2430:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2428
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2421
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2419
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2420

lab2419:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2420:

lab2421:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2424
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2422
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2423

lab2422:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2423:

lab2424:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2427
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2425
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2426

lab2425:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2426:

lab2427:
    jmp lab2429

lab2428:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2429:

lab2431:
    ; #load tag
    lea r9, [rel List_Pair_i64_i64_2432]
    ; jump to_pair_
    jmp to_pair_

List_Pair_i64_i64_2432:
    jmp near List_Pair_i64_i64_2432_Nil
    jmp near List_Pair_i64_i64_2432_Cons

List_Pair_i64_i64_2432_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2435
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2433
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2433:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2434
    ; ####increment refcount
    add qword [rax + 0], 1

lab2434:
    jmp lab2436

lab2435:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2436:
    ; let x1: List[Pair[i64, i64]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_i64_i64_2432_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2439
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2437
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2437:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2438
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2438:
    jmp lab2440

lab2439:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2440:
    ; substitute (x0 := x0)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Pair[i64, i64]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2452
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2453

lab2452:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2450
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2443
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2441
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2442

lab2441:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2442:

lab2443:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2446
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2444
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2445

lab2444:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2445:

lab2446:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2449
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2447
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2448

lab2447:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2448:

lab2449:
    jmp lab2451

lab2450:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2451:

lab2453:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

n_pairs_:
    ; substitute (a0 := a0)(n := n)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_2454]
    add rcx, r9
    jmp rcx

List_i64_2454:
    jmp near List_i64_2454_Nil
    jmp near List_i64_2454_Cons

List_i64_2454_Nil:
    ; substitute (a0 := a0);
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_2454_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2456
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2455
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2455:
    mov r9, [r8 + 40]
    jmp lab2457

lab2456:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2457:
    ; substitute (varrr := varrr)(n0 := n)(n := n)(t1 := t1)(a0 := a0);
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rdx, r9
    mov r9, rdi
    ; create a1: List[Pair[i64, i64]] = (n, t1, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2469
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2470

lab2469:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2467
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2460
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2458
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2459

lab2458:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2459:

lab2460:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2463
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2461
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2462

lab2461:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2462:

lab2463:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2466
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2464
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2465

lab2464:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2465:

lab2466:
    jmp lab2468

lab2467:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2468:

lab2470:
    ; #load tag
    lea r9, [rel List_Pair_i64_i64_2471]
    ; substitute (n0 := n0)(varrr := varrr)(a1 := a1);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a2: List[i64] = (varrr, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2483
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2484

lab2483:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2481
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2474
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2472
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2473

lab2472:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2473:

lab2474:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2477
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2475
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2476

lab2475:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2476:

lab2477:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2480
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2478
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2479

lab2478:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2479:

lab2480:
    jmp lab2482

lab2481:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2482:

lab2484:
    ; #load tag
    lea rdi, [rel List_i64_2485]
    ; lit x2 <- 1;
    mov r9, 1
    ; substitute (x2 := x2)(n0 := n0)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_2485:
    jmp near List_i64_2485_Nil
    jmp near List_i64_2485_Cons

List_i64_2485_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2487
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2486
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2486:
    mov rdx, [rax + 40]
    jmp lab2488

lab2487:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab2488:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(varrr := varrr)(a1 := a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump to_pair_
    jmp to_pair_

List_i64_2485_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2490
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2489
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2489:
    mov r9, [r8 + 40]
    jmp lab2491

lab2490:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2491:
    ; substitute (a1 := a1)(varrr := varrr)(a6 := a6)(as2 := as2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x1: List[i64] = Cons(a6, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2503
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2504

lab2503:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2501
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2494
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2492
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2493

lab2492:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2493:

lab2494:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2497
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2495
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2496

lab2495:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2496:

lab2497:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2500
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2498
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2499

lab2498:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2499:

lab2500:
    jmp lab2502

lab2501:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2502:

lab2504:
    ; #load tag
    mov r9, 5
    ; substitute (x1 := x1)(varrr := varrr)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump to_pair_
    jmp to_pair_

List_Pair_i64_i64_2471:
    jmp near List_Pair_i64_i64_2471_Nil
    jmp near List_Pair_i64_i64_2471_Cons

List_Pair_i64_i64_2471_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2507
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab2505
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2505:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab2506
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2506:
    mov rdx, [rax + 24]
    jmp lab2508

lab2507:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab2508:
    ; let x0: List[Pair[i64, i64]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(n := n)(t1 := t1)(x0 := x0);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump lift_n_pairs_0_
    jmp lift_n_pairs_0_

List_Pair_i64_i64_2471_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2511
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab2509
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2509:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab2510
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2510:
    mov r9, [r8 + 24]
    jmp lab2512

lab2511:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab2512:
    ; substitute (a0 := a0)(t1 := t1)(n := n)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Pair[i64, i64]] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2524
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2525

lab2524:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2522
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2515
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2513
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2514

lab2513:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2514:

lab2515:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2518
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2516
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2517

lab2516:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2517:

lab2518:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2521
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2519
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2520

lab2519:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2520:

lab2521:
    jmp lab2523

lab2522:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2523:

lab2525:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(n := n)(t1 := t1)(x0 := x0);
    ; #move variables
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_n_pairs_0_
    jmp lift_n_pairs_0_

lift_n_pairs_0_:
    ; substitute (t1 := t1)(n := n)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a3: List[List[Pair[i64, i64]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2537
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2538

lab2537:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2535
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2528
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2526
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2527

lab2526:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2527:

lab2528:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2531
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2529
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2530

lab2529:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2530:

lab2531:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2534
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2532
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2533

lab2532:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2533:

lab2534:
    jmp lab2536

lab2535:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2536:

lab2538:
    ; #load tag
    lea r9, [rel List_List_Pair_i64_i64_2539]
    ; jump n_pairs_
    jmp n_pairs_

List_List_Pair_i64_i64_2539:
    jmp near List_List_Pair_i64_i64_2539_Nil
    jmp near List_List_Pair_i64_i64_2539_Cons

List_List_Pair_i64_i64_2539_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2542
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2540
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2540:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2541
    ; ####increment refcount
    add qword [rax + 0], 1

lab2541:
    jmp lab2543

lab2542:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2543:
    ; let x3: List[List[Pair[i64, i64]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Pair_i64_i64_2539_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2546
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2544
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2544:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2545
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2545:
    jmp lab2547

lab2546:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2547:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[List[Pair[i64, i64]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2559
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2560

lab2559:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2557
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2550
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2548
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2549

lab2548:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2549:

lab2550:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2553
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2551
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2552

lab2551:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2552:

lab2553:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2556
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2554
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2555

lab2554:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2555:

lab2556:
    jmp lab2558

lab2557:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2558:

lab2560:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_zip_with_:
    ; substitute (f := f)(a0 := a0)(y := y)(x := x);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch x \{ ... \};
    lea rcx, [rel List_ConflictSet_2561]
    add rcx, r11
    jmp rcx

List_ConflictSet_2561:
    jmp near List_ConflictSet_2561_Nil
    jmp near List_ConflictSet_2561_Cons

List_ConflictSet_2561_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab2564
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2562
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2563

lab2562:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2563:

lab2564:
    ; #erase y
    cmp r8, 0
    je lab2567
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2565
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2566

lab2565:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2566:

lab2567:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_2561_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2570
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab2568
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2568:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab2569
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2569:
    jmp lab2571

lab2570:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab2571:
    ; substitute (f := f)(a0 := a0)(cs := cs)(c := c)(y := y);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    ; switch y \{ ... \};
    lea rcx, [rel List_Pair_i64_i64_2572]
    add rcx, r13
    jmp rcx

List_Pair_i64_i64_2572:
    jmp near List_Pair_i64_i64_2572_Nil
    jmp near List_Pair_i64_i64_2572_Cons

List_Pair_i64_i64_2572_Nil:
    ; substitute (a0 := a0);
    ; #erase c
    cmp r10, 0
    je lab2575
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab2573
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab2574

lab2573:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab2574:

lab2575:
    ; #erase cs
    cmp r8, 0
    je lab2578
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2576
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2577

lab2576:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2577:

lab2578:
    ; #erase f
    cmp rax, 0
    je lab2581
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2579
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2580

lab2579:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2580:

lab2581:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_i64_i64_2572_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab2584
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab2582
    ; ####increment refcount
    add qword [r14 + 0], 1

lab2582:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab2583
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2583:
    jmp lab2585

lab2584:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab2585:
    ; substitute (f0 := f)(p := p)(c := c)(cs := cs)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab2586
    ; ####increment refcount
    add qword [rax + 0], 1

lab2586:
    ; #move variables
    mov [rsp + 2032], rax
    mov [rsp + 2024], rdx
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; create a1: ConflictSet = (cs, a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2598
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2599

lab2598:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2596
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2589
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2587
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2588

lab2587:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2588:

lab2589:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2592
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2590
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2591

lab2590:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2591:

lab2592:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2595
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2593
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2594

lab2593:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2594:

lab2595:
    jmp lab2597

lab2596:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2597:

lab2599:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2611
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2612

lab2611:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2609
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2602
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2600
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2601

lab2600:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2601:

lab2602:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2605
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2603
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2604

lab2603:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2604:

lab2605:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2608
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2606
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2607

lab2606:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2607:

lab2608:
    jmp lab2610

lab2609:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2610:

lab2612:
    ; #load tag
    lea r11, [rel ConflictSet_2613]
    ; substitute (c := c)(p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke f0 Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

ConflictSet_2613:
    jmp near ConflictSet_2613_Known
    jmp near ConflictSet_2613_Unknown

ConflictSet_2613_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2618
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab2614
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2614:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab2615
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2615:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab2616
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2616:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab2617
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2617:
    jmp lab2619

lab2618:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab2619:
    ; substitute (f := f)(cs := cs)(a0 := a0)(ps := ps)(vs0 := vs0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2631
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2632

lab2631:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2629
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2622
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2620
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2621

lab2620:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2621:

lab2622:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2625
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2623
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2624

lab2623:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2624:

lab2625:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2628
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2626
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2627

lab2626:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2627:

lab2628:
    jmp lab2630

lab2629:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2630:

lab2632:
    ; #load tag
    mov r13, 0
    ; substitute (a0 := a0)(cs := cs)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_fill_zip_with_0_
    jmp lift_fill_zip_with_0_

ConflictSet_2613_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2637
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2633
    ; ####increment refcount
    add qword [rax + 0], 1

lab2633:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2634
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2634:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2635
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2635:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab2636
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2636:
    jmp lab2638

lab2637:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab2638:
    ; let x0: ConflictSet = Unknown();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 5
    ; substitute (a0 := a0)(cs := cs)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; jump lift_fill_zip_with_0_
    jmp lift_fill_zip_with_0_

lift_fill_zip_with_0_:
    ; substitute (ps := ps)(cs := cs)(f := f)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a2: List[ConflictSet] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2650
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2651

lab2650:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2648
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2641
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2639
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2640

lab2639:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2640:

lab2641:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2644
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2642
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2643

lab2642:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2643:

lab2644:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2647
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2645
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2646

lab2645:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2646:

lab2647:
    jmp lab2649

lab2648:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2649:

lab2651:
    ; #load tag
    lea r11, [rel List_ConflictSet_2652]
    ; substitute (f := f)(cs := cs)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump fill_zip_with_
    jmp fill_zip_with_

List_ConflictSet_2652:
    jmp near List_ConflictSet_2652_Nil
    jmp near List_ConflictSet_2652_Cons

List_ConflictSet_2652_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2655
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2653
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2653:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2654
    ; ####increment refcount
    add qword [rax + 0], 1

lab2654:
    jmp lab2656

lab2655:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2656:
    ; let x1: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_ConflictSet_2652_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2659
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2657
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2657:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2658
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2658:
    jmp lab2660

lab2659:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2660:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[ConflictSet] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2672
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2673

lab2672:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2670
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2663
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2661
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2662

lab2661:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2662:

lab2663:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2666
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2664
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2665

lab2664:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2665:

lab2666:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2669
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2667
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2668

lab2667:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2668:

lab2669:
    jmp lab2671

lab2670:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2671:

lab2673:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_zip_with2_:
    ; substitute (f := f)(a0 := a0)(ls := ls)(tbl := tbl);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch tbl \{ ... \};
    lea rcx, [rel List_List_ConflictSet_2674]
    add rcx, r11
    jmp rcx

List_List_ConflictSet_2674:
    jmp near List_List_ConflictSet_2674_Nil
    jmp near List_List_ConflictSet_2674_Cons

List_List_ConflictSet_2674_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab2677
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2675
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2676

lab2675:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2676:

lab2677:
    ; #erase ls
    cmp r8, 0
    je lab2680
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2678
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2679

lab2678:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2679:

lab2680:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_2674_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2683
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab2681
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2681:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab2682
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2682:
    jmp lab2684

lab2683:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab2684:
    ; substitute (f := f)(a0 := a0)(css := css)(cs := cs)(ls := ls);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Pair_i64_i64_2685]
    add rcx, r13
    jmp rcx

List_List_Pair_i64_i64_2685:
    jmp near List_List_Pair_i64_i64_2685_Nil
    jmp near List_List_Pair_i64_i64_2685_Cons

List_List_Pair_i64_i64_2685_Nil:
    ; substitute (a0 := a0);
    ; #erase cs
    cmp r10, 0
    je lab2688
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab2686
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab2687

lab2686:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab2687:

lab2688:
    ; #erase css
    cmp r8, 0
    je lab2691
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2689
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2690

lab2689:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2690:

lab2691:
    ; #erase f
    cmp rax, 0
    je lab2694
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2692
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2693

lab2692:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2693:

lab2694:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Pair_i64_i64_2685_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab2697
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab2695
    ; ####increment refcount
    add qword [r14 + 0], 1

lab2695:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab2696
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2696:
    jmp lab2698

lab2697:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab2698:
    ; substitute (f0 := f)(ps := ps)(cs := cs)(css := css)(a0 := a0)(pss := pss)(f := f);
    ; #share f
    cmp rax, 0
    je lab2699
    ; ####increment refcount
    add qword [rax + 0], 1

lab2699:
    ; #move variables
    mov [rsp + 2032], rax
    mov [rsp + 2024], rdx
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; create a1: List[ConflictSet] = (css, a0, pss, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2711
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2712

lab2711:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2709
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2702
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2700
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2701

lab2700:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2701:

lab2702:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2705
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2703
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2704

lab2703:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2704:

lab2705:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2708
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2706
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2707

lab2706:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2707:

lab2708:
    jmp lab2710

lab2709:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2710:

lab2712:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2724
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2725

lab2724:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2722
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2715
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2713
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2714

lab2713:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2714:

lab2715:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2718
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2716
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2717

lab2716:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2717:

lab2718:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2721
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2719
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2720

lab2719:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2720:

lab2721:
    jmp lab2723

lab2722:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2723:

lab2725:
    ; #load tag
    lea r11, [rel List_ConflictSet_2726]
    ; substitute (cs := cs)(ps := ps)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke f0 Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

List_ConflictSet_2726:
    jmp near List_ConflictSet_2726_Nil
    jmp near List_ConflictSet_2726_Cons

List_ConflictSet_2726_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2731
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2727
    ; ####increment refcount
    add qword [rax + 0], 1

lab2727:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2728
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2728:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2729
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2729:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab2730
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2730:
    jmp lab2732

lab2731:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab2732:
    ; let x0: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (a0 := a0)(css := css)(f := f)(pss := pss)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; jump lift_fill_zip_with2_0_
    jmp lift_fill_zip_with2_0_

List_ConflictSet_2726_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2737
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2733
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2733:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab2734
    ; ####increment refcount
    add qword [r14 + 0], 1

lab2734:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab2735
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2735:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab2736
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2736:
    jmp lab2738

lab2737:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab2738:
    ; substitute (f := f)(pss := pss)(css := css)(a0 := a0)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r14
    mov r14, rsi
    mov rsi, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: List[ConflictSet] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2750
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2751

lab2750:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2748
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2741
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2739
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2740

lab2739:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2740:

lab2741:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2744
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2742
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2743

lab2742:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2743:

lab2744:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2747
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2745
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2746

lab2745:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2746:

lab2747:
    jmp lab2749

lab2748:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2749:

lab2751:
    ; #load tag
    mov r13, 5
    ; substitute (a0 := a0)(css := css)(f := f)(pss := pss)(x0 := x0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_fill_zip_with2_0_
    jmp lift_fill_zip_with2_0_

lift_fill_zip_with2_0_:
    ; substitute (pss := pss)(css := css)(f := f)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a2: List[List[ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2763
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2764

lab2763:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2761
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2754
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2752
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2753

lab2752:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2753:

lab2754:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2757
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2755
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2756

lab2755:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2756:

lab2757:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2760
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2758
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2759

lab2758:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2759:

lab2760:
    jmp lab2762

lab2761:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2762:

lab2764:
    ; #load tag
    lea r11, [rel List_List_ConflictSet_2765]
    ; substitute (f := f)(css := css)(pss := pss)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump fill_zip_with2_
    jmp fill_zip_with2_

List_List_ConflictSet_2765:
    jmp near List_List_ConflictSet_2765_Nil
    jmp near List_List_ConflictSet_2765_Cons

List_List_ConflictSet_2765_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2768
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2766
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2766:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2767
    ; ####increment refcount
    add qword [rax + 0], 1

lab2767:
    jmp lab2769

lab2768:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2769:
    ; let x1: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_2765_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2772
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2770
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2770:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2771
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2771:
    jmp lab2773

lab2772:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2773:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2785
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2786

lab2785:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2783
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2776
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2774
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2775

lab2774:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2775:

lab2776:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2779
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2777
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2778

lab2777:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2778:

lab2779:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2782
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2780
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2781

lab2780:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2781:

lab2782:
    jmp lab2784

lab2783:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2784:

lab2786:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_table_:
    ; substitute (a0 := a0)(csp := csp)(tbl := tbl)(s := s);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; switch s \{ ... \};
    lea rcx, [rel List_Assign_2787]
    add rcx, r11
    jmp rcx

List_Assign_2787:
    jmp near List_Assign_2787_Nil
    jmp near List_Assign_2787_Cons

List_Assign_2787_Nil:
    ; substitute (a0 := a0)(tbl := tbl);
    ; #erase csp
    cmp rsi, 0
    je lab2790
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab2788
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab2789

lab2788:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab2789:

lab2790:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch tbl \{ ... \};
    lea rcx, [rel List_List_ConflictSet_2791]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_2791:
    jmp near List_List_ConflictSet_2791_Nil
    jmp near List_List_ConflictSet_2791_Cons

List_List_ConflictSet_2791_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_2791_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2794
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab2792
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2792:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab2793
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2793:
    jmp lab2795

lab2794:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab2795:
    ; substitute (a7 := a7)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Assign_2787_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2798
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab2796
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2796:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab2797
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2797:
    jmp lab2799

lab2798:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab2799:
    ; substitute (a0 := a0)(csp := csp)(tbl := tbl)(as := as);
    ; #erase as_
    cmp r12, 0
    je lab2802
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab2800
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab2801

lab2800:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab2801:

lab2802:
    ; switch as \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_2803:

Assign_2803_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2804
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab2805

lab2804:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab2805:
    ; substitute (a0 := a0)(val_ := val_)(tbl := tbl)(var_ := var_)(csp := csp);
    ; #move variables
    mov r12, rsi
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_2806:

CSP_2806_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab2808
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab2807
    ; ####increment refcount
    add qword [rcx + 0], 1

lab2807:
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]
    jmp lab2809

lab2808:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]

lab2809:
    ; substitute (a0 := a0)(vals := vals)(tbl := tbl)(var_1 := var_)(vars := vars)(var_ := var_)(rel := rel)(val_ := val_);
    ; #move variables
    mov [rsp + 2008], rdi
    mov rdi, r15
    mov r15, r11
    ; create f4: Fun2[ConflictSet, Pair[i64, i64], ConflictSet] = (var_, rel, val_)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    mov [rbx + 24], r15
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2821
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab2822

lab2821:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2819
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2812
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2810
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2811

lab2810:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2811:

lab2812:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2815
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2813
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2814

lab2813:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2814:

lab2815:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2818
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2816
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2817

lab2816:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2817:

lab2818:
    jmp lab2820

lab2819:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2820:

lab2822:
    ; #load tag
    lea r15, [rel Fun2_ConflictSet_Pair_i64_i64_ConflictSet_2823]
    ; create x6: Fun2[List[ConflictSet], List[Pair[i64, i64]], List[ConflictSet]] = (f4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2835
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab2836

lab2835:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2833
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2826
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2824
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2825

lab2824:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2825:

lab2826:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2829
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2827
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2828

lab2827:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2828:

lab2829:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2832
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2830
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2831

lab2830:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2831:

lab2832:
    jmp lab2834

lab2833:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2834:

lab2836:
    ; #load tag
    lea r15, [rel Fun2_List_ConflictSet_List_Pair_i64_i64_List_ConflictSet_2837]
    ; substitute (vars := vars)(vals := vals)(var_1 := var_1)(tbl := tbl)(a0 := a0)(x6 := x6);
    ; #move variables
    mov r12, rax
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov r10, r8
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; create a2: List[List[Pair[i64, i64]]] = (tbl, a0, x6)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2849
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2850

lab2849:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2847
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2840
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2838
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2839

lab2838:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2839:

lab2840:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2843
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2841
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2842

lab2841:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2842:

lab2843:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2846
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2844
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2845

lab2844:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2845:

lab2846:
    jmp lab2848

lab2847:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2848:

lab2850:
    ; #load tag
    lea r11, [rel List_List_Pair_i64_i64_2851]
    ; substitute (vars := vars)(var_1 := var_1)(vals := vals)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a3: List[i64] = (vals, a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2863
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2864

lab2863:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2861
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2854
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2852
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2853

lab2852:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2853:

lab2854:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2857
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2855
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2856

lab2855:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2856:

lab2857:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2860
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2858
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2859

lab2858:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2859:

lab2860:
    jmp lab2862

lab2861:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2862:

lab2864:
    ; #load tag
    lea r9, [rel List_i64_2865]
    ; lit x9 <- 1;
    mov r11, 1
    ; x10 <- var_1 + x9;
    mov r13, rdi
    add r13, r11
    ; substitute (x10 := x10)(vars := vars)(a3 := a3);
    ; #move variables
    mov rdi, rdx
    mov rdx, r13
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_2865:
    jmp near List_i64_2865_Nil
    jmp near List_i64_2865_Cons

List_i64_2865_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2867
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2866
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2866:
    mov rdx, [rax + 40]
    jmp lab2868

lab2867:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab2868:
    ; let x8: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x8 := x8)(vals := vals)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump n_pairs_
    jmp n_pairs_

List_i64_2865_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2870
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2869
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2869:
    mov r9, [r8 + 40]
    jmp lab2871

lab2870:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2871:
    ; substitute (a2 := a2)(vals := vals)(a9 := a9)(as2 := as2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x8: List[i64] = Cons(a9, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2883
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2884

lab2883:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2881
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2874
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2872
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2873

lab2872:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2873:

lab2874:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2877
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2875
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2876

lab2875:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2876:

lab2877:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2880
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2878
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2879

lab2878:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2879:

lab2880:
    jmp lab2882

lab2881:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2882:

lab2884:
    ; #load tag
    mov r9, 5
    ; substitute (x8 := x8)(vals := vals)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump n_pairs_
    jmp n_pairs_

List_List_Pair_i64_i64_2851:
    jmp near List_List_Pair_i64_i64_2851_Nil
    jmp near List_List_Pair_i64_i64_2851_Cons

List_List_Pair_i64_i64_2851_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2888
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab2885
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2885:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab2886
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2886:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab2887
    ; ####increment refcount
    add qword [rax + 0], 1

lab2887:
    jmp lab2889

lab2888:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab2889:
    ; let x7: List[List[Pair[i64, i64]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (x6 := x6)(tbl := tbl)(x7 := x7)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump fill_zip_with2_
    jmp fill_zip_with2_

List_List_Pair_i64_i64_2851_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2893
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab2890
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2890:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab2891
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2891:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab2892
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2892:
    jmp lab2894

lab2893:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab2894:
    ; substitute (x6 := x6)(a0 := a0)(tbl := tbl)(a8 := a8)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x7: List[List[Pair[i64, i64]]] = Cons(a8, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2906
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2907

lab2906:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2904
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2897
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2895
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2896

lab2895:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2896:

lab2897:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2900
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2898
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2899

lab2898:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2899:

lab2900:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2903
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2901
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2902

lab2901:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2902:

lab2903:
    jmp lab2905

lab2904:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2905:

lab2907:
    ; #load tag
    mov r11, 5
    ; substitute (x6 := x6)(tbl := tbl)(x7 := x7)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump fill_zip_with2_
    jmp fill_zip_with2_

Fun2_List_ConflictSet_List_Pair_i64_i64_List_ConflictSet_2837:

Fun2_List_ConflictSet_List_Pair_i64_i64_List_ConflictSet_2837_Apply2:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2909
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab2908
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2908:
    jmp lab2910

lab2909:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab2910:
    ; substitute (f4 := f4)(x := x)(y := y)(a1 := a1);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump fill_zip_with_
    jmp fill_zip_with_

Fun2_ConflictSet_Pair_i64_i64_ConflictSet_2823:

Fun2_ConflictSet_Pair_i64_i64_ConflictSet_2823_Apply2:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2912
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab2911
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2911:
    mov r11, [r10 + 24]
    jmp lab2913

lab2912:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]

lab2913:
    ; substitute (cs := cs)(val_ := val_)(a4 := a4)(var_ := var_)(rel := rel)(varval := varval);
    ; #move variables
    mov r14, rsi
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    ; switch varval \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_i64_i64_2914:

Pair_i64_i64_2914_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r14 + 0], 0
    je lab2915
    ; ##either decrement refcount and share children...
    add qword [r14 + 0], -1
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 40]
    jmp lab2916

lab2915:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 40]

lab2916:
    ; substitute (cs := cs)(val_ := val_)(a4 := a4)(var_ := var_)(rel := rel)(varr := varr)(vall := vall)(cs0 := cs);
    ; #share cs
    cmp rax, 0
    je lab2917
    ; ####increment refcount
    add qword [rax + 0], 1

lab2917:
    ; #move variables
    mov [rsp + 2016], rax
    mov [rsp + 2008], rdx
    ; switch cs0 \{ ... \};
    lea rcx, [rel ConflictSet_2918]
    add rcx, [rsp + 2008]
    jmp rcx

ConflictSet_2918:
    jmp near ConflictSet_2918_Known
    jmp near ConflictSet_2918_Unknown

ConflictSet_2918_Known:
    ; #load from memory
    mov rcx, [rsp + 2016]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab2920
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    ; ###evacuate additional scratch register for memory block
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab2919
    ; ####increment refcount
    add qword [rcx + 0], 1

lab2919:
    ; ###restore evacuated register
    mov rax, [rsp + 2040]
    jmp lab2921

lab2920:
    ; ##... or release blocks onto linear free list when loading
    ; ###evacuate additional scratch register for memory block
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    ; ###restore evacuated register
    mov rax, [rsp + 2040]

lab2921:
    ; substitute (a4 := a4)(cs := cs);
    ; #erase rel
    cmp r12, 0
    je lab2924
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab2922
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab2923

lab2922:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab2923:

lab2924:
    ; #erase vs
    mov rcx, [rsp + 2016]
    cmp rcx, 0
    je lab2927
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2925
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2926

lab2925:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2926:

lab2927:
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    ; switch cs \{ ... \};
    lea rcx, [rel ConflictSet_2928]
    add rcx, rdi
    jmp rcx

ConflictSet_2928:
    jmp near ConflictSet_2928_Known
    jmp near ConflictSet_2928_Unknown

ConflictSet_2928_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2930
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab2929
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2929:
    jmp lab2931

lab2930:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab2931:
    ; substitute (vs0 := vs0)(a4 := a4);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a4 Known
    add rdi, 0
    jmp rdi

ConflictSet_2928_Unknown:
    ; invoke a4 Unknown
    add rdx, 5
    jmp rdx

ConflictSet_2918_Unknown:
    ; substitute (vall := vall)(val_ := val_)(varr0 := varr)(var_0 := var_)(rel := rel)(varr := varr)(var_ := var_)(cs := cs)(a4 := a4);
    ; #move variables
    mov [rsp + 2016], rax
    mov [rsp + 2008], rdx
    mov [rsp + 2000], r8
    mov [rsp + 1992], r9
    mov rdx, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r9, r15
    ; create a5: Bool = (varr, var_, cs, a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2943
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab2944

lab2943:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2941
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2934
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2932
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2933

lab2932:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2933:

lab2934:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2937
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2935
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2936

lab2935:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2936:

lab2937:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2940
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2938
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2939

lab2938:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2939:

lab2940:
    jmp lab2942

lab2941:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2942:

lab2944:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2956
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab2957

lab2956:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2954
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2947
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2945
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2946

lab2945:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2946:

lab2947:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2950
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2948
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2949

lab2948:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2949:

lab2950:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2953
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2951
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2952

lab2951:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2952:

lab2953:
    jmp lab2955

lab2954:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2955:

lab2957:
    ; #load tag
    lea r15, [rel Bool_2958]
    ; substitute (vall := vall)(a5 := a5)(varr0 := varr0)(rel := rel)(var_0 := var_0)(val_ := val_);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, rcx
    mov r10, r12
    mov rsi, r14
    ; let x1: Assign = Assign(var_0, val_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2970
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2971

lab2970:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2968
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2961
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2959
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2960

lab2959:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2960:

lab2961:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2964
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2962
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2963

lab2962:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2963:

lab2964:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2967
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2965
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2966

lab2965:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2966:

lab2967:
    jmp lab2969

lab2968:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2969:

lab2971:
    ; #load tag
    mov r13, 0
    ; substitute (x1 := x1)(a5 := a5)(rel := rel)(varr0 := varr0)(vall := vall);
    ; #move variables
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    mov r8, r10
    mov rax, r12
    ; let x2: Assign = Assign(varr0, vall);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2983
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2984

lab2983:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2981
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2974
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2972
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2973

lab2972:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2973:

lab2974:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2977
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2975
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2976

lab2975:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2976:

lab2977:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2980
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2978
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2979

lab2978:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2979:

lab2980:
    jmp lab2982

lab2981:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2982:

lab2984:
    ; #load tag
    mov r11, 0
    ; substitute (x1 := x1)(x2 := x2)(a5 := a5)(rel := rel);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke rel Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

Bool_2958:
    jmp near Bool_2958_True
    jmp near Bool_2958_False

Bool_2958_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2987
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2985
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2985:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2986
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2986:
    mov rdi, [rsi + 24]
    jmp lab2988

lab2987:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]

lab2988:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (a4 := a4)(cs := cs)(var_ := var_)(varr := varr)(x0 := x0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rsi, r8
    mov rax, r10
    ; jump lift_fill_table_0_
    jmp lift_fill_table_0_

Bool_2958_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2991
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2989
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2989:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2990
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2990:
    mov rdi, [rsi + 24]
    jmp lab2992

lab2991:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]

lab2992:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 5
    ; substitute (a4 := a4)(cs := cs)(var_ := var_)(varr := varr)(x0 := x0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rsi, r8
    mov rax, r10
    ; jump lift_fill_table_0_
    jmp lift_fill_table_0_

lift_fill_table_0_:
    ; substitute (x0 := x0)(cs := cs)(var_ := var_)(varr := varr)(a4 := a4);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; create a6: Bool = (cs, var_, varr, a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3004
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3005

lab3004:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3002
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2995
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2993
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2994

lab2993:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2994:

lab2995:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2998
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2996
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2997

lab2996:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2997:

lab2998:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3001
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2999
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3000

lab2999:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3000:

lab3001:
    jmp lab3003

lab3002:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3003:

lab3005:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3017
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab3018

lab3017:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3015
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3008
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3006
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3007

lab3006:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3007:

lab3008:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3011
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3009
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3010

lab3009:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3010:

lab3011:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3014
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3012
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3013

lab3012:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3013:

lab3014:
    jmp lab3016

lab3015:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3016:

lab3018:
    ; #load tag
    lea rdi, [rel Bool_3019]
    ; jump not_
    jmp not_

Bool_3019:
    jmp near Bool_3019_True
    jmp near Bool_3019_False

Bool_3019_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3022
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3020
    ; ####increment refcount
    add qword [rax + 0], 1

lab3020:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab3021
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3021:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab3023

lab3022:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab3023:
    ; substitute (a4 := a4)(var_ := var_)(varr := varr);
    ; #erase cs
    cmp rax, 0
    je lab3026
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab3024
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab3025

lab3024:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab3025:

lab3026:
    ; #move variables
    mov rax, r10
    mov rdx, r11
    ; let x3: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; let x4: List[i64] = Cons(varr, x3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3038
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3039

lab3038:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3036
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3029
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3027
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3028

lab3027:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3028:

lab3029:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3032
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3030
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3031

lab3030:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3031:

lab3032:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3035
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3033
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3034

lab3033:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3034:

lab3035:
    jmp lab3037

lab3036:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3037:

lab3039:
    ; #load tag
    mov r9, 5
    ; let x5: List[i64] = Cons(var_, x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3051
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab3052

lab3051:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3049
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3042
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3040
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3041

lab3040:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3041:

lab3042:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3045
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3043
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3044

lab3043:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3044:

lab3045:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3048
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3046
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3047

lab3046:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3047:

lab3048:
    jmp lab3050

lab3049:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3050:

lab3052:
    ; #load tag
    mov rdi, 5
    ; substitute (x5 := x5)(a4 := a4);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a4 Known
    add rdi, 0
    jmp rdi

Bool_3019_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3055
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3053
    ; ####increment refcount
    add qword [rax + 0], 1

lab3053:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab3054
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3054:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab3056

lab3055:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab3056:
    ; substitute (a4 := a4)(cs := cs);
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r10
    mov rdx, r11
    ; switch cs \{ ... \};
    lea rcx, [rel ConflictSet_3057]
    add rcx, rdi
    jmp rcx

ConflictSet_3057:
    jmp near ConflictSet_3057_Known
    jmp near ConflictSet_3057_Unknown

ConflictSet_3057_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3059
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab3058
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3058:
    jmp lab3060

lab3059:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab3060:
    ; substitute (vs1 := vs1)(a4 := a4);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a4 Known
    add rdi, 0
    jmp rdi

ConflictSet_3057_Unknown:
    ; invoke a4 Unknown
    add rdx, 5
    jmp rdx

lookup_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_List_List_ConflictSet_3061]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_List_List_ConflictSet_3061:
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3061_Nil
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3061_Cons

List_Node_Pair_List_Assign_List_List_ConflictSet_3061_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab3064
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab3062
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab3063

lab3062:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab3063:

lab3064:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_List_List_ConflictSet_3061_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3067
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3065
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3065:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3066
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3066:
    jmp lab3068

lab3067:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3068:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab3069
    ; ####increment refcount
    add qword [rax + 0], 1

lab3069:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3081
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3082

lab3081:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3079
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3072
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3070
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3071

lab3070:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3071:

lab3072:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3075
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3073
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3074

lab3073:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3074:

lab3075:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3078
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3076
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3077

lab3076:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3077:

lab3078:
    jmp lab3080

lab3079:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3080:

lab3082:
    ; #load tag
    lea r9, [rel Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3083]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3083:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3083_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3087
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3084
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3084:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3085
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3085:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3086
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3086:
    jmp lab3088

lab3087:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3088:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3100
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3101

lab3100:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3098
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3091
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3089
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3090

lab3089:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3090:

lab3091:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3094
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3092
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3093

lab3092:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3093:

lab3094:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3097
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3095
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3096

lab3095:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3096:

lab3097:
    jmp lab3099

lab3098:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3099:

lab3101:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3113
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3114

lab3113:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3111
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3104
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3102
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3103

lab3102:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3103:

lab3104:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3107
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3105
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3106

lab3105:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3106:

lab3107:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3110
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3108
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3109

lab3108:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3109:

lab3110:
    jmp lab3112

lab3111:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3112:

lab3114:
    ; #load tag
    lea r9, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3115]
    ; jump lookup_map_
    jmp lookup_map_

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3115:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3115_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3115_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3115_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3118
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3116
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3116:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3117
    ; ####increment refcount
    add qword [rax + 0], 1

lab3117:
    jmp lab3119

lab3118:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3119:
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3115_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3122
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3120
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3120:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3121
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3121:
    jmp lab3123

lab3122:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3123:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3135
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3136

lab3135:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3133
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3126
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3124
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3125

lab3124:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3125:

lab3126:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3128

lab3127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3128:

lab3129:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3131

lab3130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3131:

lab3132:
    jmp lab3134

lab3133:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3134:

lab3136:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

lookup_map_tree_:
    ; substitute (f := f)(a0 := a0)(t := t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_List_List_ConflictSet_3137:

Node_Pair_List_Assign_List_List_ConflictSet_3137_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3140
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3138
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3138:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3139
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3139:
    jmp lab3141

lab3140:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3141:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab3142
    ; ####increment refcount
    add qword [rax + 0], 1

lab3142:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3154
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3155

lab3154:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3152
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3145
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3143
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3144

lab3143:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3144:

lab3145:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3148
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3146
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3147

lab3146:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3147:

lab3148:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3151
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3149
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3150

lab3149:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3150:

lab3151:
    jmp lab3153

lab3152:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3153:

lab3155:
    ; #load tag
    lea r9, [rel Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3156]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3156:

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3156_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3160
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3157
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3157:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3158
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3158:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3159
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3159:
    jmp lab3161

lab3160:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3161:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a5 := a5)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3173
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3174

lab3173:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3171
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3164
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3162
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3163

lab3162:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3163:

lab3164:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3167
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3165
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3166

lab3165:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3166:

lab3167:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3170
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3168
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3169

lab3168:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3169:

lab3170:
    jmp lab3172

lab3171:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3172:

lab3174:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3186
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3187

lab3186:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3184
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3177
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3175
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3176

lab3175:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3176:

lab3177:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3180
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3178
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3179

lab3178:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3179:

lab3180:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3183
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3181
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3182

lab3181:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3182:

lab3183:
    jmp lab3185

lab3184:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3185:

lab3187:
    ; #load tag
    lea r9, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3188]
    ; substitute (a2 := a2)(ps := ps)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x2: Fun[Node[Pair[List[Assign], List[List[ConflictSet]]]], Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3200
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3201

lab3200:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3198
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3191
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3189
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3190

lab3189:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3190:

lab3191:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3194
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3192
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3193

lab3192:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3193:

lab3194:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3197
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3195
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3196

lab3195:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3196:

lab3197:
    jmp lab3199

lab3198:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3199:

lab3201:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_List_List_ConflictSet_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3202]
    ; substitute (x2 := x2)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lookup_map_
    jmp lookup_map_

Fun_Node_Pair_List_Assign_List_List_ConflictSet_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3202:

Fun_Node_Pair_List_Assign_List_List_ConflictSet_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3202_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3204
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab3203
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3203:
    jmp lab3205

lab3204:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab3205:
    ; substitute (f := f)(x := x)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lookup_map_tree_
    jmp lookup_map_tree_

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3188:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3188_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3188_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3188_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3208
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3206
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3206:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3207
    ; ####increment refcount
    add qword [rax + 0], 1

lab3207:
    jmp lab3209

lab3208:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3209:
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3188_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3212
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3210
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3210:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3211
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3211:
    jmp lab3213

lab3212:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3213:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3225
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3226

lab3225:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3223
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3216
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3214
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3215

lab3214:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3215:

lab3216:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3219
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3217
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3218

lab3217:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3218:

lab3219:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3222
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3220
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3221

lab3220:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3221:

lab3222:
    jmp lab3224

lab3223:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3224:

lab3226:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

lookup_at_index_:
    ; substitute (ind := ind)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_ConflictSet_3227]
    add rcx, r9
    jmp rcx

List_ConflictSet_3227:
    jmp near List_ConflictSet_3227_Nil
    jmp near List_ConflictSet_3227_Cons

List_ConflictSet_3227_Nil:
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

List_ConflictSet_3227_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3230
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3228
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3228:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3229
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3229:
    jmp lab3231

lab3230:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3231:
    ; if ind == 0 \{ ... \}
    cmp rdx, 0
    je lab3232
    ; else branch
    ; substitute (ind := ind)(a0 := a0)(cs := cs);
    ; #erase c
    cmp r8, 0
    je lab3235
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab3233
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab3234

lab3233:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab3234:

lab3235:
    ; #move variables
    mov r8, r10
    mov r9, r11
    ; lit x0 <- 1;
    mov r11, 1
    ; x1 <- ind - x0;
    mov r13, rdx
    sub r13, r11
    ; substitute (x1 := x1)(cs := cs)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rdx, r13
    ; jump lookup_at_index_
    jmp lookup_at_index_

lab3232:
    ; then branch
    ; substitute (a0 := a0)(c := c);
    ; #erase cs
    cmp r10, 0
    je lab3238
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab3236
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab3237

lab3236:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab3237:

lab3238:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_3239]
    add rcx, rdi
    jmp rcx

ConflictSet_3239:
    jmp near ConflictSet_3239_Known
    jmp near ConflictSet_3239_Unknown

ConflictSet_3239_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3241
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab3240
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3240:
    jmp lab3242

lab3241:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab3242:
    ; substitute (vs0 := vs0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Known
    add rdi, 0
    jmp rdi

ConflictSet_3239_Unknown:
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

lookup_head_:
    ; substitute (a0 := a0)(tbl := tbl);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch tbl \{ ... \};
    lea rcx, [rel List_List_ConflictSet_3243]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_3243:
    jmp near List_List_ConflictSet_3243_Nil
    jmp near List_List_ConflictSet_3243_Cons

List_List_ConflictSet_3243_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_3243_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3246
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3244
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3244:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3245
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3245:
    jmp lab3247

lab3246:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3247:
    ; substitute (a0 := a0)(cs := cs);
    ; #erase css
    cmp r8, 0
    je lab3250
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab3248
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab3249

lab3248:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab3249:

lab3250:
    ; switch cs \{ ... \};
    lea rcx, [rel List_ConflictSet_3251]
    add rcx, rdi
    jmp rcx

List_ConflictSet_3251:
    jmp near List_ConflictSet_3251_Nil
    jmp near List_ConflictSet_3251_Cons

List_ConflictSet_3251_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_3251_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3254
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3252
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3252:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3253
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3253:
    jmp lab3255

lab3254:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3255:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

lookup_cache_:
    ; create f5: Fun2[CSP, Pair[List[Assign], List[List[ConflictSet]]], Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun2_CSP_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3256]
    ; substitute (a0 := a0)(t := t)(csp := csp)(f5 := f5);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x8: Fun[Pair[List[Assign], List[List[ConflictSet]]], Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (csp, f5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3268
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3269

lab3268:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3266
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3259
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3257
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3258

lab3257:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3258:

lab3259:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3262
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3260
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3261

lab3260:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3261:

lab3262:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3265
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3263
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3264

lab3263:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3264:

lab3265:
    jmp lab3267

lab3266:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3267:

lab3269:
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3270]
    ; substitute (x8 := x8)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lookup_map_tree_
    jmp lookup_map_tree_

Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3270:

Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3270_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3273
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3271
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3271:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3272
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3272:
    jmp lab3274

lab3273:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3274:
    ; substitute (csp := csp)(x := x)(a1 := a1)(f5 := f5);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke f5 Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

Fun2_CSP_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3256:

Fun2_CSP_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3256_Apply2:
    ; substitute (csp0 := csp0)(a2 := a2)(tp := tp);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch tp \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_List_List_ConflictSet_3275:

Pair_List_Assign_List_List_ConflictSet_3275_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3278
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3276
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3276:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3277
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3277:
    jmp lab3279

lab3278:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3279:
    ; substitute (csp0 := csp0)(a2 := a2)(tbl := tbl)(ls := ls);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_3280]
    add rcx, r11
    jmp rcx

List_Assign_3280:
    jmp near List_Assign_3280_Nil
    jmp near List_Assign_3280_Cons

List_Assign_3280_Nil:
    ; substitute (tbl := tbl)(a2 := a2);
    ; #erase csp0
    cmp rax, 0
    je lab3283
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab3281
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab3282

lab3281:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab3282:

lab3283:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; let x1: ConflictSet = Unknown();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 5
    ; let x2: Pair[List[Assign], ConflictSet] = Tup(x0, x1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3295
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3296

lab3295:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3293
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3286
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3284
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3285

lab3284:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3285:

lab3286:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3289
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3287
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3288

lab3287:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3288:

lab3289:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3292
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3290
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3291

lab3290:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3291:

lab3292:
    jmp lab3294

lab3293:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3294:

lab3296:
    ; #load tag
    mov r9, 0
    ; substitute (x2 := x2)(tbl := tbl)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a2 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Assign_3280_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab3299
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab3297
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3297:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab3298
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3298:
    jmp lab3300

lab3299:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab3300:
    ; substitute (a8 := a)(a2 := a2)(tbl := tbl)(a := a)(as_ := as_)(csp0 := csp0);
    ; #share a
    cmp r10, 0
    je lab3301
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3301:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov rax, r10
    mov rdx, r11
    ; create a3: _Cont = (a2, tbl, a, as_, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3313
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3314

lab3313:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3311
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3304
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3302
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3303

lab3302:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3303:

lab3304:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3307
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3305
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3306

lab3305:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3306:

lab3307:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3310
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3308
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3309

lab3308:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3309:

lab3310:
    jmp lab3312

lab3311:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3312:

lab3314:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3326
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab3327

lab3326:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3324
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3317
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3315
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3316

lab3315:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3316:

lab3317:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3320
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3318
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3319

lab3318:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3319:

lab3320:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3323
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3321
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3322

lab3321:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3322:

lab3323:
    jmp lab3325

lab3324:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3325:

lab3327:
    ; #load tag
    lea rdi, [rel _Cont_3328]
    ; jump value_
    jmp value_

_Cont_3328:

_Cont_3328_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3334
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab3329
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3329:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab3330
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3330:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab3331
    ; ####increment refcount
    add qword [r14 + 0], 1

lab3331:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab3332
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3332:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab3333
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3333:
    jmp lab3335

lab3334:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab3335:
    ; lit x4 <- 1;
    mov qword [rsp + 2024], 1
    ; x5 <- x3 - x4;
    mov rcx, rdx
    sub rcx, [rsp + 2024]
    mov [rsp + 2008], rcx
    ; substitute (tbl0 := tbl)(a2 := a2)(tbl := tbl)(a := a)(as_ := as_)(csp0 := csp0)(x5 := x5);
    ; #share tbl
    cmp r8, 0
    je lab3336
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3336:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov rcx, [rsp + 2008]
    mov [rsp + 2024], rcx
    ; create a4: List[ConflictSet] = (a2, tbl, a, as_, csp0, x5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3348
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab3349

lab3348:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3346
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3339
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3337
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3338

lab3337:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3338:

lab3339:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3342
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3340
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3341

lab3340:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3341:

lab3342:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3345
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3343
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3344

lab3343:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3344:

lab3345:
    jmp lab3347

lab3346:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3347:

lab3349:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3361
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3362

lab3361:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3359
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3352
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3350
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3351

lab3350:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3351:

lab3352:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3355
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3353
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3354

lab3353:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3354:

lab3355:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3358
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3356
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3357

lab3356:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3357:

lab3358:
    jmp lab3360

lab3359:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3360:

lab3362:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3374
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab3375

lab3374:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3372
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3365
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3363
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3364

lab3363:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3364:

lab3365:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3368
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3366
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3367

lab3366:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3367:

lab3368:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3371
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3369
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3370

lab3369:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3370:

lab3371:
    jmp lab3373

lab3372:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3373:

lab3375:
    ; #load tag
    lea rdi, [rel List_ConflictSet_3376]
    ; jump lookup_head_
    jmp lookup_head_

List_ConflictSet_3376:
    jmp near List_ConflictSet_3376_Nil
    jmp near List_ConflictSet_3376_Cons

List_ConflictSet_3376_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3382
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3377
    ; ####increment refcount
    add qword [rax + 0], 1

lab3377:
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab3378
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3378:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab3379
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3379:
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab3380
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3380:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab3381
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3381:
    jmp lab3383

lab3382:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab3383:
    ; let x6: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    mov qword [rsp + 2024], 0
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(tbl := tbl)(x5 := x5)(x6 := x6);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, r12
    mov r12, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, r13
    mov r13, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_lookup_cache_0_
    jmp lift_lookup_cache_0_

List_ConflictSet_3376_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3389
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3384
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3384:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab3385
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3385:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab3386
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3386:
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab3387
    ; ####increment refcount
    add qword [rcx + 0], 1

lab3387:
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab3388
    ; ####increment refcount
    add qword [r14 + 0], 1

lab3388:
    jmp lab3390

lab3389:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab3390:
    ; substitute (x5 := x5)(csp0 := csp0)(a2 := a2)(tbl := tbl)(a := a)(as_ := as_)(a7 := a7)(as0 := as0);
    ; #move variables
    mov [rsp + 2016], rsi
    mov rsi, [rsp + 2032]
    mov [rsp + 2032], rax
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    ; let x6: List[ConflictSet] = Cons(a7, as0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3402
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab3403

lab3402:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3400
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3392

lab3391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3392:

lab3393:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3396
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3394
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3395

lab3394:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3395:

lab3396:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3399
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3397
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3398

lab3397:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3398:

lab3399:
    jmp lab3401

lab3400:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3401:

lab3403:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(tbl := tbl)(x5 := x5)(x6 := x6);
    ; #move variables
    mov rcx, r13
    mov r13, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, r15
    mov r15, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, r14
    ; jump lift_lookup_cache_0_
    jmp lift_lookup_cache_0_

lift_lookup_cache_0_:
    ; substitute (x6 := x6)(x5 := x5)(as_ := as_)(csp0 := csp0)(tbl := tbl)(a2 := a2)(a := a);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], rax
    mov rax, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    mov r14, rsi
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    ; create a5: ConflictSet = (as_, csp0, tbl, a2, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3415
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab3416

lab3415:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3413
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3406
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3404
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3405

lab3404:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3405:

lab3406:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3409
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3407
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3408

lab3407:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3408:

lab3409:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3412
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3410
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3411

lab3410:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3411:

lab3412:
    jmp lab3414

lab3413:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3414:

lab3416:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3428
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3429

lab3428:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3426
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3419
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3417
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3418

lab3417:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3418:

lab3419:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3422
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3420
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3421

lab3420:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3421:

lab3422:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3425
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3423
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3424

lab3423:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3424:

lab3425:
    jmp lab3427

lab3426:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3427:

lab3429:
    ; #load tag
    lea r9, [rel ConflictSet_3430]
    ; substitute (x5 := x5)(x6 := x6)(a5 := a5);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lookup_at_index_
    jmp lookup_at_index_

ConflictSet_3430:
    jmp near ConflictSet_3430_Known
    jmp near ConflictSet_3430_Unknown

ConflictSet_3430_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3436
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab3431
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3431:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab3432
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3432:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab3433
    ; ####increment refcount
    add qword [r14 + 0], 1

lab3433:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab3434
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3434:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab3435
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3435:
    jmp lab3437

lab3436:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab3437:
    ; substitute (a := a)(as_ := as_)(csp0 := csp0)(tbl := tbl)(a2 := a2)(vs1 := vs1);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    ; let table_entry: ConflictSet = Known(vs1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3449
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab3450

lab3449:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3447
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3440
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3438
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3439

lab3438:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3439:

lab3440:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3443
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3441
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3442

lab3441:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3442:

lab3443:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3446
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3444
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3445

lab3444:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3445:

lab3446:
    jmp lab3448

lab3447:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3448:

lab3450:
    ; #load tag
    mov r15, 0
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(table_entry := table_entry)(tbl := tbl);
    ; #move variables
    mov rcx, r12
    mov r12, r14
    mov r14, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, r15
    mov r15, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_lookup_cache_1_
    jmp lift_lookup_cache_1_

ConflictSet_3430_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3456
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab3451
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3451:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab3452
    ; ####increment refcount
    add qword [rax + 0], 1

lab3452:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3453
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3453:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3454
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3454:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3455
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3455:
    jmp lab3457

lab3456:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3457:
    ; let table_entry: ConflictSet = Unknown();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 5
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(table_entry := table_entry)(tbl := tbl);
    ; #move variables
    mov rcx, r12
    mov r12, r14
    mov r14, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r15
    mov r15, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump lift_lookup_cache_1_
    jmp lift_lookup_cache_1_

lift_lookup_cache_1_:
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(table_entry := table_entry)(tbl := tbl)(table_entry0 := table_entry);
    ; #share table_entry
    cmp r12, 0
    je lab3458
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3458:
    ; #move variables
    mov [rsp + 2032], r12
    mov [rsp + 2024], r13
    ; switch table_entry0 \{ ... \};
    lea rcx, [rel ConflictSet_3459]
    add rcx, [rsp + 2024]
    jmp rcx

ConflictSet_3459:
    jmp near ConflictSet_3459_Known
    jmp near ConflictSet_3459_Unknown

ConflictSet_3459_Known:
    ; #load from memory
    mov rcx, [rsp + 2032]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab3461
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    ; ###evacuate additional scratch register for memory block
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab3460
    ; ####increment refcount
    add qword [rcx + 0], 1

lab3460:
    ; ###restore evacuated register
    mov rax, [rsp + 2040]
    jmp lab3462

lab3461:
    ; ##... or release blocks onto linear free list when loading
    ; ###evacuate additional scratch register for memory block
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2032], rcx
    ; ###restore evacuated register
    mov rax, [rsp + 2040]

lab3462:
    ; substitute (a := a)(a2 := a2)(as_ := as_)(table_entry := table_entry)(tbl := tbl);
    ; #erase csp0
    cmp r10, 0
    je lab3465
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab3463
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab3464

lab3463:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab3464:

lab3465:
    ; #erase vals
    mov rcx, [rsp + 2032]
    cmp rcx, 0
    je lab3468
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3466
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3467

lab3466:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3467:

lab3468:
    ; #move variables
    mov r10, r12
    mov r11, r13
    mov r12, r14
    mov r13, r15
    ; jump share_lookup_cache_0_
    jmp share_lookup_cache_0_

ConflictSet_3459_Unknown:
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(tbl := tbl)(a7 := a)(as_0 := as_);
    ; #share a
    cmp rax, 0
    je lab3469
    ; ####increment refcount
    add qword [rax + 0], 1

lab3469:
    ; #share as_
    cmp r8, 0
    je lab3470
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3470:
    ; #erase table_entry
    cmp r12, 0
    je lab3473
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab3471
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab3472

lab3471:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab3472:

lab3473:
    ; #move variables
    mov r12, r14
    mov r14, rax
    mov r13, r15
    mov r15, rdx
    mov [rsp + 2032], r8
    mov [rsp + 2024], r9
    ; let x7: List[Assign] = Cons(a7, as_0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3485
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab3486

lab3485:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3483
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3476
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3474
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3475

lab3474:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3475:

lab3476:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3479
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3477
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3478

lab3477:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3478:

lab3479:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3482
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3480
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3481

lab3480:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3481:

lab3482:
    jmp lab3484

lab3483:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3484:

lab3486:
    ; #load tag
    mov r15, 5
    ; substitute (x7 := x7)(csp0 := csp0)(as_ := as_)(a2 := a2)(tbl := tbl)(a := a);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a6: ConflictSet = (as_, a2, tbl, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3498
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3499

lab3498:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3496
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3489
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3487
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3488

lab3487:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3488:

lab3489:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3492
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3490
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3491

lab3490:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3491:

lab3492:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3495
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3493
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3494

lab3493:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3494:

lab3495:
    jmp lab3497

lab3496:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3497:

lab3499:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3511
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3512

lab3511:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3509
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3502
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3500
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3501

lab3500:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3501:

lab3502:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3505
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3503
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3504

lab3503:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3504:

lab3505:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3508
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3506
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3507

lab3506:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3507:

lab3508:
    jmp lab3510

lab3509:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3510:

lab3512:
    ; #load tag
    lea r9, [rel ConflictSet_3513]
    ; substitute (csp0 := csp0)(x7 := x7)(a6 := a6);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump check_complete_
    jmp check_complete_

ConflictSet_3513:
    jmp near ConflictSet_3513_Known
    jmp near ConflictSet_3513_Unknown

ConflictSet_3513_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3518
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3514
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3514:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3515
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3515:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3516
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3516:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3517
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3517:
    jmp lab3519

lab3518:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3519:
    ; substitute (a := a)(as_ := as_)(a2 := a2)(tbl := tbl)(vs0 := vs0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; let cs: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3531
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab3532

lab3531:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3529
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3522
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3520
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3521

lab3520:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3521:

lab3522:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3525
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3523
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3524

lab3523:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3524:

lab3525:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3528
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3526
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3527

lab3526:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3527:

lab3528:
    jmp lab3530

lab3529:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3530:

lab3532:
    ; #load tag
    mov r13, 0
    ; substitute (a := a)(a2 := a2)(as_ := as_)(cs := cs)(tbl := tbl);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rcx, r12
    mov r12, r10
    mov r10, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, rcx
    ; jump share_lookup_cache_0_
    jmp share_lookup_cache_0_

ConflictSet_3513_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3537
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3533
    ; ####increment refcount
    add qword [rax + 0], 1

lab3533:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab3534
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3534:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab3535
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3535:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab3536
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3536:
    jmp lab3538

lab3537:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab3538:
    ; let cs: ConflictSet = Unknown();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 5
    ; substitute (a := a)(a2 := a2)(as_ := as_)(cs := cs)(tbl := tbl);
    ; #move variables
    mov rcx, r10
    mov r10, r12
    mov r12, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, r13
    mov r13, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump share_lookup_cache_0_
    jmp share_lookup_cache_0_

share_lookup_cache_0_:
    ; substitute (tbl := tbl)(a2 := a2)(cs := cs)(a := a)(as_ := as_);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a, as_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3550
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3551

lab3550:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3548
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3541
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3539
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3540

lab3539:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3540:

lab3541:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3544
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3542
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3543

lab3542:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3543:

lab3544:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3546

lab3545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3546:

lab3547:
    jmp lab3549

lab3548:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3549:

lab3551:
    ; #load tag
    mov r11, 5
    ; substitute (tbl := tbl)(a2 := a2)(x0 := x0)(cs := cs);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; let x1: Pair[List[Assign], ConflictSet] = Tup(x0, cs);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3563
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3564

lab3563:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3561
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3554
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3552
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3553

lab3552:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3553:

lab3554:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3557
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3555
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3556

lab3555:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3556:

lab3557:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3560
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3558
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3559

lab3558:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3559:

lab3560:
    jmp lab3562

lab3561:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3562:

lab3564:
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(tbl := tbl)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a2 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

checks_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_List_Assign_3565]
    add rcx, r9
    jmp rcx

List_Node_List_Assign_3565:
    jmp near List_Node_List_Assign_3565_Nil
    jmp near List_Node_List_Assign_3565_Cons

List_Node_List_Assign_3565_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab3568
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab3566
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab3567

lab3566:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab3567:

lab3568:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_List_Assign_3565_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3571
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3569
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3569:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3570
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3570:
    jmp lab3572

lab3571:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3572:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab3573
    ; ####increment refcount
    add qword [rax + 0], 1

lab3573:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], List[List[ConflictSet]]]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3585
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3586

lab3585:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3583
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3576
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3574
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3575

lab3574:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3575:

lab3576:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3579
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3577
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3578

lab3577:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3578:

lab3579:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3582
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3580
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3581

lab3580:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3581:

lab3582:
    jmp lab3584

lab3583:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3584:

lab3586:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_List_List_ConflictSet_3587]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_List_List_ConflictSet_3587:

Node_Pair_List_Assign_List_List_ConflictSet_3587_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3591
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3588
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3588:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3589
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3589:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3590
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3590:
    jmp lab3592

lab3591:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3592:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3604
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3605

lab3604:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3602
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3595
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3593
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3594

lab3593:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3594:

lab3595:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3598
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3596
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3597

lab3596:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3597:

lab3598:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3601
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3599
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3600

lab3599:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3600:

lab3601:
    jmp lab3603

lab3602:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3603:

lab3605:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3617
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3618

lab3617:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3615
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3608
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3606
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3607

lab3606:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3607:

lab3608:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3611
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3609
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3610

lab3609:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3610:

lab3611:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3614
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3612
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3613

lab3612:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3613:

lab3614:
    jmp lab3616

lab3615:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3616:

lab3618:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_List_List_ConflictSet_3619]
    ; jump checks_map_
    jmp checks_map_

List_Node_Pair_List_Assign_List_List_ConflictSet_3619:
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3619_Nil
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3619_Cons

List_Node_Pair_List_Assign_List_List_ConflictSet_3619_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3622
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3620
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3620:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3621
    ; ####increment refcount
    add qword [rax + 0], 1

lab3621:
    jmp lab3623

lab3622:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3623:
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_List_List_ConflictSet_3619_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3626
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3624
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3624:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3625
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3625:
    jmp lab3627

lab3626:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3627:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3639
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3640

lab3639:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3637
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3630
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3628
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3629

lab3628:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3629:

lab3630:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3633
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3631
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3632

lab3631:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3632:

lab3633:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3636
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3634
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3635

lab3634:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3635:

lab3636:
    jmp lab3638

lab3637:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3638:

lab3640:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

checks_tail_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_3641]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_3641:
    jmp near List_List_ConflictSet_3641_Nil
    jmp near List_List_ConflictSet_3641_Cons

List_List_ConflictSet_3641_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_3641_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3644
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3642
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3642:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3643
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3643:
    jmp lab3645

lab3644:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3645:
    ; substitute (a0 := a0)(ls0 := ls0);
    ; #erase l
    cmp rsi, 0
    je lab3648
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab3646
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab3647

lab3646:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab3647:

lab3648:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch ls0 \{ ... \};
    lea rcx, [rel List_List_ConflictSet_3649]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_3649:
    jmp near List_List_ConflictSet_3649_Nil
    jmp near List_List_ConflictSet_3649_Cons

List_List_ConflictSet_3649_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_3649_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3652
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3650
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3650:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3651
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3651:
    jmp lab3653

lab3652:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3653:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

cache_checks_:
    ; substitute (csp := csp)(tbl := tbl)(a0 := a0)(n := n);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_List_Assign_3654:

Node_List_Assign_3654_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab3657
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab3655
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3655:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab3656
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3656:
    jmp lab3658

lab3657:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab3658:
    ; substitute (csp := csp)(tbl := tbl)(a0 := a0)(s := s)(cs := cs)(s0 := s)(tbl0 := tbl);
    ; #share s
    cmp r10, 0
    je lab3659
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3659:
    ; #share tbl
    cmp rsi, 0
    je lab3660
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3660:
    ; #move variables
    mov [rsp + 2032], rsi
    mov [rsp + 2024], rdi
    mov r14, r10
    mov r15, r11
    ; let x0: Pair[List[Assign], List[List[ConflictSet]]] = Tup(s0, tbl0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3672
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab3673

lab3672:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3670
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3663
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3661
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3662

lab3661:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3662:

lab3663:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3666
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3664
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3665

lab3664:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3665:

lab3666:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3669
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3667
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3668

lab3667:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3668:

lab3669:
    jmp lab3671

lab3670:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3671:

lab3673:
    ; #load tag
    mov r15, 0
    ; substitute (csp := csp)(tbl := tbl)(cs := cs)(s := s)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    ; create a1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3685
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab3686

lab3685:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3683
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3676
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3674
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3675

lab3674:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3675:

lab3676:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3679
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3677
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3678

lab3677:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3678:

lab3679:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3682
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3680
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3681

lab3680:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3681:

lab3682:
    jmp lab3684

lab3683:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3684:

lab3686:
    ; #load tag
    lea r13, [rel List_Node_Pair_List_Assign_List_List_ConflictSet_3687]
    ; substitute (a1 := a1)(cs := cs)(tbl := tbl)(s := s)(csp := csp);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create x2: Fun[Node[List[Assign]], Node[Pair[List[Assign], List[List[ConflictSet]]]]] = (tbl, s, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3699
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3700

lab3699:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3697
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3690
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3688
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3689

lab3688:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3689:

lab3690:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3693
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3691
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3692

lab3691:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3692:

lab3693:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3696
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3694
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3695

lab3694:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3695:

lab3696:
    jmp lab3698

lab3697:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3698:

lab3700:
    ; #load tag
    lea r9, [rel Fun_Node_List_Assign_Node_Pair_List_Assign_List_List_ConflictSet_3701]
    ; substitute (x2 := x2)(cs := cs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump checks_map_
    jmp checks_map_

Fun_Node_List_Assign_Node_Pair_List_Assign_List_List_ConflictSet_3701:

Fun_Node_List_Assign_Node_Pair_List_Assign_List_List_ConflictSet_3701_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3705
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3702
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3702:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3703
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3703:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3704
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3704:
    jmp lab3706

lab3705:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3706:
    ; substitute (csp0 := csp)(s := s)(tbl := tbl)(a2 := a2)(csp := csp)(x := x);
    ; #share csp
    cmp r12, 0
    je lab3707
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3707:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    mov rax, r12
    mov rdx, r13
    ; create a3: List[List[ConflictSet]] = (a2, csp, x)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3719
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3720

lab3719:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3717
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3710
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3708
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3709

lab3708:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3709:

lab3710:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3713
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3711
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3712

lab3711:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3712:

lab3713:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3716
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3714
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3715

lab3714:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3715:

lab3716:
    jmp lab3718

lab3717:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3718:

lab3720:
    ; #load tag
    lea r11, [rel List_List_ConflictSet_3721]
    ; substitute (tbl := tbl)(s := s)(csp0 := csp0)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a4: List[List[ConflictSet]] = (s, csp0, a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3733
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab3734

lab3733:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3731
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3724
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3722
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3723

lab3722:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3723:

lab3724:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3727
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3725
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3726

lab3725:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3726:

lab3727:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3730
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3728
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3729

lab3728:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3729:

lab3730:
    jmp lab3732

lab3731:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3732:

lab3734:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_3735]
    ; jump checks_tail_
    jmp checks_tail_

List_List_ConflictSet_3735:
    jmp near List_List_ConflictSet_3735_Nil
    jmp near List_List_ConflictSet_3735_Cons

List_List_ConflictSet_3735_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3739
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab3736
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3736:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab3737
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3737:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab3738
    ; ####increment refcount
    add qword [rax + 0], 1

lab3738:
    jmp lab3740

lab3739:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab3740:
    ; let x4: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (s := s)(csp0 := csp0)(x4 := x4)(a3 := a3);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; jump fill_table_
    jmp fill_table_

List_List_ConflictSet_3735_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3744
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3741
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3741:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3742
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3742:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3743
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3743:
    jmp lab3745

lab3744:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3745:
    ; substitute (a3 := a3)(csp0 := csp0)(s := s)(a7 := a7)(as2 := as2);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x4: List[List[ConflictSet]] = Cons(a7, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3757
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3758

lab3757:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3755
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3748
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3746
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3747

lab3746:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3747:

lab3748:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3751
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3749
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3750

lab3749:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3750:

lab3751:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3754
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3752
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3753

lab3752:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3753:

lab3754:
    jmp lab3756

lab3755:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3756:

lab3758:
    ; #load tag
    mov r11, 5
    ; substitute (s := s)(csp0 := csp0)(x4 := x4)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump fill_table_
    jmp fill_table_

List_List_ConflictSet_3721:
    jmp near List_List_ConflictSet_3721_Nil
    jmp near List_List_ConflictSet_3721_Cons

List_List_ConflictSet_3721_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3762
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab3759
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3759:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab3760
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3760:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab3761
    ; ####increment refcount
    add qword [rax + 0], 1

lab3761:
    jmp lab3763

lab3762:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab3763:
    ; let x3: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (csp := csp)(x3 := x3)(x := x)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_List_ConflictSet_3721_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3767
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3764
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3764:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3765
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3765:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3766
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3766:
    jmp lab3768

lab3767:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3768:
    ; substitute (x := x)(csp := csp)(a2 := a2)(a6 := a6)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x3: List[List[ConflictSet]] = Cons(a6, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3780
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3781

lab3780:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3778
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3771
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3769
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3770

lab3769:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3770:

lab3771:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3774
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3772
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3773

lab3772:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3773:

lab3774:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3777
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3775
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3776

lab3775:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3776:

lab3777:
    jmp lab3779

lab3778:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3779:

lab3781:
    ; #load tag
    mov r11, 5
    ; substitute (csp := csp)(x3 := x3)(x := x)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r10
    mov r10, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r11
    mov r11, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_Node_Pair_List_Assign_List_List_ConflictSet_3687:
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3687_Nil
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3687_Cons

List_Node_Pair_List_Assign_List_List_ConflictSet_3687_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3784
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3782
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3782:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3783
    ; ####increment refcount
    add qword [rax + 0], 1

lab3783:
    jmp lab3785

lab3784:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3785:
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_List_List_ConflictSet_3687_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3788
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3786
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3786:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3787
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3787:
    jmp lab3789

lab3788:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3789:
    ; substitute (x0 := x0)(a0 := a0)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3801
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3802

lab3801:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3799
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3792
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3790
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3791

lab3790:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3791:

lab3792:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3795
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3793
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3794

lab3793:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3794:

lab3795:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3798
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3796
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3797

lab3796:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3797:

lab3798:
    jmp lab3800

lab3799:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3800:

lab3802:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bm_fst_:
    ; substitute (a0 := a0)(x := x);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch x \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3803:

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3803_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3806
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3804
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3804:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3805
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3805:
    jmp lab3807

lab3806:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3807:
    ; substitute (a0 := a0)(p := p);
    ; #erase ls
    cmp r8, 0
    je lab3810
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab3808
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab3809

lab3808:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab3809:

lab3810:
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_3811:

Pair_List_Assign_ConflictSet_3811_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3814
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3812
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3812:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3813
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3813:
    jmp lab3815

lab3814:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3815:
    ; substitute (a1 := a1)(b0 := b0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

bm_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3816]
    add rcx, r9
    jmp rcx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3816:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3816_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3816_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3816_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab3819
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab3817
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab3818

lab3817:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab3818:

lab3819:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3816_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3822
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3820
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3820:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3821
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3821:
    jmp lab3823

lab3822:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3823:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab3824
    ; ####increment refcount
    add qword [rax + 0], 1

lab3824:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3836
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3837

lab3836:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3834
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3827
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3825
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3826

lab3825:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3826:

lab3827:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3830
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3828
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3829

lab3828:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3829:

lab3830:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3833
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3831
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3832

lab3831:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3832:

lab3833:
    jmp lab3835

lab3834:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3835:

lab3837:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_3838]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_3838:

Node_Pair_List_Assign_ConflictSet_3838_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3842
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3839
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3839:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3840
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3840:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3841
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3841:
    jmp lab3843

lab3842:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3843:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3855
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3856

lab3855:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3853
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3846
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3844
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3845

lab3844:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3845:

lab3846:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3849
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3847
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3848

lab3847:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3848:

lab3849:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3852
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3850
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3851

lab3850:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3851:

lab3852:
    jmp lab3854

lab3853:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3854:

lab3856:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3868
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3869

lab3868:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3866
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3859
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3857
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3858

lab3857:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3858:

lab3859:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3862
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3860
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3861

lab3860:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3861:

lab3862:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3865
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3863
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3864

lab3863:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3864:

lab3865:
    jmp lab3867

lab3866:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3867:

lab3869:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_3870]
    ; jump bm_map_
    jmp bm_map_

List_Node_Pair_List_Assign_ConflictSet_3870:
    jmp near List_Node_Pair_List_Assign_ConflictSet_3870_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_3870_Cons

List_Node_Pair_List_Assign_ConflictSet_3870_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3873
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3871
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3871:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3872
    ; ####increment refcount
    add qword [rax + 0], 1

lab3872:
    jmp lab3874

lab3873:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3874:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_3870_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3877
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3875
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3875:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3876
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3876:
    jmp lab3878

lab3877:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3878:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3890
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3891

lab3890:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3888
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3881
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3879
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3880

lab3879:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3880:

lab3881:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3884
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3882
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3883

lab3882:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3883:

lab3884:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3887
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3885
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3886

lab3885:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3886:

lab3887:
    jmp lab3889

lab3888:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3889:

lab3891:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bm_map_tree_:
    ; substitute (f := f)(a0 := a0)(t := t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3892:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3892_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3895
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3893
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3893:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3894
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3894:
    jmp lab3896

lab3895:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3896:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab3897
    ; ####increment refcount
    add qword [rax + 0], 1

lab3897:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[List[Assign], ConflictSet] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3909
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3910

lab3909:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3907
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3900
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3898
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3899

lab3898:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3899:

lab3900:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3903
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3901
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3902

lab3901:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3902:

lab3903:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3906
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3904
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3905

lab3904:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3905:

lab3906:
    jmp lab3908

lab3907:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3908:

lab3910:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_3911]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_List_Assign_ConflictSet_3911:

Pair_List_Assign_ConflictSet_3911_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3915
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3912
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3912:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3913
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3913:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3914
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3914:
    jmp lab3916

lab3915:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3916:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a5 := a5)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3928
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3929

lab3928:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3926
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3919
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3917
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3918

lab3917:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3918:

lab3919:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3922
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3920
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3921

lab3920:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3921:

lab3922:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3925
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3923
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3924

lab3923:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3924:

lab3925:
    jmp lab3927

lab3926:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3927:

lab3929:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3941
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3942

lab3941:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3939
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3932
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3930
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3931

lab3930:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3931:

lab3932:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3935
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3933
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3934

lab3933:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3934:

lab3935:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3938
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3936
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3937

lab3936:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3937:

lab3938:
    jmp lab3940

lab3939:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3940:

lab3942:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_3943]
    ; substitute (a2 := a2)(ps := ps)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x2: Fun[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]], Node[Pair[List[Assign], ConflictSet]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3955
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3956

lab3955:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3953
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3946
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3944
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3945

lab3944:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3945:

lab3946:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3949
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3947
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3948

lab3947:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3948:

lab3949:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3952
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3950
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3951

lab3950:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3951:

lab3952:
    jmp lab3954

lab3953:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3954:

lab3956:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_3957]
    ; substitute (x2 := x2)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bm_map_
    jmp bm_map_

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_3957:

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_3957_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3959
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab3958
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3958:
    jmp lab3960

lab3959:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab3960:
    ; substitute (f := f)(x := x)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bm_map_tree_
    jmp bm_map_tree_

List_Node_Pair_List_Assign_ConflictSet_3943:
    jmp near List_Node_Pair_List_Assign_ConflictSet_3943_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_3943_Cons

List_Node_Pair_List_Assign_ConflictSet_3943_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3963
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3961
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3961:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3962
    ; ####increment refcount
    add qword [rax + 0], 1

lab3962:
    jmp lab3964

lab3963:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3964:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_3943_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3967
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3965
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3965:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3966
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3966:
    jmp lab3968

lab3967:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3968:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3980
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3981

lab3980:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3978
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3971
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3969
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3970

lab3969:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3970:

lab3971:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3974
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3972
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3973

lab3972:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3973:

lab3974:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3977
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3975
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3976

lab3975:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3976:

lab3977:
    jmp lab3979

lab3978:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3979:

lab3981:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bm_:
    ; create x0: Fun[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_3982]
    ; create a2: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3994
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3995

lab3994:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3992
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3985
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3983
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3984

lab3983:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3984:

lab3985:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3988
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3986
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3987

lab3986:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3987:

lab3988:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3991
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3989
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3990

lab3989:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3990:

lab3991:
    jmp lab3993

lab3992:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3993:

lab3995:
    ; #load tag
    lea r9, [rel Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3996]
    ; substitute (csp0 := csp)(t := t)(a2 := a2)(csp := csp);
    ; #share csp
    cmp rax, 0
    je lab3997
    ; ####increment refcount
    add qword [rax + 0], 1

lab3997:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a3: Node[Pair[List[Assign], List[List[ConflictSet]]]] = (a2, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4009
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4010

lab4009:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4007
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4000
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3998
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3999

lab3998:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3999:

lab4000:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4003
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4001
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4002

lab4001:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4002:

lab4003:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4006
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4004
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4005

lab4004:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4005:

lab4006:
    jmp lab4008

lab4007:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4008:

lab4010:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_List_List_ConflictSet_4011]
    ; substitute (csp00 := csp0)(t := t)(a3 := a3)(csp0 := csp0);
    ; #share csp0
    cmp rax, 0
    je lab4012
    ; ####increment refcount
    add qword [rax + 0], 1

lab4012:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a4: List[List[ConflictSet]] = (t, a3, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4024
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4025

lab4024:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4022
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4015
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4013
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4014

lab4013:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4014:

lab4015:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4018
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4016
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4017

lab4016:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4017:

lab4018:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4021
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4019
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4020

lab4019:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4020:

lab4021:
    jmp lab4023

lab4022:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4023:

lab4025:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_4026]
    ; jump empty_table_
    jmp empty_table_

List_List_ConflictSet_4026:
    jmp near List_List_ConflictSet_4026_Nil
    jmp near List_List_ConflictSet_4026_Cons

List_List_ConflictSet_4026_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4030
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab4027
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4027:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4028
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4028:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab4029
    ; ####increment refcount
    add qword [rax + 0], 1

lab4029:
    jmp lab4031

lab4030:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab4031:
    ; let x3: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (csp0 := csp0)(x3 := x3)(t := t)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_List_ConflictSet_4026_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4035
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4032
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4032:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4033
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4033:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4034
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4034:
    jmp lab4036

lab4035:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4036:
    ; substitute (csp0 := csp0)(a3 := a3)(t := t)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x3: List[List[ConflictSet]] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4048
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4049

lab4048:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4046
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4039
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4037
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4038

lab4037:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4038:

lab4039:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4042
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4040
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4041

lab4040:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4041:

lab4042:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4045
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4043
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4044

lab4043:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4044:

lab4045:
    jmp lab4047

lab4046:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4047:

lab4049:
    ; #load tag
    mov r11, 5
    ; substitute (csp0 := csp0)(x3 := x3)(t := t)(a3 := a3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

Node_Pair_List_Assign_List_List_ConflictSet_4011:

Node_Pair_List_Assign_List_List_ConflictSet_4011_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4052
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4050
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4050:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4051
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4051:
    jmp lab4053

lab4052:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4053:
    ; substitute (csp := csp)(a2 := a2)(lab1 := lab1)(children1 := children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: Node[Pair[List[Assign], List[List[ConflictSet]]]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4065
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4066

lab4065:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4063
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4056
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4054
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4055

lab4054:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4055:

lab4056:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4059
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4057
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4058

lab4057:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4058:

lab4059:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4062
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4060
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4061

lab4060:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4061:

lab4062:
    jmp lab4064

lab4063:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4064:

lab4066:
    ; #load tag
    mov r9, 0
    ; substitute (csp := csp)(x2 := x2)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lookup_cache_
    jmp lookup_cache_

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3996:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3996_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4069
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4067
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4067:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4068
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4068:
    jmp lab4070

lab4069:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4070:
    ; substitute (x0 := x0)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4082
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4083

lab4082:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4080
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4073
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4071
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4072

lab4071:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4072:

lab4073:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4076
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4074
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4075

lab4074:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4075:

lab4076:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4079
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4077
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4078

lab4077:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4078:

lab4079:
    jmp lab4081

lab4080:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4081:

lab4083:
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump bm_map_tree_
    jmp bm_map_tree_

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_3982:

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_3982_Apply:
    ; jump bm_fst_
    jmp bm_fst_

in_list_:
    ; substitute (i := i)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_4084]
    add rcx, r9
    jmp rcx

List_i64_4084:
    jmp near List_i64_4084_Nil
    jmp near List_i64_4084_Cons

List_i64_4084_Nil:
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 False
    add rdx, 5
    jmp rdx

List_i64_4084_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4086
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4085
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4085:
    mov r9, [r8 + 40]
    jmp lab4087

lab4086:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4087:
    ; if i == j \{ ... \}
    cmp rdx, r9
    je lab4088
    ; else branch
    ; substitute (i := i)(js := js)(a0 := a0);
    ; #move variables
    mov r8, rsi
    mov r9, rdi
    mov rsi, r10
    mov rdi, r11
    ; jump in_list_
    jmp in_list_

lab4088:
    ; then branch
    ; substitute (a0 := a0);
    ; #erase js
    cmp r10, 0
    je lab4091
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab4089
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab4090

lab4089:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab4090:

lab4091:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 True
    add rdx, 0
    jmp rdx

not_elem_:
    ; create a1: Bool = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4103
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4104

lab4103:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4101
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4094
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4092
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4093

lab4092:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4093:

lab4094:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4097
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4095
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4096

lab4095:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4096:

lab4097:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4100
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4098
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4099

lab4098:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4099:

lab4100:
    jmp lab4102

lab4101:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4102:

lab4104:
    ; #load tag
    lea r9, [rel Bool_4105]
    ; jump in_list_
    jmp in_list_

Bool_4105:
    jmp near Bool_4105_True
    jmp near Bool_4105_False

Bool_4105_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4107
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4106
    ; ####increment refcount
    add qword [rax + 0], 1

lab4106:
    jmp lab4108

lab4107:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4108:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_4105_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4110
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4109
    ; ####increment refcount
    add qword [rax + 0], 1

lab4109:
    jmp lab4111

lab4110:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4111:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

append_:
    ; substitute (a0 := a0)(l2 := l2)(l1 := l1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch l1 \{ ... \};
    lea rcx, [rel List_i64_4112]
    add rcx, r9
    jmp rcx

List_i64_4112:
    jmp near List_i64_4112_Nil
    jmp near List_i64_4112_Cons

List_i64_4112_Nil:
    ; switch l2 \{ ... \};
    lea rcx, [rel List_i64_4113]
    add rcx, rdi
    jmp rcx

List_i64_4113:
    jmp near List_i64_4113_Nil
    jmp near List_i64_4113_Cons

List_i64_4113_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4113_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4115
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4114
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4114:
    mov rdi, [rsi + 40]
    jmp lab4116

lab4115:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4116:
    ; substitute (a2 := a2)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4112_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4118
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4117
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4117:
    mov r9, [r8 + 40]
    jmp lab4119

lab4118:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4119:
    ; substitute (iss := iss)(l2 := l2)(is := is)(a0 := a0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a1: List[i64] = (is, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4131
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4132

lab4131:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4129
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4122
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4120
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4121

lab4120:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4121:

lab4122:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4125
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4123
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4124

lab4123:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4124:

lab4125:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4128
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4126
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4127

lab4126:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4127:

lab4128:
    jmp lab4130

lab4129:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4130:

lab4132:
    ; #load tag
    lea r9, [rel List_i64_4133]
    ; jump append_
    jmp append_

List_i64_4133:
    jmp near List_i64_4133_Nil
    jmp near List_i64_4133_Cons

List_i64_4133_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4135
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4134
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4134:
    mov rdx, [rax + 40]
    jmp lab4136

lab4135:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab4136:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (is := is)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4133_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4138
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4137
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4137:
    mov r9, [r8 + 40]
    jmp lab4139

lab4138:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4139:
    ; substitute (a0 := a0)(is := is)(a3 := a3)(as1 := as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a3, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4151
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4152

lab4151:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4149
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4142
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4140
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4141

lab4140:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4141:

lab4142:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4145
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4143
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4144

lab4143:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4144:

lab4145:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4148
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4146
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4147

lab4146:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4147:

lab4148:
    jmp lab4150

lab4149:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4150:

lab4152:
    ; #load tag
    mov r9, 5
    ; substitute (is := is)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

delete_by_:
    ; substitute (f := f)(x := x)(a0 := a0)(ys := ys);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch ys \{ ... \};
    lea rcx, [rel List_i64_4153]
    add rcx, r11
    jmp rcx

List_i64_4153:
    jmp near List_i64_4153_Nil
    jmp near List_i64_4153_Cons

List_i64_4153_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab4156
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4154
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4155

lab4154:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4155:

lab4156:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4153_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab4158
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab4157
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4157:
    mov r11, [r10 + 40]
    jmp lab4159

lab4158:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]

lab4159:
    ; substitute (f0 := f)(x1 := x)(y0 := y)(y := y)(ys0 := ys0)(f := f)(x := x)(a0 := a0);
    ; #share f
    cmp rax, 0
    je lab4160
    ; ####increment refcount
    add qword [rax + 0], 1

lab4160:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov [rsp + 2024], rdi
    mov [rsp + 2016], r8
    mov [rsp + 2008], r9
    mov r9, r11
    ; create a2: Bool = (y, ys0, f, x, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov [rbx + 24], r15
    mov [rbx + 16], r14
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4172
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab4173

lab4172:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4170
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4163
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4161
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4162

lab4161:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4162:

lab4163:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4166
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4164
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4165

lab4164:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4165:

lab4166:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4169
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4167
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4168

lab4167:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4168:

lab4169:
    jmp lab4171

lab4170:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4171:

lab4173:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4185
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4186

lab4185:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4183
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4176
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4174
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4175

lab4174:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4175:

lab4176:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4179
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4177
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4178

lab4177:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4178:

lab4179:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4182
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4180
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4181

lab4180:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4181:

lab4182:
    jmp lab4184

lab4183:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4184:

lab4186:
    ; #load tag
    lea r11, [rel Bool_4187]
    ; let a3: Fun[i64, Bool] = Apply(y0, a2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4199
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4200

lab4199:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4197
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4190
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4188
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4189

lab4188:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4189:

lab4190:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4193
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4191
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4192

lab4191:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4192:

lab4193:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4196
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4194
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4195

lab4194:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4195:

lab4196:
    jmp lab4198

lab4197:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4198:

lab4200:
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(a3 := a3)(f0 := f0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_4187:
    jmp near Bool_4187_True
    jmp near Bool_4187_False

Bool_4187_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4204
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4201
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4201:
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4202
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4202:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4203
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4203:
    jmp lab4205

lab4204:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4205:
    ; substitute (a0 := a0)(ys0 := ys0);
    ; #erase f
    cmp r8, 0
    je lab4208
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab4206
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab4207

lab4206:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab4207:

lab4208:
    ; #move variables
    mov rax, r12
    mov rdx, r13
    ; switch ys0 \{ ... \};
    lea rcx, [rel List_i64_4209]
    add rcx, rdi
    jmp rcx

List_i64_4209:
    jmp near List_i64_4209_Nil
    jmp near List_i64_4209_Cons

List_i64_4209_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4209_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4211
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4210
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4210:
    mov rdi, [rsi + 40]
    jmp lab4212

lab4211:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4212:
    ; substitute (a4 := a4)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_4187_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4216
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4213
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4213:
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4214
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4214:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4215
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4215:
    jmp lab4217

lab4216:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4217:
    ; substitute (x := x)(ys0 := ys0)(f := f)(y := y)(a0 := a0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a1: List[i64] = (y, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4229
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4230

lab4229:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4227
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4220
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4218
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4219

lab4218:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4219:

lab4220:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4223
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4221
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4222

lab4221:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4222:

lab4223:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4226
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4224
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4225

lab4224:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4225:

lab4226:
    jmp lab4228

lab4227:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4228:

lab4230:
    ; #load tag
    lea r11, [rel List_i64_4231]
    ; substitute (f := f)(x := x)(ys0 := ys0)(a1 := a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump delete_by_
    jmp delete_by_

List_i64_4231:
    jmp near List_i64_4231_Nil
    jmp near List_i64_4231_Cons

List_i64_4231_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4233
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4232
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4232:
    mov rdx, [rax + 40]
    jmp lab4234

lab4233:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab4234:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (y := y)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4231_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4236
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4235
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4235:
    mov r9, [r8 + 40]
    jmp lab4237

lab4236:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4237:
    ; substitute (a0 := a0)(y := y)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4249
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4250

lab4249:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4247
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4239

lab4238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4239:

lab4240:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4242

lab4241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4242:

lab4243:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4246
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4244
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4245

lab4244:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4245:

lab4246:
    jmp lab4248

lab4247:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4248:

lab4250:
    ; #load tag
    mov r9, 5
    ; substitute (y := y)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

nub_by_:
    ; substitute (f := f)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_4251]
    add rcx, r9
    jmp rcx

List_i64_4251:
    jmp near List_i64_4251_Nil
    jmp near List_i64_4251_Cons

List_i64_4251_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab4254
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4252
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4253

lab4252:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4253:

lab4254:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4251_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4256
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4255
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4255:
    mov r9, [r8 + 40]
    jmp lab4257

lab4256:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4257:
    ; substitute (f := f)(t := t)(h0 := h)(h := h)(a0 := a0);
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    mov rdi, r11
    mov r11, r9
    mov rsi, r10
    ; create a1: List[i64] = (h, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4269
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4270

lab4269:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4267
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4259

lab4258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4259:

lab4260:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4263
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4261
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4262

lab4261:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4262:

lab4263:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4266
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4264
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4265

lab4264:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4265:

lab4266:
    jmp lab4268

lab4267:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4268:

lab4270:
    ; #load tag
    lea r11, [rel List_i64_4271]
    ; substitute (f0 := f)(t := t)(h0 := h0)(a1 := a1)(f := f);
    ; #share f
    cmp rax, 0
    je lab4272
    ; ####increment refcount
    add qword [rax + 0], 1

lab4272:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    ; create a2: List[i64] = (a1, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4284
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4285

lab4284:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4282
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4275
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4273
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4274

lab4273:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4274:

lab4275:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4278
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4276
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4277

lab4276:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4277:

lab4278:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4281
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4279
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4280

lab4279:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4280:

lab4281:
    jmp lab4283

lab4282:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4283:

lab4285:
    ; #load tag
    lea r11, [rel List_i64_4286]
    ; substitute (a2 := a2)(t := t)(h0 := h0)(f0 := f0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create x2: Fun[i64, Bool] = (h0, f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4298
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4299

lab4298:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4296
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4289
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4287
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4288

lab4287:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4288:

lab4289:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4292
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4290
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4291

lab4290:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4291:

lab4292:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4295
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4293
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4294

lab4293:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4294:

lab4295:
    jmp lab4297

lab4296:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4297:

lab4299:
    ; #load tag
    lea r9, [rel Fun_i64_Bool_4300]
    ; substitute (x2 := x2)(t := t)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump filter_union_
    jmp filter_union_

Fun_i64_Bool_4300:

Fun_i64_Bool_4300_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4302
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4301
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4301:
    mov r9, [r8 + 40]
    jmp lab4303

lab4302:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4303:
    ; substitute (y := y)(f0 := f0)(h0 := h0)(a3 := a3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a4: Bool = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4315
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4316

lab4315:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4313
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4306
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4304
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4305

lab4304:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4305:

lab4306:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4309
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4307
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4308

lab4307:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4308:

lab4309:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4312
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4310
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4311

lab4310:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4311:

lab4312:
    jmp lab4314

lab4313:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4314:

lab4316:
    ; #load tag
    lea r11, [rel Bool_4317]
    ; substitute (h0 := h0)(f0 := f0)(y := y)(a4 := a4);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let a5: Fun[i64, Bool] = Apply(y, a4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4329
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4330

lab4329:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4327
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4320
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4318
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4319

lab4318:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4319:

lab4320:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4323
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4321
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4322

lab4321:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4322:

lab4323:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4326
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4324
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4325

lab4324:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4325:

lab4326:
    jmp lab4328

lab4327:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4328:

lab4330:
    ; #load tag
    mov r9, 0
    ; substitute (h0 := h0)(a5 := a5)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_4317:
    jmp near Bool_4317_True
    jmp near Bool_4317_False

Bool_4317_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4332
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4331
    ; ####increment refcount
    add qword [rax + 0], 1

lab4331:
    jmp lab4333

lab4332:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4333:
    ; let x3: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x3 := x3)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_4317_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4335
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4334
    ; ####increment refcount
    add qword [rax + 0], 1

lab4334:
    jmp lab4336

lab4335:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4336:
    ; let x3: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x3 := x3)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

List_i64_4286:
    jmp near List_i64_4286_Nil
    jmp near List_i64_4286_Cons

List_i64_4286_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4339
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4337
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4337:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4338
    ; ####increment refcount
    add qword [rax + 0], 1

lab4338:
    jmp lab4340

lab4339:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab4340:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (f := f)(x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump nub_by_
    jmp nub_by_

List_i64_4286_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4343
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4341
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4341:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4342
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4342:
    jmp lab4344

lab4343:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4344:
    ; substitute (f := f)(a1 := a1)(a7 := a7)(as1 := as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a7, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4356
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4357

lab4356:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4354
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4347
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4345
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4346

lab4345:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4346:

lab4347:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4350
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4348
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4349

lab4348:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4349:

lab4350:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4353
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4351
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4352

lab4351:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4352:

lab4353:
    jmp lab4355

lab4354:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4355:

lab4357:
    ; #load tag
    mov r9, 5
    ; substitute (f := f)(x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump nub_by_
    jmp nub_by_

List_i64_4271:
    jmp near List_i64_4271_Nil
    jmp near List_i64_4271_Cons

List_i64_4271_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4359
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4358
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4358:
    mov rdx, [rax + 40]
    jmp lab4360

lab4359:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab4360:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (h := h)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4271_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4362
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4361
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4361:
    mov r9, [r8 + 40]
    jmp lab4363

lab4362:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4363:
    ; substitute (a0 := a0)(h := h)(a6 := a6)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4375
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4376

lab4375:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4373
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4366
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4364
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4365

lab4364:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4365:

lab4366:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4369
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4367
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4368

lab4367:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4368:

lab4369:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4372
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4370
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4371

lab4370:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4371:

lab4372:
    jmp lab4374

lab4373:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4374:

lab4376:
    ; #load tag
    mov r9, 5
    ; substitute (h := h)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

filter_union_:
    ; substitute (f := f)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_4377]
    add rcx, r9
    jmp rcx

List_i64_4377:
    jmp near List_i64_4377_Nil
    jmp near List_i64_4377_Cons

List_i64_4377_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab4380
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4378
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4379

lab4378:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4379:

lab4380:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4377_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4382
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4381
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4381:
    mov r9, [r8 + 40]
    jmp lab4383

lab4382:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4383:
    ; substitute (f0 := f)(i0 := i)(i := i)(is := is)(f := f)(a0 := a0);
    ; #share f
    cmp rax, 0
    je lab4384
    ; ####increment refcount
    add qword [rax + 0], 1

lab4384:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rdi, r9
    ; create a2: Bool = (i, is, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4396
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4397

lab4396:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4394
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4387
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4385
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4386

lab4385:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4386:

lab4387:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4390
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4388
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4389

lab4388:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4389:

lab4390:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4392

lab4391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4392:

lab4393:
    jmp lab4395

lab4394:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4395:

lab4397:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4409
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4410

lab4409:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4407
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4400
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4398
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4399

lab4398:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4399:

lab4400:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4403
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4401
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4402

lab4401:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4402:

lab4403:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4406
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4404
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4405

lab4404:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4405:

lab4406:
    jmp lab4408

lab4407:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4408:

lab4410:
    ; #load tag
    lea r9, [rel Bool_4411]
    ; substitute (i0 := i0)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_4411:
    jmp near Bool_4411_True
    jmp near Bool_4411_False

Bool_4411_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4415
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4412
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4412:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4413
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4413:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4414
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4414:
    jmp lab4416

lab4415:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4416:
    ; substitute (f := f)(is := is)(i := i)(a0 := a0);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r8
    ; create a1: List[i64] = (i, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4428
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4429

lab4428:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4426
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4419
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4417
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4418

lab4417:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4418:

lab4419:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4422
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4420
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4421

lab4420:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4421:

lab4422:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4425
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4423
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4424

lab4423:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4424:

lab4425:
    jmp lab4427

lab4426:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4427:

lab4429:
    ; #load tag
    lea r9, [rel List_i64_4430]
    ; jump filter_union_
    jmp filter_union_

List_i64_4430:
    jmp near List_i64_4430_Nil
    jmp near List_i64_4430_Cons

List_i64_4430_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4432
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4431
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4431:
    mov rdx, [rax + 40]
    jmp lab4433

lab4432:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab4433:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (i := i)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4430_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4435
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4434
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4434:
    mov r9, [r8 + 40]
    jmp lab4436

lab4435:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4436:
    ; substitute (a0 := a0)(i := i)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4448
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4449

lab4448:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4446
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4438

lab4437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4438:

lab4439:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4442
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4440
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4441

lab4440:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4441:

lab4442:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4445
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4443
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4444

lab4443:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4444:

lab4445:
    jmp lab4447

lab4446:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4447:

lab4449:
    ; #load tag
    mov r9, 5
    ; substitute (i := i)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_4411_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4453
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4450
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4450:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4451
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4451:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4452
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4452:
    jmp lab4454

lab4453:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4454:
    ; substitute (f := f)(is := is)(a0 := a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump filter_union_
    jmp filter_union_

foldl_:
    ; substitute (f := f)(a := a)(a0 := a0)(xs := xs);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch xs \{ ... \};
    lea rcx, [rel List_i64_4455]
    add rcx, r11
    jmp rcx

List_i64_4455:
    jmp near List_i64_4455_Nil
    jmp near List_i64_4455_Cons

List_i64_4455_Nil:
    ; substitute (a0 := a0)(a := a);
    ; #erase f
    cmp rax, 0
    je lab4458
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4456
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4457

lab4456:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4457:

lab4458:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; switch a \{ ... \};
    lea rcx, [rel List_i64_4459]
    add rcx, rdi
    jmp rcx

List_i64_4459:
    jmp near List_i64_4459_Nil
    jmp near List_i64_4459_Cons

List_i64_4459_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4459_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4461
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4460
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4460:
    mov rdi, [rsi + 40]
    jmp lab4462

lab4461:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4462:
    ; substitute (a3 := a3)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4455_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab4464
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab4463
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4463:
    mov r11, [r10 + 40]
    jmp lab4465

lab4464:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]

lab4465:
    ; substitute (f0 := f)(a := a)(h := h)(a0 := a0)(t := t)(f := f);
    ; #share f
    cmp rax, 0
    je lab4466
    ; ####increment refcount
    add qword [rax + 0], 1

lab4466:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov r10, r8
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; create a1: List[i64] = (a0, t, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4478
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4479

lab4478:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4476
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4469
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4467
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4468

lab4467:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4468:

lab4469:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4472
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4470
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4471

lab4470:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4471:

lab4472:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4475
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4473
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4474

lab4473:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4474:

lab4475:
    jmp lab4477

lab4476:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4477:

lab4479:
    ; #load tag
    lea r11, [rel List_i64_4480]
    ; let a2: Fun[i64, List[i64]] = Apply(h, a1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4492
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4493

lab4492:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4490
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4483
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4481
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4482

lab4481:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4482:

lab4483:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4486
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4484
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4485

lab4484:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4485:

lab4486:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4489
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4487
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4488

lab4487:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4488:

lab4489:
    jmp lab4491

lab4490:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4491:

lab4493:
    ; #load tag
    mov r9, 0
    ; substitute (a := a)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_i64_4480:
    jmp near List_i64_4480_Nil
    jmp near List_i64_4480_Cons

List_i64_4480_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4497
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab4494
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4494:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4495
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4495:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab4496
    ; ####increment refcount
    add qword [rax + 0], 1

lab4496:
    jmp lab4498

lab4497:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab4498:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (f := f)(x0 := x0)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump foldl_
    jmp foldl_

List_i64_4480_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4502
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4499
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4499:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4500
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4500:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4501
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4501:
    jmp lab4503

lab4502:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4503:
    ; substitute (f := f)(t := t)(a0 := a0)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x0: List[i64] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4515
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4516

lab4515:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4513
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4506
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4504
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4505

lab4504:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4505:

lab4506:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4509
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4507
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4508

lab4507:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4508:

lab4509:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4512
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4510
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4511

lab4510:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4511:

lab4512:
    jmp lab4514

lab4513:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4514:

lab4516:
    ; #load tag
    mov r11, 5
    ; substitute (f := f)(x0 := x0)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump foldl_
    jmp foldl_

union_by_:
    ; substitute (f := f)(l10 := l1)(l2 := l2)(a0 := a0)(l1 := l1);
    ; #share l1
    cmp rsi, 0
    je lab4517
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4517:
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    ; create a1: List[i64] = (a0, l1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4529
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4530

lab4529:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4527
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4520
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4518
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4519

lab4518:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4519:

lab4520:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4523
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4521
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4522

lab4521:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4522:

lab4523:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4526
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4524
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4525

lab4524:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4525:

lab4526:
    jmp lab4528

lab4527:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4528:

lab4530:
    ; #load tag
    lea r11, [rel List_i64_4531]
    ; substitute (f0 := f)(l10 := l10)(l2 := l2)(a1 := a1)(f := f);
    ; #share f
    cmp rax, 0
    je lab4532
    ; ####increment refcount
    add qword [rax + 0], 1

lab4532:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    ; create x1: Fun[List[i64], Fun[i64, List[i64]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4544
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab4545

lab4544:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4542
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4535
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4533
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4534

lab4533:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4534:

lab4535:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4538
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4536
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4537

lab4536:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4537:

lab4538:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4541
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4539
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4540

lab4539:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4540:

lab4541:
    jmp lab4543

lab4542:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4543:

lab4545:
    ; #load tag
    lea r13, [rel Fun_List_i64_Fun_i64_List_i64_4546]
    ; substitute (f0 := f0)(l2 := l2)(l10 := l10)(a1 := a1)(x1 := x1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a4: List[i64] = (l10, a1, x1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4558
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4559

lab4558:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4556
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4549
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4547
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4548

lab4547:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4548:

lab4549:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4552
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4550
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4551

lab4550:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4551:

lab4552:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4555
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4553
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4554

lab4553:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4554:

lab4555:
    jmp lab4557

lab4556:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4557:

lab4559:
    ; #load tag
    lea r9, [rel List_i64_4560]
    ; jump nub_by_
    jmp nub_by_

List_i64_4560:
    jmp near List_i64_4560_Nil
    jmp near List_i64_4560_Cons

List_i64_4560_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4564
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab4561
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4561:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4562
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4562:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab4563
    ; ####increment refcount
    add qword [rax + 0], 1

lab4563:
    jmp lab4565

lab4564:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab4565:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (x1 := x1)(x2 := x2)(l10 := l10)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump foldl_
    jmp foldl_

List_i64_4560_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4569
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4566
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4566:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4567
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4567:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4568
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4568:
    jmp lab4570

lab4569:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4570:
    ; substitute (x1 := x1)(a1 := a1)(l10 := l10)(a6 := a6)(as1 := as1);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x2: List[i64] = Cons(a6, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4582
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4583

lab4582:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4580
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4573
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4571
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4572

lab4571:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4572:

lab4573:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4576
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4574
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4575

lab4574:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4575:

lab4576:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4579
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4577
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4578

lab4577:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4578:

lab4579:
    jmp lab4581

lab4580:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4581:

lab4583:
    ; #load tag
    mov r11, 5
    ; substitute (x1 := x1)(x2 := x2)(l10 := l10)(a1 := a1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump foldl_
    jmp foldl_

Fun_List_i64_Fun_i64_List_i64_4546:

Fun_List_i64_Fun_i64_List_i64_4546_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4585
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab4584
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4584:
    jmp lab4586

lab4585:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab4586:
    ; substitute (acc := acc)(f := f)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Fun_i64_List_i64_4587:

Fun_i64_List_i64_4587_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4589
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4588
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4588:
    mov r9, [r8 + 40]
    jmp lab4590

lab4589:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4590:
    ; substitute (f := f)(y := y)(acc := acc)(a3 := a3);
    ; #move variables
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump delete_by_
    jmp delete_by_

List_i64_4531:
    jmp near List_i64_4531_Nil
    jmp near List_i64_4531_Cons

List_i64_4531_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4593
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4591
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4591:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4592
    ; ####increment refcount
    add qword [rax + 0], 1

lab4592:
    jmp lab4594

lab4593:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab4594:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l1 := l1)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump append_
    jmp append_

List_i64_4531_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4597
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4595
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4595:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4596
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4596:
    jmp lab4598

lab4597:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4598:
    ; substitute (l1 := l1)(a0 := a0)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4610
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4611

lab4610:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4608
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4601
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4599
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4600

lab4599:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4600:

lab4601:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4604
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4602
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4603

lab4602:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4603:

lab4604:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4607
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4605
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4606

lab4605:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4606:

lab4607:
    jmp lab4609

lab4608:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4609:

lab4611:
    ; #load tag
    mov r9, 5
    ; substitute (l1 := l1)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump append_
    jmp append_

union_:
    ; create x0: Fun[i64, Fun[i64, Bool]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_i64_Fun_i64_Bool_4612]
    ; substitute (x0 := x0)(l1 := l1)(l2 := l2)(a0 := a0);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump union_by_
    jmp union_by_

Fun_i64_Fun_i64_Bool_4612:

Fun_i64_Fun_i64_Bool_4612_Apply:
    ; switch a1 \{ ... \};
    ; #there is only one clause, so we can just fall through

Fun_i64_Bool_4613:

Fun_i64_Bool_4613_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4615
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4614
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4614:
    mov rdi, [rsi + 40]
    jmp lab4616

lab4615:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4616:
    ; jump eq_
    jmp eq_

combine_:
    ; substitute (a0 := a0)(acc := acc)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_4617]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_4617:
    jmp near List_Pair_List_Assign_ConflictSet_4617_Nil
    jmp near List_Pair_List_Assign_ConflictSet_4617_Cons

List_Pair_List_Assign_ConflictSet_4617_Nil:
    ; switch acc \{ ... \};
    lea rcx, [rel List_i64_4618]
    add rcx, rdi
    jmp rcx

List_i64_4618:
    jmp near List_i64_4618_Nil
    jmp near List_i64_4618_Cons

List_i64_4618_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4618_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4620
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4619
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4619:
    mov rdi, [rsi + 40]
    jmp lab4621

lab4620:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4621:
    ; substitute (a4 := a4)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_4617_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4624
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4622
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4622:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4623
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4623:
    jmp lab4625

lab4624:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4625:
    ; substitute (a0 := a0)(acc := acc)(css := css)(p := p);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_4626:

Pair_List_Assign_ConflictSet_4626_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab4629
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab4627
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4627:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab4628
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4628:
    jmp lab4630

lab4629:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab4630:
    ; switch cs \{ ... \};
    lea rcx, [rel ConflictSet_4631]
    add rcx, r13
    jmp rcx

ConflictSet_4631:
    jmp near ConflictSet_4631_Known
    jmp near ConflictSet_4631_Unknown

ConflictSet_4631_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab4633
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r13, [r12 + 56]
    mov r12, [r12 + 48]
    cmp r12, 0
    je lab4632
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4632:
    jmp lab4634

lab4633:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r13, [r12 + 56]
    mov r12, [r12 + 48]

lab4634:
    ; substitute (s := s)(acc := acc)(css := css)(a0 := a0)(cs0 := cs0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a2: _Cont = (acc, css, a0, cs0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4646
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4647

lab4646:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4644
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4637
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4635
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4636

lab4635:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4636:

lab4637:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4640
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4638
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4639

lab4638:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4639:

lab4640:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4643
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4641
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4642

lab4641:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4642:

lab4643:
    jmp lab4645

lab4644:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4645:

lab4647:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4659
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4660

lab4659:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4657
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4650
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4648
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4649

lab4648:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4649:

lab4650:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4653
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4651
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4652

lab4651:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4652:

lab4653:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4656
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4654
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4655

lab4654:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4655:

lab4656:
    jmp lab4658

lab4657:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4658:

lab4660:
    ; #load tag
    lea rdi, [rel _Cont_4661]
    ; jump max_level_
    jmp max_level_

_Cont_4661:

_Cont_4661_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4666
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab4662
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4662:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4663
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4663:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4664
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4664:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4665
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4665:
    jmp lab4667

lab4666:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4667:
    ; substitute (x0 := x0)(cs00 := cs0)(css := css)(a0 := a0)(cs0 := cs0)(acc := acc);
    ; #share cs0
    cmp r12, 0
    je lab4668
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4668:
    ; #move variables
    mov r14, rsi
    mov r15, rdi
    mov rsi, r12
    mov rdi, r13
    ; create a3: Bool = (css, a0, cs0, acc)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4680
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4681

lab4680:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4678
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4671
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4669
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4670

lab4669:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4670:

lab4671:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4674
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4672
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4673

lab4672:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4673:

lab4674:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4677
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4675
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4676

lab4675:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4676:

lab4677:
    jmp lab4679

lab4678:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4679:

lab4681:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4693
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4694

lab4693:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4691
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4684
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4682
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4683

lab4682:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4683:

lab4684:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4687
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4685
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4686

lab4685:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4686:

lab4687:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4690
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4688
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4689

lab4688:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4689:

lab4690:
    jmp lab4692

lab4691:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4692:

lab4694:
    ; #load tag
    lea r9, [rel Bool_4695]
    ; jump not_elem_
    jmp not_elem_

Bool_4695:
    jmp near Bool_4695_True
    jmp near Bool_4695_False

Bool_4695_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4700
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4696
    ; ####increment refcount
    add qword [rax + 0], 1

lab4696:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4697
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4697:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4698
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4698:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4699
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4699:
    jmp lab4701

lab4700:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4701:
    ; substitute (a0 := a0)(cs0 := cs0);
    ; #erase acc
    cmp r10, 0
    je lab4704
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab4702
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab4703

lab4702:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab4703:

lab4704:
    ; #erase css
    cmp rax, 0
    je lab4707
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4705
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4706

lab4705:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4706:

lab4707:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; switch cs0 \{ ... \};
    lea rcx, [rel List_i64_4708]
    add rcx, rdi
    jmp rcx

List_i64_4708:
    jmp near List_i64_4708_Nil
    jmp near List_i64_4708_Cons

List_i64_4708_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4708_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4710
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4709
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4709:
    mov rdi, [rsi + 40]
    jmp lab4711

lab4710:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4711:
    ; substitute (a5 := a5)(as1 := as1)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_4695_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4716
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4712
    ; ####increment refcount
    add qword [rax + 0], 1

lab4712:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4713
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4713:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4714
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4714:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4715
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4715:
    jmp lab4717

lab4716:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4717:
    ; substitute (acc := acc)(cs0 := cs0)(a0 := a0)(css := css);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: List[i64] = (a0, css)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4729
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4730

lab4729:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4727
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4720
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4718
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4719

lab4718:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4719:

lab4720:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4723
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4721
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4722

lab4721:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4722:

lab4723:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4726
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4724
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4725

lab4724:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4725:

lab4726:
    jmp lab4728

lab4727:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4728:

lab4730:
    ; #load tag
    lea r9, [rel List_i64_4731]
    ; substitute (cs0 := cs0)(acc := acc)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump union_
    jmp union_

List_i64_4731:
    jmp near List_i64_4731_Nil
    jmp near List_i64_4731_Cons

List_i64_4731_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4734
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4732
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4732:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4733
    ; ####increment refcount
    add qword [rax + 0], 1

lab4733:
    jmp lab4735

lab4734:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab4735:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (css := css)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump combine_
    jmp combine_

List_i64_4731_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4738
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4736
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4736:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4737
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4737:
    jmp lab4739

lab4738:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4739:
    ; substitute (css := css)(a0 := a0)(a6 := a6)(as2 := as2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a6, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4751
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4752

lab4751:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4749
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4742
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4740
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4741

lab4740:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4741:

lab4742:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4745
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4743
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4744

lab4743:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4744:

lab4745:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4748
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4746
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4747

lab4746:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4747:

lab4748:
    jmp lab4750

lab4749:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4750:

lab4752:
    ; #load tag
    mov r9, 5
    ; substitute (css := css)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump combine_
    jmp combine_

ConflictSet_4631_Unknown:
    ; substitute (a0 := a0)(acc := acc);
    ; #erase css
    cmp r8, 0
    je lab4755
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab4753
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab4754

lab4753:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab4754:

lab4755:
    ; #erase s
    cmp r10, 0
    je lab4758
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab4756
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab4757

lab4756:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab4757:

lab4758:
    ; switch acc \{ ... \};
    lea rcx, [rel List_i64_4759]
    add rcx, rdi
    jmp rcx

List_i64_4759:
    jmp near List_i64_4759_Nil
    jmp near List_i64_4759_Cons

List_i64_4759_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4759_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4761
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4760
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4760:
    mov rdi, [rsi + 40]
    jmp lab4762

lab4761:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4762:
    ; substitute (a7 := a7)(as3 := as3)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bj__:
    ; substitute (a0 := a0)(t := t);
    ; #erase csp
    cmp rax, 0
    je lab4765
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4763
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4764

lab4763:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4764:

lab4765:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; create f7: Fun2[Pair[List[Assign], ConflictSet], List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_4766]
    ; substitute (f7 := f7)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bj_fold_tree_
    jmp bj_fold_tree_

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_4766:

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_4766_Apply2:
    ; substitute (a1 := a1)(chs := chs)(tp2 := tp2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch tp2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_4767:

Pair_List_Assign_ConflictSet_4767_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4770
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4768
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4768:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4769
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4769:
    jmp lab4771

lab4770:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4771:
    ; switch conf \{ ... \};
    lea rcx, [rel ConflictSet_4772]
    add rcx, r11
    jmp rcx

ConflictSet_4772:
    jmp near ConflictSet_4772_Known
    jmp near ConflictSet_4772_Unknown

ConflictSet_4772_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab4774
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab4773
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4773:
    jmp lab4775

lab4774:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab4775:
    ; let x0: ConflictSet = Known(cs);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4787
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4788

lab4787:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4785
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4778
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4776
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4777

lab4776:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4777:

lab4778:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4781
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4779
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4780

lab4779:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4780:

lab4781:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4784
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4782
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4783

lab4782:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4783:

lab4784:
    jmp lab4786

lab4785:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4786:

lab4788:
    ; #load tag
    mov r11, 0
    ; let x1: Pair[List[Assign], ConflictSet] = Tup(a, x0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4800
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4801

lab4800:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4798
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4791
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4789
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4790

lab4789:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4790:

lab4791:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4794
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4792
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4793

lab4792:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4793:

lab4794:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4797
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4795
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4796

lab4795:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4796:

lab4797:
    jmp lab4799

lab4798:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4799:

lab4801:
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(chs := chs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

ConflictSet_4772_Unknown:
    ; substitute (chs0 := chs)(chs := chs)(a := a)(a1 := a1);
    ; #share chs
    cmp rsi, 0
    je lab4802
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4802:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov rdx, rdi
    ; create a2: List[i64] = (chs, a, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4814
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4815

lab4814:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4812
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4805
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4803
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4804

lab4803:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4804:

lab4805:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4808
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4806
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4807

lab4806:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4807:

lab4808:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4811
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4809
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4810

lab4809:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4810:

lab4811:
    jmp lab4813

lab4812:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4813:

lab4815:
    ; #load tag
    lea rdi, [rel List_i64_4816]
    ; create a3: List[Pair[List[Assign], ConflictSet]] = (a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4828
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4829

lab4828:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4826
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4819
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4817
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4818

lab4817:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4818:

lab4819:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4822
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4820
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4821

lab4820:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4821:

lab4822:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4825
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4823
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4824

lab4823:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4824:

lab4825:
    jmp lab4827

lab4826:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4827:

lab4829:
    ; #load tag
    lea rdi, [rel List_Pair_List_Assign_ConflictSet_4830]
    ; create x4: Fun[Node[Pair[List[Assign], ConflictSet]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_4831]
    ; substitute (x4 := x4)(chs0 := chs0)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bj_map_
    jmp bj_map_

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_4831:

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_4831_Apply:
    ; jump bj_label_
    jmp bj_label_

List_Pair_List_Assign_ConflictSet_4830:
    jmp near List_Pair_List_Assign_ConflictSet_4830_Nil
    jmp near List_Pair_List_Assign_ConflictSet_4830_Cons

List_Pair_List_Assign_ConflictSet_4830_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4833
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4832
    ; ####increment refcount
    add qword [rax + 0], 1

lab4832:
    jmp lab4834

lab4833:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4834:
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_bj__1_
    jmp lift_bj__1_

List_Pair_List_Assign_ConflictSet_4830_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4836
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab4835
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4835:
    jmp lab4837

lab4836:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab4837:
    ; substitute (a2 := a2)(a7 := a7)(as1 := as1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Cons(a7, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4849
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4850

lab4849:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4847
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4840
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4838
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4839

lab4838:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4839:

lab4840:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4843
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4841
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4842

lab4841:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4842:

lab4843:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4846
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4844
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4845

lab4844:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4845:

lab4846:
    jmp lab4848

lab4847:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4848:

lab4850:
    ; #load tag
    mov rdi, 5
    ; jump lift_bj__1_
    jmp lift_bj__1_

List_i64_4816:
    jmp near List_i64_4816_Nil
    jmp near List_i64_4816_Cons

List_i64_4816_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4854
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab4851
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4851:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4852
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4852:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab4853
    ; ####increment refcount
    add qword [rax + 0], 1

lab4853:
    jmp lab4855

lab4854:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab4855:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a := a)(a1 := a1)(chs := chs)(x2 := x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_bj__0_
    jmp lift_bj__0_

List_i64_4816_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4859
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4856
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4856:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4857
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4857:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4858
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4858:
    jmp lab4860

lab4859:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4860:
    ; substitute (a1 := a1)(a := a)(chs := chs)(a6 := a6)(as0 := as0);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x2: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4872
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4873

lab4872:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4870
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4863
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4861
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4862

lab4861:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4862:

lab4863:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4866
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4864
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4865

lab4864:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4865:

lab4866:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4869
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4867
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4868

lab4867:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4868:

lab4869:
    jmp lab4871

lab4870:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4871:

lab4873:
    ; #load tag
    mov r11, 5
    ; substitute (a := a)(a1 := a1)(chs := chs)(x2 := x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_bj__0_
    jmp lift_bj__0_

lift_bj__1_:
    ; let x5: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x3 := x3)(x5 := x5)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump combine_
    jmp combine_

lift_bj__0_:
    ; let cs_: ConflictSet = Known(x2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4885
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4886

lab4885:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4883
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4876
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4874
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4875

lab4874:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4875:

lab4876:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4879
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4877
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4878

lab4877:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4878:

lab4879:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4882
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4880
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4881

lab4880:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4881:

lab4882:
    jmp lab4884

lab4883:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4884:

lab4886:
    ; #load tag
    mov r11, 0
    ; substitute (cs_0 := cs_)(a1 := a1)(chs := chs)(cs_ := cs_)(a := a);
    ; #share cs_
    cmp r10, 0
    je lab4887
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4887:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, r10
    mov rdx, r11
    ; create a5: Bool = (a1, chs, cs_, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4899
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4900

lab4899:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4897
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4890
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4888
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4889

lab4888:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4889:

lab4890:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4893
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4891
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4892

lab4891:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4892:

lab4893:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4896
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4894
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4895

lab4894:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4895:

lab4896:
    jmp lab4898

lab4897:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4898:

lab4900:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4912
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4913

lab4912:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4910
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4903
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4901
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4902

lab4901:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4902:

lab4903:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4906
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4904
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4905

lab4904:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4905:

lab4906:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4909
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4907
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4908

lab4907:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4908:

lab4909:
    jmp lab4911

lab4910:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4911:

lab4913:
    ; #load tag
    lea rdi, [rel Bool_4914]
    ; jump known_conflict_
    jmp known_conflict_

Bool_4914:
    jmp near Bool_4914_True
    jmp near Bool_4914_False

Bool_4914_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4919
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4915
    ; ####increment refcount
    add qword [rax + 0], 1

lab4915:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4916
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4916:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4917
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4917:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4918
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4918:
    jmp lab4920

lab4919:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4920:
    ; substitute (a1 := a1)(a := a)(cs_ := cs_);
    ; #erase chs
    cmp rsi, 0
    je lab4923
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab4921
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab4922

lab4921:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab4922:

lab4923:
    ; #move variables
    mov rsi, r10
    mov rdi, r11
    ; let x6: Pair[List[Assign], ConflictSet] = Tup(a, cs_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4935
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4936

lab4935:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4933
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4926
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4924
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4925

lab4924:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4925:

lab4926:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4929
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4927
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4928

lab4927:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4928:

lab4929:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4932
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4930
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4931

lab4930:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4931:

lab4932:
    jmp lab4934

lab4933:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4934:

lab4936:
    ; #load tag
    mov rdi, 0
    ; let x7: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x6 := x6)(x7 := x7)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_4914_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4941
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4937
    ; ####increment refcount
    add qword [rax + 0], 1

lab4937:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4938
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4938:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4939
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4939:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4940
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4940:
    jmp lab4942

lab4941:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4942:
    ; substitute (a1 := a1)(chs := chs)(a := a)(cs_ := cs_);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; let x8: Pair[List[Assign], ConflictSet] = Tup(a, cs_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4954
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4955

lab4954:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4952
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4945
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4943
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4944

lab4943:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4944:

lab4945:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4948
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4946
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4947

lab4946:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4947:

lab4948:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4951
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4949
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4950

lab4949:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4950:

lab4951:
    jmp lab4953

lab4952:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4953:

lab4955:
    ; #load tag
    mov r9, 0
    ; substitute (x8 := x8)(chs := chs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bj_label_:
    ; substitute (a0 := a0)(n := n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_4956:

Node_Pair_List_Assign_ConflictSet_4956_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4959
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4957
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4957:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab4958
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4958:
    jmp lab4960

lab4959:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab4960:
    ; substitute (a0 := a0)(l := l);
    ; #erase cs
    cmp r8, 0
    je lab4963
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab4961
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab4962

lab4961:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab4962:

lab4963:
    ; switch l \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_4964:

Pair_List_Assign_ConflictSet_4964_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4967
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4965
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4965:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab4966
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4966:
    jmp lab4968

lab4967:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab4968:
    ; substitute (a1 := a1)(b0 := b0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

bj_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_4969]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_4969:
    jmp near List_Node_Pair_List_Assign_ConflictSet_4969_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_4969_Cons

List_Node_Pair_List_Assign_ConflictSet_4969_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab4972
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4970
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4971

lab4970:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4971:

lab4972:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_4969_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4975
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4973
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4973:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4974
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4974:
    jmp lab4976

lab4975:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4976:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab4977
    ; ####increment refcount
    add qword [rax + 0], 1

lab4977:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[List[Assign], ConflictSet] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4989
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4990

lab4989:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4987
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4980
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4978
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4979

lab4978:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4979:

lab4980:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4983
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4981
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4982

lab4981:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4982:

lab4983:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4986
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4984
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4985

lab4984:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4985:

lab4986:
    jmp lab4988

lab4987:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4988:

lab4990:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_4991]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_List_Assign_ConflictSet_4991:

Pair_List_Assign_ConflictSet_4991_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4995
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4992
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4992:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4993
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4993:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4994
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4994:
    jmp lab4996

lab4995:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4996:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a4 := a4)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a4, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5008
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5009

lab5008:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5006
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4999
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4997
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4998

lab4997:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4998:

lab4999:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5002
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5000
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5001

lab5000:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5001:

lab5002:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5005
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5003
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5004

lab5003:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5004:

lab5005:
    jmp lab5007

lab5006:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5007:

lab5009:
    ; #load tag
    mov r11, 0
    ; create a2: List[Pair[List[Assign], ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5021
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5022

lab5021:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5019
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5012
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5010
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5011

lab5010:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5011:

lab5012:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5015
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5013
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5014

lab5013:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5014:

lab5015:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5018
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5016
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5017

lab5016:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5017:

lab5018:
    jmp lab5020

lab5019:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5020:

lab5022:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_5023]
    ; jump bj_map_
    jmp bj_map_

List_Pair_List_Assign_ConflictSet_5023:
    jmp near List_Pair_List_Assign_ConflictSet_5023_Nil
    jmp near List_Pair_List_Assign_ConflictSet_5023_Cons

List_Pair_List_Assign_ConflictSet_5023_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5026
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5024
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5024:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5025
    ; ####increment refcount
    add qword [rax + 0], 1

lab5025:
    jmp lab5027

lab5026:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5027:
    ; let x1: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_5023_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5030
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5028
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5028:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5029
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5029:
    jmp lab5031

lab5030:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5031:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Pair[List[Assign], ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5043
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5044

lab5043:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5041
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5034
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5032
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5033

lab5032:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5033:

lab5034:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5037
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5035
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5036

lab5035:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5036:

lab5037:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5040
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5038
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5039

lab5038:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5039:

lab5040:
    jmp lab5042

lab5041:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5042:

lab5044:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bj_map2_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_5045]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_5045:
    jmp near List_Node_Pair_List_Assign_ConflictSet_5045_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_5045_Cons

List_Node_Pair_List_Assign_ConflictSet_5045_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab5048
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab5046
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab5047

lab5046:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab5047:

lab5048:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_5045_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5051
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5049
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5049:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5050
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5050:
    jmp lab5052

lab5051:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5052:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab5053
    ; ####increment refcount
    add qword [rax + 0], 1

lab5053:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5065
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5066

lab5065:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5063
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5056
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5054
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5055

lab5054:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5055:

lab5056:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5059
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5057
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5058

lab5057:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5058:

lab5059:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5062
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5060
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5061

lab5060:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5061:

lab5062:
    jmp lab5064

lab5063:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5064:

lab5066:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_5067]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_5067:

Node_Pair_List_Assign_ConflictSet_5067_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5071
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5068
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5068:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5069
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5069:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5070
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5070:
    jmp lab5072

lab5071:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5072:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5084
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5085

lab5084:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5082
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5075
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5073
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5074

lab5073:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5074:

lab5075:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5078
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5076
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5077

lab5076:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5077:

lab5078:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5081
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5079
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5080

lab5079:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5080:

lab5081:
    jmp lab5083

lab5082:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5083:

lab5085:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5097
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5098

lab5097:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5095
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5088
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5086
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5087

lab5086:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5087:

lab5088:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5091
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5089
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5090

lab5089:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5090:

lab5091:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5094
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5092
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5093

lab5092:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5093:

lab5094:
    jmp lab5096

lab5095:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5096:

lab5098:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_5099]
    ; jump bj_map2_
    jmp bj_map2_

List_Node_Pair_List_Assign_ConflictSet_5099:
    jmp near List_Node_Pair_List_Assign_ConflictSet_5099_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_5099_Cons

List_Node_Pair_List_Assign_ConflictSet_5099_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5102
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5100
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5100:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5101
    ; ####increment refcount
    add qword [rax + 0], 1

lab5101:
    jmp lab5103

lab5102:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5103:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_5099_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5106
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5104
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5104:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5105
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5105:
    jmp lab5107

lab5106:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5107:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5119
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5120

lab5119:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5117
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5110
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5108
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5109

lab5108:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5109:

lab5110:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5113
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5111
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5112

lab5111:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5112:

lab5113:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5116
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5114
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5115

lab5114:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5115:

lab5116:
    jmp lab5118

lab5117:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5118:

lab5120:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bj_fold_tree_:
    ; substitute (f := f)(a0 := a0)(t := t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_5121:

Node_Pair_List_Assign_ConflictSet_5121_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5124
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5122
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5122:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5123
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5123:
    jmp lab5125

lab5124:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5125:
    ; substitute (f0 := f)(c := c)(l := l)(a0 := a0)(f := f);
    ; #share f
    cmp rax, 0
    je lab5126
    ; ####increment refcount
    add qword [rax + 0], 1

lab5126:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a1: List[Node[Pair[List[Assign], ConflictSet]]] = (l, a0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5138
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5139

lab5138:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5136
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5128

lab5127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5128:

lab5129:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5131

lab5130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5131:

lab5132:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5135
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5133
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5134

lab5133:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5134:

lab5135:
    jmp lab5137

lab5136:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5137:

lab5139:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_5140]
    ; substitute (a1 := a1)(c := c)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x1: Fun[Node[Pair[List[Assign], ConflictSet]], Node[Pair[List[Assign], ConflictSet]]] = (f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5152
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5153

lab5152:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5150
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5143
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5141
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5142

lab5141:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5142:

lab5143:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5146
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5144
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5145

lab5144:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5145:

lab5146:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5149
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5147
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5148

lab5147:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5148:

lab5149:
    jmp lab5151

lab5150:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5151:

lab5153:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5154]
    ; substitute (x1 := x1)(c := c)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bj_map2_
    jmp bj_map2_

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5154:

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5154_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5156
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5155
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5155:
    jmp lab5157

lab5156:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5157:
    ; substitute (f0 := f0)(x := x)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bj_fold_tree_
    jmp bj_fold_tree_

List_Node_Pair_List_Assign_ConflictSet_5140:
    jmp near List_Node_Pair_List_Assign_ConflictSet_5140_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_5140_Cons

List_Node_Pair_List_Assign_ConflictSet_5140_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5161
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5158
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5158:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5159
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5159:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5160
    ; ####increment refcount
    add qword [rax + 0], 1

lab5160:
    jmp lab5162

lab5161:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5162:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (l := l)(x0 := x0)(a0 := a0)(f := f);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

List_Node_Pair_List_Assign_ConflictSet_5140_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5166
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5163
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5163:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5164
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5164:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5165
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5165:
    jmp lab5167

lab5166:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5167:
    ; substitute (f := f)(a0 := a0)(l := l)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5179
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5180

lab5179:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5177
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5170
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5168
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5169

lab5168:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5169:

lab5170:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5173
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5171
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5172

lab5171:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5172:

lab5173:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5176
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5174
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5175

lab5174:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5175:

lab5176:
    jmp lab5178

lab5177:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5178:

lab5180:
    ; #load tag
    mov r11, 5
    ; substitute (l := l)(x0 := x0)(a0 := a0)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke f Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

bj_:
    ; substitute (a0 := a0)(t := t);
    ; #erase csp
    cmp rax, 0
    je lab5183
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab5181
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab5182

lab5181:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab5182:

lab5183:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; create f6: Fun2[Pair[List[Assign], ConflictSet], List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5184]
    ; substitute (f6 := f6)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bj_fold_tree_
    jmp bj_fold_tree_

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5184:

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5184_Apply2:
    ; substitute (a1 := a1)(chs := chs)(tp2 := tp2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch tp2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_5185:

Pair_List_Assign_ConflictSet_5185_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5188
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5186
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5186:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5187
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5187:
    jmp lab5189

lab5188:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5189:
    ; switch conf \{ ... \};
    lea rcx, [rel ConflictSet_5190]
    add rcx, r11
    jmp rcx

ConflictSet_5190:
    jmp near ConflictSet_5190_Known
    jmp near ConflictSet_5190_Unknown

ConflictSet_5190_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab5192
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab5191
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5191:
    jmp lab5193

lab5192:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab5193:
    ; let x0: ConflictSet = Known(cs);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5205
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5206

lab5205:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5203
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5196
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5194
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5195

lab5194:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5195:

lab5196:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5199
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5197
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5198

lab5197:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5198:

lab5199:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5202
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5200
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5201

lab5200:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5201:

lab5202:
    jmp lab5204

lab5203:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5204:

lab5206:
    ; #load tag
    mov r11, 0
    ; let x1: Pair[List[Assign], ConflictSet] = Tup(a, x0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5218
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5219

lab5218:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5216
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5209
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5207
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5208

lab5207:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5208:

lab5209:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5212
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5210
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5211

lab5210:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5211:

lab5212:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5215
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5213
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5214

lab5213:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5214:

lab5215:
    jmp lab5217

lab5216:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5217:

lab5219:
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(chs := chs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

ConflictSet_5190_Unknown:
    ; substitute (chs0 := chs)(chs := chs)(a := a)(a1 := a1);
    ; #share chs
    cmp rsi, 0
    je lab5220
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5220:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov rdx, rdi
    ; create a2: List[i64] = (chs, a, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5232
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5233

lab5232:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5230
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5223
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5221
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5222

lab5221:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5222:

lab5223:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5226
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5224
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5225

lab5224:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5225:

lab5226:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5229
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5227
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5228

lab5227:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5228:

lab5229:
    jmp lab5231

lab5230:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5231:

lab5233:
    ; #load tag
    lea rdi, [rel List_i64_5234]
    ; create a3: List[Pair[List[Assign], ConflictSet]] = (a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5246
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5247

lab5246:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5244
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5237
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5235
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5236

lab5235:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5236:

lab5237:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5239

lab5238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5239:

lab5240:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5242

lab5241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5242:

lab5243:
    jmp lab5245

lab5244:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5245:

lab5247:
    ; #load tag
    lea rdi, [rel List_Pair_List_Assign_ConflictSet_5248]
    ; create x4: Fun[Node[Pair[List[Assign], ConflictSet]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_5249]
    ; substitute (x4 := x4)(chs0 := chs0)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bj_map_
    jmp bj_map_

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_5249:

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_5249_Apply:
    ; jump bj_label_
    jmp bj_label_

List_Pair_List_Assign_ConflictSet_5248:
    jmp near List_Pair_List_Assign_ConflictSet_5248_Nil
    jmp near List_Pair_List_Assign_ConflictSet_5248_Cons

List_Pair_List_Assign_ConflictSet_5248_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5251
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab5250
    ; ####increment refcount
    add qword [rax + 0], 1

lab5250:
    jmp lab5252

lab5251:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab5252:
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_bj_1_
    jmp lift_bj_1_

List_Pair_List_Assign_ConflictSet_5248_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5254
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5253
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5253:
    jmp lab5255

lab5254:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5255:
    ; substitute (a2 := a2)(a6 := a6)(as1 := as1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Cons(a6, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5267
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5268

lab5267:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5265
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5258
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5256
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5257

lab5256:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5257:

lab5258:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5261
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5259
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5260

lab5259:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5260:

lab5261:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5264
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5262
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5263

lab5262:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5263:

lab5264:
    jmp lab5266

lab5265:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5266:

lab5268:
    ; #load tag
    mov rdi, 5
    ; jump lift_bj_1_
    jmp lift_bj_1_

List_i64_5234:
    jmp near List_i64_5234_Nil
    jmp near List_i64_5234_Cons

List_i64_5234_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5272
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5269
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5269:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5270
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5270:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5271
    ; ####increment refcount
    add qword [rax + 0], 1

lab5271:
    jmp lab5273

lab5272:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5273:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a := a)(a1 := a1)(chs := chs)(x2 := x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_bj_0_
    jmp lift_bj_0_

List_i64_5234_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5277
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5274
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5274:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5275
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5275:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5276
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5276:
    jmp lab5278

lab5277:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5278:
    ; substitute (a1 := a1)(a := a)(chs := chs)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x2: List[i64] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5290
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5291

lab5290:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5288
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5281
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5279
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5280

lab5279:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5280:

lab5281:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5284
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5282
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5283

lab5282:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5283:

lab5284:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5287
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5285
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5286

lab5285:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5286:

lab5287:
    jmp lab5289

lab5288:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5289:

lab5291:
    ; #load tag
    mov r11, 5
    ; substitute (a := a)(a1 := a1)(chs := chs)(x2 := x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_bj_0_
    jmp lift_bj_0_

lift_bj_1_:
    ; let x5: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x3 := x3)(x5 := x5)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump combine_
    jmp combine_

lift_bj_0_:
    ; let x6: ConflictSet = Known(x2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5303
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5304

lab5303:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5301
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5294
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5292
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5293

lab5292:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5293:

lab5294:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5297
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5295
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5296

lab5295:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5296:

lab5297:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5300
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5298
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5299

lab5298:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5299:

lab5300:
    jmp lab5302

lab5301:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5302:

lab5304:
    ; #load tag
    mov r11, 0
    ; substitute (chs := chs)(a1 := a1)(a := a)(x6 := x6);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x7: Pair[List[Assign], ConflictSet] = Tup(a, x6);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5316
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5317

lab5316:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5314
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5307
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5305
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5306

lab5305:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5306:

lab5307:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5310
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5308
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5309

lab5308:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5309:

lab5310:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5313
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5311
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5312

lab5311:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5312:

lab5313:
    jmp lab5315

lab5314:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5315:

lab5317:
    ; #load tag
    mov r9, 0
    ; substitute (x7 := x7)(chs := chs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bjbt_:
    ; substitute (csp0 := csp)(t := t)(a0 := a0)(csp := csp);
    ; #share csp
    cmp rax, 0
    je lab5318
    ; ####increment refcount
    add qword [rax + 0], 1

lab5318:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5330
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5331

lab5330:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5328
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5321
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5319
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5320

lab5319:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5320:

lab5321:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5324
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5322
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5323

lab5322:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5323:

lab5324:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5327
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5325
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5326

lab5325:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5326:

lab5327:
    jmp lab5329

lab5328:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5329:

lab5331:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_5332]
    ; jump bt_
    jmp bt_

Node_Pair_List_Assign_ConflictSet_5332:

Node_Pair_List_Assign_ConflictSet_5332_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5335
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5333
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5333:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5334
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5334:
    jmp lab5336

lab5335:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5336:
    ; substitute (csp := csp)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5348
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5349

lab5348:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5346
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5339
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5337
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5338

lab5337:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5338:

lab5339:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5342
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5340
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5341

lab5340:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5341:

lab5342:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5345
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5343
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5344

lab5343:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5344:

lab5345:
    jmp lab5347

lab5346:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5347:

lab5349:
    ; #load tag
    mov r9, 0
    ; substitute (csp := csp)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump bj_
    jmp bj_

bjbt__:
    ; substitute (csp0 := csp)(t := t)(a0 := a0)(csp := csp);
    ; #share csp
    cmp rax, 0
    je lab5350
    ; ####increment refcount
    add qword [rax + 0], 1

lab5350:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5362
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5363

lab5362:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5360
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5353
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5351
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5352

lab5351:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5352:

lab5353:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5356
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5354
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5355

lab5354:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5355:

lab5356:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5359
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5357
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5358

lab5357:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5358:

lab5359:
    jmp lab5361

lab5360:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5361:

lab5363:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_5364]
    ; jump bt_
    jmp bt_

Node_Pair_List_Assign_ConflictSet_5364:

Node_Pair_List_Assign_ConflictSet_5364_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5367
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5365
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5365:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5366
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5366:
    jmp lab5368

lab5367:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5368:
    ; substitute (csp := csp)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5380
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5381

lab5380:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5378
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5371
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5369
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5370

lab5369:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5370:

lab5371:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5374
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5372
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5373

lab5372:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5373:

lab5374:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5377
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5375
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5376

lab5375:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5376:

lab5377:
    jmp lab5379

lab5378:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5379:

lab5381:
    ; #load tag
    mov r9, 0
    ; substitute (csp := csp)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump bj__
    jmp bj__

collect_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_ConflictSet_5382]
    add rcx, rdi
    jmp rcx

List_ConflictSet_5382:
    jmp near List_ConflictSet_5382_Nil
    jmp near List_ConflictSet_5382_Cons

List_ConflictSet_5382_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_5382_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5385
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5383
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5383:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5384
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5384:
    jmp lab5386

lab5385:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5386:
    ; substitute (a0 := a0)(css := css)(conf := conf);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch conf \{ ... \};
    lea rcx, [rel ConflictSet_5387]
    add rcx, r9
    jmp rcx

ConflictSet_5387:
    jmp near ConflictSet_5387_Known
    jmp near ConflictSet_5387_Unknown

ConflictSet_5387_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5389
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5388
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5388:
    jmp lab5390

lab5389:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5390:
    ; substitute (css := css)(a0 := a0)(cs := cs);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: List[i64] = (a0, cs)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5402
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5403

lab5402:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5400
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5392

lab5391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5392:

lab5393:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5396
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5394
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5395

lab5394:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5395:

lab5396:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5399
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5397
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5398

lab5397:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5398:

lab5399:
    jmp lab5401

lab5400:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5401:

lab5403:
    ; #load tag
    lea rdi, [rel List_i64_5404]
    ; jump collect_
    jmp collect_

List_i64_5404:
    jmp near List_i64_5404_Nil
    jmp near List_i64_5404_Cons

List_i64_5404_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5407
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5405
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5405:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5406
    ; ####increment refcount
    add qword [rax + 0], 1

lab5406:
    jmp lab5408

lab5407:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5408:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (cs := cs)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump union_
    jmp union_

List_i64_5404_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5411
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5409
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5409:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5410
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5410:
    jmp lab5412

lab5411:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5412:
    ; substitute (cs := cs)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5424
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5425

lab5424:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5422
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5415
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5413
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5414

lab5413:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5414:

lab5415:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5418
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5416
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5417

lab5416:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5417:

lab5418:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5421
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5419
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5420

lab5419:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5420:

lab5421:
    jmp lab5423

lab5422:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5423:

lab5425:
    ; #load tag
    mov r9, 5
    ; substitute (cs := cs)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump union_
    jmp union_

ConflictSet_5387_Unknown:
    ; substitute (a0 := a0);
    ; #erase css
    cmp rsi, 0
    je lab5428
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5426
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5427

lab5426:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5427:

lab5428:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

wipe_all_:
    ; substitute (f := f)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_ConflictSet_5429]
    add rcx, r9
    jmp rcx

List_ConflictSet_5429:
    jmp near List_ConflictSet_5429_Nil
    jmp near List_ConflictSet_5429_Cons

List_ConflictSet_5429_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab5432
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab5430
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab5431

lab5430:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab5431:

lab5432:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_ConflictSet_5429_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5435
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5433
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5433:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5434
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5434:
    jmp lab5436

lab5435:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5436:
    ; substitute (f0 := f)(c := c)(a0 := a0)(cs := cs)(f := f);
    ; #share f
    cmp rax, 0
    je lab5437
    ; ####increment refcount
    add qword [rax + 0], 1

lab5437:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Bool = (a0, cs, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5449
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5450

lab5449:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5447
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5440
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5438
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5439

lab5438:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5439:

lab5440:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5443
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5441
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5442

lab5441:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5442:

lab5443:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5446
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5444
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5445

lab5444:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5445:

lab5446:
    jmp lab5448

lab5447:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5448:

lab5450:
    ; #load tag
    lea r9, [rel Bool_5451]
    ; substitute (c := c)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_5451:
    jmp near Bool_5451_True
    jmp near Bool_5451_False

Bool_5451_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5455
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5452
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5452:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5453
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5453:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5454
    ; ####increment refcount
    add qword [rax + 0], 1

lab5454:
    jmp lab5456

lab5455:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5456:
    ; substitute (f := f)(cs := cs)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump wipe_all_
    jmp wipe_all_

Bool_5451_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5460
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5457
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5457:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5458
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5458:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5459
    ; ####increment refcount
    add qword [rax + 0], 1

lab5459:
    jmp lab5461

lab5460:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5461:
    ; substitute (a0 := a0);
    ; #erase cs
    cmp rsi, 0
    je lab5464
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5462
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5463

lab5462:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5463:

lab5464:
    ; #erase f
    cmp r8, 0
    je lab5467
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab5465
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab5466

lab5465:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab5466:

lab5467:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

filter_known_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_5468]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_5468:
    jmp near List_List_ConflictSet_5468_Nil
    jmp near List_List_ConflictSet_5468_Cons

List_List_ConflictSet_5468_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_5468_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5471
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5469
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5469:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5470
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5470:
    jmp lab5472

lab5471:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5472:
    ; create x0: Fun[ConflictSet, Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_ConflictSet_Bool_5473]
    ; substitute (x0 := x0)(vs0 := vs)(t1 := t1)(vs := vs)(a0 := a0);
    ; #share vs
    cmp rsi, 0
    je lab5474
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5474:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, r10
    mov r10, rsi
    mov rdx, r11
    mov r11, rdi
    ; create a3: Bool = (t1, vs, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5486
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5487

lab5486:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5484
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5477
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5475
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5476

lab5475:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5476:

lab5477:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5480
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5478
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5479

lab5478:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5479:

lab5480:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5483
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5481
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5482

lab5481:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5482:

lab5483:
    jmp lab5485

lab5484:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5485:

lab5487:
    ; #load tag
    lea r9, [rel Bool_5488]
    ; jump wipe_all_
    jmp wipe_all_

Bool_5488:
    jmp near Bool_5488_True
    jmp near Bool_5488_False

Bool_5488_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5492
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5489
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5489:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5490
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5490:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5491
    ; ####increment refcount
    add qword [rax + 0], 1

lab5491:
    jmp lab5493

lab5492:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5493:
    ; create a1: List[List[ConflictSet]] = (vs, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5505
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5506

lab5505:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5503
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5496
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5494
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5495

lab5494:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5495:

lab5496:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5499
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5497
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5498

lab5497:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5498:

lab5499:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5502
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5500
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5501

lab5500:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5501:

lab5502:
    jmp lab5504

lab5503:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5504:

lab5506:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_5507]
    ; jump filter_known_
    jmp filter_known_

List_List_ConflictSet_5507:
    jmp near List_List_ConflictSet_5507_Nil
    jmp near List_List_ConflictSet_5507_Cons

List_List_ConflictSet_5507_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5510
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5508
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5508:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5509
    ; ####increment refcount
    add qword [rax + 0], 1

lab5509:
    jmp lab5511

lab5510:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5511:
    ; let x1: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (vs := vs)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_5507_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5514
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5512
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5512:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5513
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5513:
    jmp lab5515

lab5514:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5515:
    ; substitute (a0 := a0)(vs := vs)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5527
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5528

lab5527:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5525
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5518
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5516
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5517

lab5516:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5517:

lab5518:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5521
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5519
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5520

lab5519:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5520:

lab5521:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5524
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5522
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5523

lab5522:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5523:

lab5524:
    jmp lab5526

lab5525:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5526:

lab5528:
    ; #load tag
    mov r9, 5
    ; substitute (vs := vs)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_5488_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5532
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5529
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5529:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5530
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5530:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5531
    ; ####increment refcount
    add qword [rax + 0], 1

lab5531:
    jmp lab5533

lab5532:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5533:
    ; substitute (t1 := t1)(a0 := a0);
    ; #erase vs
    cmp rsi, 0
    je lab5536
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5534
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5535

lab5534:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5535:

lab5536:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; jump filter_known_
    jmp filter_known_

Fun_ConflictSet_Bool_5473:

Fun_ConflictSet_Bool_5473_Apply:
    ; jump known_conflict_
    jmp known_conflict_

wipe_null__:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_5537]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_5537:
    jmp near List_List_ConflictSet_5537_Nil
    jmp near List_List_ConflictSet_5537_Cons

List_List_ConflictSet_5537_Nil:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_List_ConflictSet_5537_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5540
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5538
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5538:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5539
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5539:
    jmp lab5541

lab5540:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5541:
    ; substitute (a0 := a0);
    ; #erase l
    cmp rsi, 0
    je lab5544
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5542
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5543

lab5542:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5543:

lab5544:
    ; #erase ls0
    cmp r8, 0
    je lab5547
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab5545
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab5546

lab5545:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab5546:

lab5547:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

wipe_head_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_5548]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_5548:
    jmp near List_List_ConflictSet_5548_Nil
    jmp near List_List_ConflictSet_5548_Cons

List_List_ConflictSet_5548_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_5548_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5551
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5549
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5549:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5550
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5550:
    jmp lab5552

lab5551:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5552:
    ; substitute (a0 := a0)(l := l);
    ; #erase ls0
    cmp r8, 0
    je lab5555
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab5553
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab5554

lab5553:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab5554:

lab5555:
    ; switch l \{ ... \};
    lea rcx, [rel List_ConflictSet_5556]
    add rcx, rdi
    jmp rcx

List_ConflictSet_5556:
    jmp near List_ConflictSet_5556_Nil
    jmp near List_ConflictSet_5556_Cons

List_ConflictSet_5556_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_5556_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5559
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5557
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5557:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5558
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5558:
    jmp lab5560

lab5559:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5560:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

wipe_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5561]
    add rcx, r9
    jmp rcx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5561:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5561_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5561_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5561_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab5564
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab5562
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab5563

lab5562:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab5563:

lab5564:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5561_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5567
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5565
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5565:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5566
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5566:
    jmp lab5568

lab5567:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5568:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab5569
    ; ####increment refcount
    add qword [rax + 0], 1

lab5569:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5581
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5582

lab5581:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5579
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5572
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5570
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5571

lab5570:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5571:

lab5572:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5575
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5573
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5574

lab5573:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5574:

lab5575:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5578
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5576
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5577

lab5576:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5577:

lab5578:
    jmp lab5580

lab5579:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5580:

lab5582:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_5583]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_5583:

Node_Pair_List_Assign_ConflictSet_5583_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5587
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5584
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5584:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5585
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5585:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5586
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5586:
    jmp lab5588

lab5587:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5588:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5600
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5601

lab5600:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5598
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5591
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5589
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5590

lab5589:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5590:

lab5591:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5594
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5592
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5593

lab5592:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5593:

lab5594:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5597
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5595
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5596

lab5595:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5596:

lab5597:
    jmp lab5599

lab5598:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5599:

lab5601:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5613
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5614

lab5613:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5611
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5604
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5602
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5603

lab5602:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5603:

lab5604:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5607
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5605
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5606

lab5605:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5606:

lab5607:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5610
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5608
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5609

lab5608:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5609:

lab5610:
    jmp lab5612

lab5611:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5612:

lab5614:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_5615]
    ; jump wipe_map_
    jmp wipe_map_

List_Node_Pair_List_Assign_ConflictSet_5615:
    jmp near List_Node_Pair_List_Assign_ConflictSet_5615_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_5615_Cons

List_Node_Pair_List_Assign_ConflictSet_5615_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5618
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5616
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5616:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5617
    ; ####increment refcount
    add qword [rax + 0], 1

lab5617:
    jmp lab5619

lab5618:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5619:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_5615_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5622
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5620
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5620:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5621
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5621:
    jmp lab5623

lab5622:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5623:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5635
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5636

lab5635:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5633
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5626
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5624
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5625

lab5624:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5625:

lab5626:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5629
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5627
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5628

lab5627:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5628:

lab5629:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5632
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5630
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5631

lab5630:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5631:

lab5632:
    jmp lab5634

lab5633:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5634:

lab5636:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

wipe_map_tree_:
    ; substitute (f := f)(a0 := a0)(t := t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5637:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5637_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5640
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5638
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5638:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5639
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5639:
    jmp lab5641

lab5640:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5641:
    ; substitute (f0 := f)(l := l)(a0 := a0)(c := c)(f := f);
    ; #share f
    cmp rax, 0
    je lab5642
    ; ####increment refcount
    add qword [rax + 0], 1

lab5642:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[List[Assign], ConflictSet] = (a0, c, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5654
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5655

lab5654:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5652
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5645
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5643
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5644

lab5643:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5644:

lab5645:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5648
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5646
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5647

lab5646:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5647:

lab5648:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5651
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5649
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5650

lab5649:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5650:

lab5651:
    jmp lab5653

lab5652:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5653:

lab5655:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_5656]
    ; substitute (l := l)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_List_Assign_ConflictSet_5656:

Pair_List_Assign_ConflictSet_5656_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5660
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5657
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5657:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5658
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5658:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5659
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5659:
    jmp lab5661

lab5660:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5661:
    ; substitute (f := f)(c := c)(a0 := a0)(a5 := a5)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5673
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5674

lab5673:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5671
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5664
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5662
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5663

lab5662:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5663:

lab5664:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5667
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5665
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5666

lab5665:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5666:

lab5667:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5670
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5668
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5669

lab5668:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5669:

lab5670:
    jmp lab5672

lab5671:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5672:

lab5674:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5686
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5687

lab5686:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5684
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5677
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5675
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5676

lab5675:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5676:

lab5677:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5680
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5678
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5679

lab5678:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5679:

lab5680:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5683
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5681
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5682

lab5681:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5682:

lab5683:
    jmp lab5685

lab5684:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5685:

lab5687:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_5688]
    ; substitute (a2 := a2)(c := c)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x2: Fun[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]], Node[Pair[List[Assign], ConflictSet]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5700
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5701

lab5700:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5698
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5691
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5689
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5690

lab5689:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5690:

lab5691:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5694
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5692
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5693

lab5692:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5693:

lab5694:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5697
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5695
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5696

lab5695:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5696:

lab5697:
    jmp lab5699

lab5698:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5699:

lab5701:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_5702]
    ; substitute (x2 := x2)(c := c)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump wipe_map_
    jmp wipe_map_

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_5702:

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_5702_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5704
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5703
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5703:
    jmp lab5705

lab5704:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5705:
    ; substitute (f := f)(x := x)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump wipe_map_tree_
    jmp wipe_map_tree_

List_Node_Pair_List_Assign_ConflictSet_5688:
    jmp near List_Node_Pair_List_Assign_ConflictSet_5688_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_5688_Cons

List_Node_Pair_List_Assign_ConflictSet_5688_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5708
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5706
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5706:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5707
    ; ####increment refcount
    add qword [rax + 0], 1

lab5707:
    jmp lab5709

lab5708:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5709:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_5688_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5712
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5710
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5710:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5711
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5711:
    jmp lab5713

lab5712:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5713:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5725
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5726

lab5725:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5723
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5716
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5714
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5715

lab5714:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5715:

lab5716:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5719
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5717
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5718

lab5717:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5718:

lab5719:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5722
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5720
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5721

lab5720:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5721:

lab5722:
    jmp lab5724

lab5723:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5724:

lab5726:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

domain_wipeout_:
    ; substitute (a0 := a0)(t := t)(csp := csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_5727:

CSP_5727_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5729
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5728
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5728:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab5730

lab5729:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab5730:
    ; substitute (a0 := a0)(t := t);
    ; #erase rel
    cmp r12, 0
    je lab5733
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab5731
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab5732

lab5731:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab5732:

lab5733:
    ; create f8: Fun[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_5734]
    ; substitute (f8 := f8)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump wipe_map_tree_
    jmp wipe_map_tree_

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_5734:

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_5734_Apply:
    ; substitute (a1 := a1)(tp2 := tp2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch tp2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5735:

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5735_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5738
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5736
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5736:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5737
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5737:
    jmp lab5739

lab5738:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5739:
    ; substitute (a1 := a1)(tbl := tbl)(p := p);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_5740:

Pair_List_Assign_ConflictSet_5740_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5743
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5741
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5741:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5742
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5742:
    jmp lab5744

lab5743:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5744:
    ; substitute (tbl := tbl)(a1 := a1)(as_ := as_)(cs := cs);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a4: List[List[ConflictSet]] = (a1, as_, cs)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5756
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5757

lab5756:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5754
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5747
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5745
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5746

lab5745:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5746:

lab5747:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5750
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5748
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5749

lab5748:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5749:

lab5750:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5753
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5751
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5752

lab5751:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5752:

lab5753:
    jmp lab5755

lab5754:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5755:

lab5757:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_5758]
    ; jump filter_known_
    jmp filter_known_

List_List_ConflictSet_5758:
    jmp near List_List_ConflictSet_5758_Nil
    jmp near List_List_ConflictSet_5758_Cons

List_List_ConflictSet_5758_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5762
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5759
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5759:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5760
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5760:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5761
    ; ####increment refcount
    add qword [rax + 0], 1

lab5761:
    jmp lab5763

lab5762:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5763:
    ; let wiped_domains: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; jump lift_domain_wipeout_0_
    jmp lift_domain_wipeout_0_

List_List_ConflictSet_5758_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5767
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5764
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5764:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5765
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5765:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5766
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5766:
    jmp lab5768

lab5767:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5768:
    ; substitute (cs := cs)(as_ := as_)(a1 := a1)(a8 := a8)(as2 := as2);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let wiped_domains: List[List[ConflictSet]] = Cons(a8, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5780
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5781

lab5780:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5778
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5771
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5769
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5770

lab5769:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5770:

lab5771:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5774
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5772
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5773

lab5772:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5773:

lab5774:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5777
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5775
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5776

lab5775:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5776:

lab5777:
    jmp lab5779

lab5778:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5779:

lab5781:
    ; #load tag
    mov r11, 5
    ; substitute (a1 := a1)(as_ := as_)(cs := cs)(wiped_domains := wiped_domains);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_domain_wipeout_0_
    jmp lift_domain_wipeout_0_

lift_domain_wipeout_0_:
    ; substitute (wiped_domains0 := wiped_domains)(as_ := as_)(cs := cs)(wiped_domains := wiped_domains)(a1 := a1);
    ; #share wiped_domains
    cmp r10, 0
    je lab5782
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5782:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, r10
    mov rdx, r11
    ; create a5: Bool = (as_, cs, wiped_domains, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5794
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5795

lab5794:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5792
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5785
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5783
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5784

lab5783:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5784:

lab5785:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5788
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5786
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5787

lab5786:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5787:

lab5788:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5791
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5789
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5790

lab5789:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5790:

lab5791:
    jmp lab5793

lab5792:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5793:

lab5795:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5807
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5808

lab5807:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5805
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5798
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5796
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5797

lab5796:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5797:

lab5798:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5801
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5799
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5800

lab5799:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5800:

lab5801:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5804
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5802
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5803

lab5802:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5803:

lab5804:
    jmp lab5806

lab5805:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5806:

lab5808:
    ; #load tag
    lea rdi, [rel Bool_5809]
    ; jump wipe_null__
    jmp wipe_null__

Bool_5809:
    jmp near Bool_5809_True
    jmp near Bool_5809_False

Bool_5809_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5814
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5810
    ; ####increment refcount
    add qword [rax + 0], 1

lab5810:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab5811
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5811:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab5812
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5812:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab5813
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5813:
    jmp lab5815

lab5814:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab5815:
    ; substitute (a1 := a1)(as_ := as_)(cs := cs);
    ; #erase wiped_domains
    cmp r8, 0
    je lab5818
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab5816
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab5817

lab5816:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab5817:

lab5818:
    ; #move variables
    mov r8, rsi
    mov rsi, rax
    mov r9, rdi
    mov rdi, rdx
    mov rax, r10
    mov rdx, r11
    ; jump share_domain_wipeout_0_
    jmp share_domain_wipeout_0_

Bool_5809_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5823
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5819
    ; ####increment refcount
    add qword [rax + 0], 1

lab5819:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab5820
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5820:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab5821
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5821:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab5822
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5822:
    jmp lab5824

lab5823:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab5824:
    ; substitute (wiped_domains := wiped_domains)(as_ := as_)(a1 := a1);
    ; #erase cs
    cmp rsi, 0
    je lab5827
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5825
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5826

lab5825:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5826:

lab5827:
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; create a2: List[i64] = (as_, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5839
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5840

lab5839:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5837
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5830
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5828
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5829

lab5828:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5829:

lab5830:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5833
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5831
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5832

lab5831:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5832:

lab5833:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5835

lab5834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5835:

lab5836:
    jmp lab5838

lab5837:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5838:

lab5840:
    ; #load tag
    lea rdi, [rel List_i64_5841]
    ; create a3: List[ConflictSet] = (a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5853
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5854

lab5853:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5851
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5844
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5842
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5843

lab5842:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5843:

lab5844:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5847
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5845
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5846

lab5845:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5846:

lab5847:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5850
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5848
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5849

lab5848:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5849:

lab5850:
    jmp lab5852

lab5851:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5852:

lab5854:
    ; #load tag
    lea rdi, [rel List_ConflictSet_5855]
    ; jump wipe_head_
    jmp wipe_head_

List_ConflictSet_5855:
    jmp near List_ConflictSet_5855_Nil
    jmp near List_ConflictSet_5855_Cons

List_ConflictSet_5855_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5857
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab5856
    ; ####increment refcount
    add qword [rax + 0], 1

lab5856:
    jmp lab5858

lab5857:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab5858:
    ; let x1: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 := x1)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump collect_
    jmp collect_

List_ConflictSet_5855_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5860
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5859
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5859:
    jmp lab5861

lab5860:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5861:
    ; substitute (a2 := a2)(a7 := a7)(as1 := as1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x1: List[ConflictSet] = Cons(a7, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5873
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5874

lab5873:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5871
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5864
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5862
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5863

lab5862:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5863:

lab5864:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5867
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5865
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5866

lab5865:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5866:

lab5867:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5870
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5868
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5869

lab5868:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5869:

lab5870:
    jmp lab5872

lab5871:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5872:

lab5874:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 := x1)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump collect_
    jmp collect_

List_i64_5841:
    jmp near List_i64_5841_Nil
    jmp near List_i64_5841_Cons

List_i64_5841_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5877
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5875
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5875:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5876
    ; ####increment refcount
    add qword [rax + 0], 1

lab5876:
    jmp lab5878

lab5877:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5878:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a1 := a1)(as_ := as_)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_domain_wipeout_1_
    jmp lift_domain_wipeout_1_

List_i64_5841_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5881
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5879
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5879:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5880
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5880:
    jmp lab5882

lab5881:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5882:
    ; substitute (a1 := a1)(as_ := as_)(a6 := a6)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5894
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5895

lab5894:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5892
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5885
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5883
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5884

lab5883:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5884:

lab5885:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5888
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5886
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5887

lab5886:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5887:

lab5888:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5891
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5889
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5890

lab5889:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5890:

lab5891:
    jmp lab5893

lab5892:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5893:

lab5895:
    ; #load tag
    mov r9, 5
    ; jump lift_domain_wipeout_1_
    jmp lift_domain_wipeout_1_

lift_domain_wipeout_1_:
    ; let cs_: ConflictSet = Known(x0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5907
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5908

lab5907:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5905
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5898
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5896
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5897

lab5896:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5897:

lab5898:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5901
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5899
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5900

lab5899:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5900:

lab5901:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5904
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5902
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5903

lab5902:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5903:

lab5904:
    jmp lab5906

lab5905:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5906:

lab5908:
    ; #load tag
    mov r9, 0
    ; jump share_domain_wipeout_0_
    jmp share_domain_wipeout_0_

share_domain_wipeout_0_:
    ; substitute (as_ := as_)(cs_ := cs_)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

fc_:
    ; substitute (csp0 := csp)(t := t)(a0 := a0)(csp := csp);
    ; #share csp
    cmp rax, 0
    je lab5909
    ; ####increment refcount
    add qword [rax + 0], 1

lab5909:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a1: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5921
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5922

lab5921:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5919
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5912
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5910
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5911

lab5910:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5911:

lab5912:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5915
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5913
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5914

lab5913:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5914:

lab5915:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5918
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5916
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5917

lab5916:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5917:

lab5918:
    jmp lab5920

lab5919:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5920:

lab5922:
    ; #load tag
    lea r9, [rel Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5923]
    ; substitute (csp00 := csp0)(t := t)(a1 := a1)(csp0 := csp0);
    ; #share csp0
    cmp rax, 0
    je lab5924
    ; ####increment refcount
    add qword [rax + 0], 1

lab5924:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a2: Node[Pair[List[Assign], List[List[ConflictSet]]]] = (a1, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5936
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5937

lab5936:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5934
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5927
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5925
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5926

lab5925:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5926:

lab5927:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5930
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5928
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5929

lab5928:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5929:

lab5930:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5933
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5931
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5932

lab5931:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5932:

lab5933:
    jmp lab5935

lab5934:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5935:

lab5937:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_List_List_ConflictSet_5938]
    ; substitute (csp000 := csp00)(t := t)(a2 := a2)(csp00 := csp00);
    ; #share csp00
    cmp rax, 0
    je lab5939
    ; ####increment refcount
    add qword [rax + 0], 1

lab5939:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a3: List[List[ConflictSet]] = (t, a2, csp00)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5951
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5952

lab5951:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5949
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5942
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5940
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5941

lab5940:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5941:

lab5942:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5945
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5943
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5944

lab5943:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5944:

lab5945:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5948
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5946
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5947

lab5946:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5947:

lab5948:
    jmp lab5950

lab5949:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5950:

lab5952:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_5953]
    ; jump empty_table_
    jmp empty_table_

List_List_ConflictSet_5953:
    jmp near List_List_ConflictSet_5953_Nil
    jmp near List_List_ConflictSet_5953_Cons

List_List_ConflictSet_5953_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5957
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5954
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5954:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5955
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5955:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5956
    ; ####increment refcount
    add qword [rax + 0], 1

lab5956:
    jmp lab5958

lab5957:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5958:
    ; let x2: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (csp00 := csp00)(x2 := x2)(t := t)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_List_ConflictSet_5953_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5962
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5959
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5959:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5960
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5960:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5961
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5961:
    jmp lab5963

lab5962:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5963:
    ; substitute (csp00 := csp00)(a2 := a2)(t := t)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x2: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5975
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5976

lab5975:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5973
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5965

lab5964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5965:

lab5966:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5969
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5967
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5968

lab5967:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5968:

lab5969:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5972
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5970
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5971

lab5970:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5971:

lab5972:
    jmp lab5974

lab5973:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5974:

lab5976:
    ; #load tag
    mov r11, 5
    ; substitute (csp00 := csp00)(x2 := x2)(t := t)(a2 := a2);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

Node_Pair_List_Assign_List_List_ConflictSet_5938:

Node_Pair_List_Assign_List_List_ConflictSet_5938_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5979
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5977
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5977:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5978
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5978:
    jmp lab5980

lab5979:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5980:
    ; substitute (csp0 := csp0)(a1 := a1)(lab1 := lab1)(children1 := children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: Node[Pair[List[Assign], List[List[ConflictSet]]]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5992
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5993

lab5992:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5990
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5983
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5981
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5982

lab5981:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5982:

lab5983:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5986
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5984
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5985

lab5984:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5985:

lab5986:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5989
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5987
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5988

lab5987:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5988:

lab5989:
    jmp lab5991

lab5990:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5991:

lab5993:
    ; #load tag
    mov r9, 0
    ; substitute (csp0 := csp0)(x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lookup_cache_
    jmp lookup_cache_

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5923:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5923_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5996
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5994
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5994:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5995
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5995:
    jmp lab5997

lab5996:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5997:
    ; substitute (csp := csp)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6009
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6010

lab6009:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6007
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6000
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5998
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5999

lab5998:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5999:

lab6000:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6003
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6001
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6002

lab6001:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6002:

lab6003:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6006
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6004
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6005

lab6004:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6005:

lab6006:
    jmp lab6008

lab6007:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6008:

lab6010:
    ; #load tag
    mov r9, 0
    ; substitute (csp := csp)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump domain_wipeout_
    jmp domain_wipeout_

list_len_:
    ; substitute (a0 := a0)(l := l);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_List_Assign_6011]
    add rcx, rdi
    jmp rcx

List_List_Assign_6011:
    jmp near List_List_Assign_6011_Nil
    jmp near List_List_Assign_6011_Cons

List_List_Assign_6011_Nil:
    ; lit x2 <- 0;
    mov rdi, 0
    ; substitute (x2 := x2)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

List_List_Assign_6011_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab6014
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab6012
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6012:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab6013
    ; ####increment refcount
    add qword [rsi + 0], 1

lab6013:
    jmp lab6015

lab6014:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab6015:
    ; substitute (a0 := a0)(ls := ls);
    ; #erase l0
    cmp rsi, 0
    je lab6018
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab6016
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab6017

lab6016:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab6017:

lab6018:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; lit x0 <- 1;
    mov r9, 1
    ; substitute (ls := ls)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: _Cont = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6030
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6031

lab6030:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6028
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6021
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6019
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6020

lab6019:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6020:

lab6021:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6024
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6022
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6023

lab6022:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6023:

lab6024:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6027
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6025
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6026

lab6025:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6026:

lab6027:
    jmp lab6029

lab6028:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6029:

lab6031:
    ; #load tag
    lea rdi, [rel _Cont_6032]
    ; jump list_len_
    jmp list_len_

_Cont_6032:

_Cont_6032_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab6034
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab6033
    ; ####increment refcount
    add qword [rsi + 0], 1

lab6033:
    jmp lab6035

lab6034:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab6035:
    ; x3 <- x0 + x1;
    mov r11, r9
    add r11, rdx
    ; substitute (x3 := x3)(a0 := a0);
    ; #move variables
    mov rdx, r11
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

try__:
    ; create a1: List[List[Assign]] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6047
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6048

lab6047:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6045
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6038
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6036
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6037

lab6036:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6037:

lab6038:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6041
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6039
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6040

lab6039:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6040:

lab6041:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6044
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6042
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6043

lab6042:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6043:

lab6044:
    jmp lab6046

lab6045:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6046:

lab6048:
    ; #load tag
    lea r9, [rel List_List_Assign_6049]
    ; create a2: CSP = (algorithm, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6061
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6062

lab6061:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6059
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6052
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6050
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6051

lab6050:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6051:

lab6052:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6055
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6053
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6054

lab6053:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6054:

lab6055:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6058
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6056
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6057

lab6056:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6057:

lab6058:
    jmp lab6060

lab6059:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6060:

lab6062:
    ; #load tag
    lea rdi, [rel CSP_6063]
    ; jump queens_
    jmp queens_

CSP_6063:

CSP_6063_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab6066
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab6064
    ; ####increment refcount
    add qword [r12 + 0], 1

lab6064:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab6065
    ; ####increment refcount
    add qword [r10 + 0], 1

lab6065:
    jmp lab6067

lab6066:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab6067:
    ; substitute (a1 := a1)(algorithm := algorithm)(vars0 := vars0)(vals0 := vals0)(rel0 := rel0);
    ; #move variables
    mov rcx, r13
    mov r13, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    mov rax, r12
    mov r12, r8
    mov rsi, r10
    ; let x1: CSP = CSP(vars0, vals0, rel0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6079
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6080

lab6079:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6077
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6070
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6068
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6069

lab6068:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6069:

lab6070:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6073
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6071
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6072

lab6071:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6072:

lab6073:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6076
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6074
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6075

lab6074:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6075:

lab6076:
    jmp lab6078

lab6077:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6078:

lab6080:
    ; #load tag
    mov r9, 0
    ; substitute (algorithm := algorithm)(x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_
    jmp search_

List_List_Assign_6049:
    jmp near List_List_Assign_6049_Nil
    jmp near List_List_Assign_6049_Cons

List_List_Assign_6049_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab6082
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab6081
    ; ####increment refcount
    add qword [rax + 0], 1

lab6081:
    jmp lab6083

lab6082:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab6083:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump list_len_
    jmp list_len_

List_List_Assign_6049_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6085
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab6084
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6084:
    jmp lab6086

lab6085:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab6086:
    ; substitute (a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6098
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6099

lab6098:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6096
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6089
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6087
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6088

lab6087:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6088:

lab6089:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6092
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6090
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6091

lab6090:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6091:

lab6092:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6095
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6093
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6094

lab6093:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6094:

lab6095:
    jmp lab6097

lab6096:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6097:

lab6099:
    ; #load tag
    mov rdi, 5
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump list_len_
    jmp list_len_

test_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6100]
    add rcx, r9
    jmp rcx

List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6100:
    jmp near List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6100_Nil
    jmp near List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6100_Cons

List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6100_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab6103
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab6101
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab6102

lab6101:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab6102:

lab6103:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6100_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6106
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab6104
    ; ####increment refcount
    add qword [r10 + 0], 1

lab6104:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab6105
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6105:
    jmp lab6107

lab6106:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab6107:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab6108
    ; ####increment refcount
    add qword [rax + 0], 1

lab6108:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: _Cont = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6120
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6121

lab6120:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6118
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6110

lab6109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6110:

lab6111:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6114
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6112
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6113

lab6112:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6113:

lab6114:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6117
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6115
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6116

lab6115:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6116:

lab6117:
    jmp lab6119

lab6118:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6119:

lab6121:
    ; #load tag
    lea r9, [rel _Cont_6122]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

_Cont_6122:

_Cont_6122_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab6126
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab6123
    ; ####increment refcount
    add qword [r10 + 0], 1

lab6123:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab6124
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6124:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab6125
    ; ####increment refcount
    add qword [rsi + 0], 1

lab6125:
    jmp lab6127

lab6126:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab6127:
    ; substitute (f := f)(ps := ps)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rax, r10
    ; create a2: List[i64] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6139
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6140

lab6139:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6137
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6130
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6128
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6129

lab6128:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6129:

lab6130:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6133
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6131
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6132

lab6131:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6132:

lab6133:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6136
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6134
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6135

lab6134:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6135:

lab6136:
    jmp lab6138

lab6137:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6138:

lab6140:
    ; #load tag
    lea r9, [rel List_i64_6141]
    ; jump test_map_
    jmp test_map_

List_i64_6141:
    jmp near List_i64_6141_Nil
    jmp near List_i64_6141_Cons

List_i64_6141_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab6143
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab6142
    ; ####increment refcount
    add qword [rax + 0], 1

lab6142:
    jmp lab6144

lab6143:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab6144:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_6141_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6146
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab6145
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6145:
    jmp lab6147

lab6146:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab6147:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6159
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6160

lab6159:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6157
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6150
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6148
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6149

lab6148:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6149:

lab6150:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6153
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6151
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6152

lab6151:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6152:

lab6153:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6156
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6154
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6155

lab6154:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6155:

lab6156:
    jmp lab6158

lab6157:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6158:

lab6160:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

test_constraints_nofib_:
    ; substitute (a0 := a0)(n := n);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; create x0: Fun[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]], i64] = (n)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov qword [rbx + 48], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6172
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6173

lab6172:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6170
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6163
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6161
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6162

lab6161:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6162:

lab6163:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6166
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6164
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6165

lab6164:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6165:

lab6166:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6169
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6167
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6168

lab6167:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6168:

lab6169:
    jmp lab6171

lab6170:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6171:

lab6173:
    ; #load tag
    lea rdi, [rel Fun_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_i64_6174]
    ; create x1: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6175]
    ; create x2: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6176]
    ; create x3: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6177]
    ; create x4: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    lea r15, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6178]
    ; create x5: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    lea rcx, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6179]
    mov [rsp + 2024], rcx
    ; let x6: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    mov qword [rsp + 2008], 0
    ; let x7: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x5, x6);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6191
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab6192

lab6191:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6189
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6182
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6180
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6181

lab6180:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6181:

lab6182:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6185
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6183
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6184

lab6183:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6184:

lab6185:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6188
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6186
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6187

lab6186:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6187:

lab6188:
    jmp lab6190

lab6189:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6190:

lab6192:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; let x8: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x4, x7);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6204
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab6205

lab6204:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6202
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6195
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6193
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6194

lab6193:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6194:

lab6195:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6198
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6196
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6197

lab6196:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6197:

lab6198:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6201
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6199
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6200

lab6199:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6200:

lab6201:
    jmp lab6203

lab6202:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6203:

lab6205:
    ; #load tag
    mov r15, 5
    ; let x9: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x3, x8);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6217
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab6218

lab6217:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6215
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6208
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6206
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6207

lab6206:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6207:

lab6208:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6211
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6209
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6210

lab6209:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6210:

lab6211:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6214
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6212
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6213

lab6212:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6213:

lab6214:
    jmp lab6216

lab6215:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6216:

lab6218:
    ; #load tag
    mov r13, 5
    ; let x10: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x2, x9);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6230
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab6231

lab6230:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6228
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6221
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6219
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6220

lab6219:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6220:

lab6221:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6224
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6222
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6223

lab6222:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6223:

lab6224:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6227
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6225
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6226

lab6225:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6226:

lab6227:
    jmp lab6229

lab6228:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6229:

lab6231:
    ; #load tag
    mov r11, 5
    ; let x11: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x1, x10);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6243
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6244

lab6243:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6241
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6234
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6232
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6233

lab6232:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6233:

lab6234:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6237
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6235
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6236

lab6235:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6236:

lab6237:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6239

lab6238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6239:

lab6240:
    jmp lab6242

lab6241:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6242:

lab6244:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x11 := x11)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump test_map_
    jmp test_map_

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6179:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6179_Apply2:
    ; jump fc_
    jmp fc_

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6178:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6178_Apply2:
    ; jump bjbt__
    jmp bjbt__

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6177:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6177_Apply2:
    ; jump bjbt_
    jmp bjbt_

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6176:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6176_Apply2:
    ; jump bm_
    jmp bm_

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6175:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6175_Apply2:
    ; jump bt_
    jmp bt_

Fun_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_i64_6174:

Fun_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_i64_6174_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6245
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    jmp lab6246

lab6245:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]

lab6246:
    ; substitute (n := n)(x := x)(a1 := a1);
    ; #move variables
    mov r8, rsi
    mov rsi, rax
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump try__
    jmp try__

head_:
    ; substitute (a0 := a0)(l := l);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_i64_6247]
    add rcx, rdi
    jmp rcx

List_i64_6247:
    jmp near List_i64_6247_Nil
    jmp near List_i64_6247_Cons

List_i64_6247_Nil:
    ; lit x0 <- -1;
    mov rdi, -1
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

List_i64_6247_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab6249
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab6248
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6248:
    mov rdi, [rsi + 40]
    jmp lab6250

lab6249:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab6250:
    ; substitute (x := x)(a0 := a0);
    ; #erase xs
    cmp r8, 0
    je lab6253
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab6251
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab6252

lab6251:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab6252:

lab6253:
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

main_loop_:
    ; lit x0 <- 1;
    mov r11, 1
    ; if iters == x0 \{ ... \}
    cmp rdx, r11
    je lab6254
    ; else branch
    ; substitute (n0 := n)(n := n)(a0 := a0)(iters := iters);
    ; #move variables
    mov r11, rdx
    mov rdx, rdi
    ; create a3: List[i64] = (n, a0, iters)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6266
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6267

lab6266:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6264
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6257
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6255
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6256

lab6255:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6256:

lab6257:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6259

lab6258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6259:

lab6260:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6263
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6261
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6262

lab6261:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6262:

lab6263:
    jmp lab6265

lab6264:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6265:

lab6267:
    ; #load tag
    lea rdi, [rel List_i64_6268]
    ; jump test_constraints_nofib_
    jmp test_constraints_nofib_

List_i64_6268:
    jmp near List_i64_6268_Nil
    jmp near List_i64_6268_Cons

List_i64_6268_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab6270
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab6269
    ; ####increment refcount
    add qword [rsi + 0], 1

lab6269:
    mov rdx, [rax + 24]
    jmp lab6271

lab6270:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab6271:
    ; let res: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(iters := iters)(n := n);
    ; #erase res
    cmp r10, 0
    je lab6274
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab6272
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab6273

lab6272:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab6273:

lab6274:
    ; #move variables
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump lift_main_loop_1_
    jmp lift_main_loop_1_

List_i64_6268_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6276
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab6275
    ; ####increment refcount
    add qword [r10 + 0], 1

lab6275:
    mov r9, [r8 + 24]
    jmp lab6277

lab6276:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab6277:
    ; substitute (iters := iters)(a0 := a0)(n := n)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov r12, rsi
    mov rsi, r10
    ; let res: List[i64] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6289
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab6290

lab6289:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6287
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6280
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6278
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6279

lab6278:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6279:

lab6280:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6283
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6281
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6282

lab6281:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6282:

lab6283:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6286
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6284
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6285

lab6284:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6285:

lab6286:
    jmp lab6288

lab6287:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6288:

lab6290:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(iters := iters)(n := n);
    ; #erase res
    cmp r10, 0
    je lab6293
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab6291
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab6292

lab6291:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab6292:

lab6293:
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump lift_main_loop_1_
    jmp lift_main_loop_1_

lab6254:
    ; then branch
    ; substitute (n := n)(a0 := a0);
    ; #move variables
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; create a2: List[i64] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6305
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6306

lab6305:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6303
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6296
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6294
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6295

lab6294:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6295:

lab6296:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6299
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6297
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6298

lab6297:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6298:

lab6299:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6302
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6300
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6301

lab6300:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6301:

lab6302:
    jmp lab6304

lab6303:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6304:

lab6306:
    ; #load tag
    lea rdi, [rel List_i64_6307]
    ; jump test_constraints_nofib_
    jmp test_constraints_nofib_

List_i64_6307:
    jmp near List_i64_6307_Nil
    jmp near List_i64_6307_Cons

List_i64_6307_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab6309
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab6308
    ; ####increment refcount
    add qword [rax + 0], 1

lab6308:
    jmp lab6310

lab6309:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab6310:
    ; let res: List[i64] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_main_loop_0_
    jmp lift_main_loop_0_

List_i64_6307_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6312
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab6311
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6311:
    jmp lab6313

lab6312:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab6313:
    ; substitute (a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; let res: List[i64] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6325
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6326

lab6325:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6323
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6316
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6314
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6315

lab6314:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6315:

lab6316:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6319
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6317
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6318

lab6317:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6318:

lab6319:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6322
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6320
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6321

lab6320:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6321:

lab6322:
    jmp lab6324

lab6323:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6324:

lab6326:
    ; #load tag
    mov rdi, 5
    ; jump lift_main_loop_0_
    jmp lift_main_loop_0_

lift_main_loop_1_:
    ; lit x2 <- 1;
    mov r11, 1
    ; x3 <- iters - x2;
    mov r13, rdi
    sub r13, r11
    ; substitute (x3 := x3)(n := n)(a0 := a0);
    ; #move variables
    mov r8, rax
    mov rdi, r9
    mov r9, rdx
    mov rdx, r13
    ; jump main_loop_
    jmp main_loop_

lift_main_loop_0_:
    ; substitute (res := res)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: _Cont = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6338
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6339

lab6338:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6336
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6329
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6327
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6328

lab6327:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6328:

lab6329:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6332
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6330
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6331

lab6330:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6331:

lab6332:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6335
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6333
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6334

lab6333:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6334:

lab6335:
    jmp lab6337

lab6336:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6337:

lab6339:
    ; #load tag
    lea rdi, [rel _Cont_6340]
    ; jump head_
    jmp head_

_Cont_6340:

_Cont_6340_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab6342
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab6341
    ; ####increment refcount
    add qword [rsi + 0], 1

lab6341:
    jmp lab6343

lab6342:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab6343:
    ; println_i64 x1;
    ; #save caller-save registers
    mov r12, rdx
    mov r13, rsi
    mov r14, rdi
    sub rsp, 8
    ; #move argument into place
    mov rdi, rdx
    call println_i64
    ; #restore caller-save registers
    mov rdx, r12
    mov rsi, r13
    mov rdi, r14
    add rsp, 8
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; lit x4 <- 0;
    mov rdi, 0
    ; substitute (x4 := x4)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

cleanup:
    ; free space for register spills
    add rsp, 2048
    ; restore registers
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbp
    pop rbx
    ret