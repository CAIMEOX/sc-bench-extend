    ; asmsyntax=nasm
section .note.GNU-stack noalloc noexec nowrite progbits
section .text
extern print_i64
extern println_i64
global asm_main

asm_main:
    ; setup
    ; save registers
    push rbx
    push rbp
    push r12
    push r13
    push r14
    push r15
    ; reserve space for register spills
    sub rsp, 2048
    ; initialize heap pointer
    mov rbx, rdi
    ; initialize free pointer
    mov rbp, rbx
    add rbp, 64
    ; move parameters into place
    mov rdi, rdx
    ; move parameters into place
    mov rdx, rsi
    ; actual code

main_:
    ; create a0: _Cont = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel _Cont_1]
    ; jump main_loop_
    jmp main_loop_

_Cont_1:

_Cont_1_Ret:
    ; exit x0
    mov rax, rdx
    jmp cleanup

abs_:
    ; if i < 0 \{ ... \}
    cmp rdx, 0
    jl lab2
    ; else branch
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

lab2:
    ; then branch
    ; lit x0 <- -1;
    mov r9, -1
    ; x1 <- x0 * i;
    mov r11, r9
    imul r11, rdx
    ; substitute (x1 := x1)(a0 := a0);
    ; #move variables
    mov rdx, r11
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

eq_:
    ; if i1 == i2 \{ ... \}
    cmp rdx, rdi
    je lab3
    ; else branch
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 False
    add rdx, 5
    jmp rdx

lab3:
    ; then branch
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 True
    add rdx, 0
    jmp rdx

not_:
    ; substitute (a0 := a0)(b := b);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch b \{ ... \};
    lea rcx, [rel Bool_4]
    add rcx, rdi
    jmp rcx

Bool_4:
    jmp near Bool_4_True
    jmp near Bool_4_False

Bool_4_True:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

Bool_4_False:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

reverse_loop_:
    ; substitute (a0 := a0)(acc := acc)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_5]
    add rcx, r9
    jmp rcx

List_Assign_5:
    jmp near List_Assign_5_Nil
    jmp near List_Assign_5_Cons

List_Assign_5_Nil:
    ; switch acc \{ ... \};
    lea rcx, [rel List_Assign_6]
    add rcx, rdi
    jmp rcx

List_Assign_6:
    jmp near List_Assign_6_Nil
    jmp near List_Assign_6_Cons

List_Assign_6_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_6_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab9
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab7
    ; ####increment refcount
    add qword [r8 + 0], 1

lab7:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab8
    ; ####increment refcount
    add qword [rsi + 0], 1

lab8:
    jmp lab10

lab9:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab10:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Assign_5_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab13
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab11
    ; ####increment refcount
    add qword [r10 + 0], 1

lab11:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab12
    ; ####increment refcount
    add qword [r8 + 0], 1

lab12:
    jmp lab14

lab13:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab14:
    ; substitute (a0 := a0)(as := as)(a := a)(acc := acc);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; let x0: List[Assign] = Cons(a, acc);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab26
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab27

lab26:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab24
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab17
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab15
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab16

lab15:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab16:

lab17:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab20
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab18
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab19

lab18:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab19:

lab20:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab23
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab21
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab22

lab21:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab22:

lab23:
    jmp lab25

lab24:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab25:

lab27:
    ; #load tag
    mov r9, 5
    ; substitute (as := as)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump reverse_loop_
    jmp reverse_loop_

reverse_:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (ls := ls)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump reverse_loop_
    jmp reverse_loop_

level_:
    ; substitute (a0 := a0)(a := a);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch a \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_28:

Assign_28_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab29
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab30

lab29:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab30:
    ; substitute (varr := varr)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

value_:
    ; substitute (a0 := a0)(a := a);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch a \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_31:

Assign_31_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab32
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab33

lab32:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab33:
    ; substitute (value := value)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rdx, r9
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

max_level_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_34]
    add rcx, rdi
    jmp rcx

List_Assign_34:
    jmp near List_Assign_34_Nil
    jmp near List_Assign_34_Cons

List_Assign_34_Nil:
    ; lit x0 <- 0;
    mov rdi, 0
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

List_Assign_34_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab37
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab35
    ; ####increment refcount
    add qword [r8 + 0], 1

lab35:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab36
    ; ####increment refcount
    add qword [rsi + 0], 1

lab36:
    jmp lab38

lab37:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab38:
    ; substitute (a0 := a0)(a := a);
    ; #erase t
    cmp r8, 0
    je lab41
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab39
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab40

lab39:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab40:

lab41:
    ; switch a \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_42:

Assign_42_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab43
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab44

lab43:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab44:
    ; substitute (v := v)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

complete_:
    ; substitute (a0 := a0)(s := s)(csp := csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_45:

CSP_45_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab47
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab46
    ; ####increment refcount
    add qword [r12 + 0], 1

lab46:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab48

lab47:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab48:
    ; substitute (s := s)(a0 := a0)(v := v);
    ; #erase rel
    cmp r12, 0
    je lab51
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab49
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab50

lab49:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab50:

lab51:
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: _Cont = (a0, v)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab63
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab64

lab63:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab54
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab52
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab53

lab52:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab53:

lab54:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56

lab55:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56:

lab57:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59

lab58:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59:

lab60:
    jmp lab62

lab61:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62:

lab64:
    ; #load tag
    lea rdi, [rel _Cont_65]
    ; jump max_level_
    jmp max_level_

_Cont_65:

_Cont_65_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab67
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab66
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66:
    jmp lab68

lab67:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68:
    ; substitute (x0 := x0)(v := v)(a0 := a0);
    ; #move variables
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump eq_
    jmp eq_

enum_from_to_:
    ; if from <= to_ \{ ... \}
    cmp rdx, rdi
    jle lab69
    ; else branch
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

lab69:
    ; then branch
    ; substitute (from0 := from)(to_ := to_)(a0 := a0)(from := from);
    ; #move variables
    mov r11, rdx
    ; create a1: List[i64] = (a0, from)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab81
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab82

lab81:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab79
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71

lab70:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71:

lab72:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab75
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74

lab73:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74:

lab75:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab78
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab76
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab77

lab76:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab77:

lab78:
    jmp lab80

lab79:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab80:

lab82:
    ; #load tag
    lea r9, [rel List_i64_83]
    ; lit x1 <- 1;
    mov r11, 1
    ; x2 <- from0 + x1;
    mov r13, rdx
    add r13, r11
    ; substitute (x2 := x2)(to_ := to_)(a1 := a1);
    ; #move variables
    mov rdx, r13
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_83:
    jmp near List_i64_83_Nil
    jmp near List_i64_83_Cons

List_i64_83_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab85
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab84
    ; ####increment refcount
    add qword [rax + 0], 1

lab84:
    jmp lab86

lab85:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab86:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (from := from)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_83_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab88
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab87
    ; ####increment refcount
    add qword [r8 + 0], 1

lab87:
    jmp lab89

lab88:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab89:
    ; substitute (from := from)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab101
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab102

lab101:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab99
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab92
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab90
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab91

lab90:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab91:

lab92:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab95
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab93
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab94

lab93:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab94:

lab95:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab98
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab96
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab97

lab96:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab97:

lab98:
    jmp lab100

lab99:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab100:

lab102:
    ; #load tag
    mov r9, 5
    ; substitute (from := from)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

safe_:
    ; substitute (a0 := a0)(as2 := as2)(as1 := as1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch as1 \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_103:

Assign_103_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab104
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab105

lab104:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab105:
    ; substitute (a0 := a0)(m := m)(i := i)(as2 := as2);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch as2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_106:

Assign_106_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab107
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab108

lab107:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab108:
    ; if m == n \{ ... \}
    cmp rdi, r13
    je lab109
    ; else branch
    ; substitute (n := n)(m := m)(i := i)(j := j)(a0 := a0);
    ; #move variables
    mov r12, rax
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; create a1: Bool = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab121
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab122

lab121:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab119
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab112
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab110
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab111

lab110:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab111:

lab112:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab115
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab113
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab114

lab113:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab114:

lab115:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab118
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab116
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab117

lab116:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab117:

lab118:
    jmp lab120

lab119:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab120:

lab122:
    ; #load tag
    lea r13, [rel Bool_123]
    ; substitute (j := j)(i := i)(m := m)(n := n)(a1 := a1);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a2: _Cont = (m, n, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab135
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab136

lab135:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab133
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab126
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab124
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab125

lab124:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab125:

lab126:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab128

lab127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab128:

lab129:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab131

lab130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab131:

lab132:
    jmp lab134

lab133:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab134:

lab136:
    ; #load tag
    lea r9, [rel _Cont_137]
    ; x2 <- i - j;
    mov r11, rdi
    sub r11, rdx
    ; substitute (x2 := x2)(a2 := a2);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    mov rdx, r11
    ; jump abs_
    jmp abs_

_Cont_137:

_Cont_137_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab139
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab138
    ; ####increment refcount
    add qword [r10 + 0], 1

lab138:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab140

lab139:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab140:
    ; substitute (n := n)(m := m)(x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a3: _Cont = (x1, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab152
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab153

lab152:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab150
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab143
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab141
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab142

lab141:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab142:

lab143:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab146
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab144
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab145

lab144:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab145:

lab146:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab149
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab147
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab148

lab147:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab148:

lab149:
    jmp lab151

lab150:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab151:

lab153:
    ; #load tag
    lea r9, [rel _Cont_154]
    ; x4 <- m - n;
    mov r11, rdi
    sub r11, rdx
    ; substitute (x4 := x4)(a3 := a3);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    mov rdx, r11
    ; jump abs_
    jmp abs_

_Cont_154:

_Cont_154_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab156
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab155
    ; ####increment refcount
    add qword [r8 + 0], 1

lab155:
    mov rdi, [rsi + 40]
    jmp lab157

lab156:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab157:
    ; substitute (x1 := x1)(x3 := x3)(a1 := a1);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump eq_
    jmp eq_

Bool_123:
    jmp near Bool_123_True
    jmp near Bool_123_False

Bool_123_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab159
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab158
    ; ####increment refcount
    add qword [rax + 0], 1

lab158:
    jmp lab160

lab159:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab160:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_123_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab162
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab161
    ; ####increment refcount
    add qword [rax + 0], 1

lab161:
    jmp lab163

lab162:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab163:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

lab109:
    ; then branch
    ; substitute (a0 := a0);
    ; invoke a0 False
    add rdx, 5
    jmp rdx

queens_:
    ; create x0: Fun2[Assign, Assign, Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun2_Assign_Assign_Bool_164]
    ; substitute (n := n)(n0 := n)(x0 := x0)(a0 := a0);
    ; #move variables
    mov r11, rdi
    mov rdi, rdx
    mov r10, rsi
    ; invoke a0 CSP
    ; #there is only one clause, so we can jump there directly
    jmp r11

Fun2_Assign_Assign_Bool_164:

Fun2_Assign_Assign_Bool_164_Apply2:
    ; jump safe_
    jmp safe_

mk_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_List_Assign_165]
    add rcx, r9
    jmp rcx

List_List_Assign_165:
    jmp near List_List_Assign_165_Nil
    jmp near List_List_Assign_165_Cons

List_List_Assign_165_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab168
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab166
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab167

lab166:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab167:

lab168:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Assign_165_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab171
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab169
    ; ####increment refcount
    add qword [r10 + 0], 1

lab169:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab170
    ; ####increment refcount
    add qword [r8 + 0], 1

lab170:
    jmp lab172

lab171:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab172:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab173
    ; ####increment refcount
    add qword [rax + 0], 1

lab173:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[List[Assign]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab185
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab186

lab185:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab183
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab176
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab174
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab175

lab174:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab175:

lab176:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab179
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab177
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab178

lab177:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab178:

lab179:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab182
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab180
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab181

lab180:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab181:

lab182:
    jmp lab184

lab183:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab184:

lab186:
    ; #load tag
    lea r9, [rel Node_List_Assign_187]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_List_Assign_187:

Node_List_Assign_187_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab191
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab188
    ; ####increment refcount
    add qword [r12 + 0], 1

lab188:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab189
    ; ####increment refcount
    add qword [r10 + 0], 1

lab189:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab190
    ; ####increment refcount
    add qword [r8 + 0], 1

lab190:
    jmp lab192

lab191:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab192:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[List[Assign]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab204
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab205

lab204:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab202
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab195
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab193
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab194

lab193:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab194:

lab195:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab198
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab196
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab197

lab196:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab197:

lab198:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab201
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab199
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab200

lab199:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab200:

lab201:
    jmp lab203

lab202:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab203:

lab205:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[List[Assign]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab217
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab218

lab217:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab215
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab208
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab206
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab207

lab206:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab207:

lab208:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab211
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab209
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab210

lab209:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab210:

lab211:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab214
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab212
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab213

lab212:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab213:

lab214:
    jmp lab216

lab215:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab216:

lab218:
    ; #load tag
    lea r9, [rel List_Node_List_Assign_219]
    ; jump mk_map_
    jmp mk_map_

List_Node_List_Assign_219:
    jmp near List_Node_List_Assign_219_Nil
    jmp near List_Node_List_Assign_219_Cons

List_Node_List_Assign_219_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab222
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab220
    ; ####increment refcount
    add qword [rsi + 0], 1

lab220:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab221
    ; ####increment refcount
    add qword [rax + 0], 1

lab221:
    jmp lab223

lab222:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab223:
    ; let x1: List[Node[List[Assign]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_List_Assign_219_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab226
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab224
    ; ####increment refcount
    add qword [r10 + 0], 1

lab224:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab225
    ; ####increment refcount
    add qword [r8 + 0], 1

lab225:
    jmp lab227

lab226:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab227:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[List[Assign]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab239
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab240

lab239:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab237
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab230
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab228
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab229

lab228:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab229:

lab230:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab233
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab231
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab232

lab231:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab232:

lab233:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab236
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab234
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab235

lab234:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab235:

lab236:
    jmp lab238

lab237:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab238:

lab240:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

mk_init_tree_:
    ; substitute (f := f)(x3 := x)(a0 := a0)(x := x);
    ; #share x
    cmp rsi, 0
    je lab241
    ; ####increment refcount
    add qword [rsi + 0], 1

lab241:
    ; #move variables
    mov r10, rsi
    mov r11, rdi
    ; create a1: List[Node[List[Assign]]] = (a0, x)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab253
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab254

lab253:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab251
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab244
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab242
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab243

lab242:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab243:

lab244:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab247
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab245
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab246

lab245:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab246:

lab247:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab250
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab248
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab249

lab248:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab249:

lab250:
    jmp lab252

lab251:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab252:

lab254:
    ; #load tag
    lea r9, [rel List_Node_List_Assign_255]
    ; substitute (f0 := f)(x3 := x3)(a1 := a1)(f := f);
    ; #share f
    cmp rax, 0
    je lab256
    ; ####increment refcount
    add qword [rax + 0], 1

lab256:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create x1: Fun[List[Assign], Node[List[Assign]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab268
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab269

lab268:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab266
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab259
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab257
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab258

lab257:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab258:

lab259:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab262
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab260
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab261

lab260:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab261:

lab262:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab265
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab263
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab264

lab263:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab264:

lab265:
    jmp lab267

lab266:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab267:

lab269:
    ; #load tag
    lea r11, [rel Fun_List_Assign_Node_List_Assign_270]
    ; create a3: List[List[Assign]] = (a1, x1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab282
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab283

lab282:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab280
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab273
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab271
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab272

lab271:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab272:

lab273:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab276
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab274
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab275

lab274:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab275:

lab276:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab279
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab277
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab278

lab277:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab278:

lab279:
    jmp lab281

lab280:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab281:

lab283:
    ; #load tag
    lea r9, [rel List_List_Assign_284]
    ; substitute (x3 := x3)(a3 := a3)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_List_Assign_284:
    jmp near List_List_Assign_284_Nil
    jmp near List_List_Assign_284_Cons

List_List_Assign_284_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab287
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab285
    ; ####increment refcount
    add qword [rsi + 0], 1

lab285:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab286
    ; ####increment refcount
    add qword [rax + 0], 1

lab286:
    jmp lab288

lab287:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab288:
    ; let x2: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(x2 := x2)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump mk_map_
    jmp mk_map_

List_List_Assign_284_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab291
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab289
    ; ####increment refcount
    add qword [r10 + 0], 1

lab289:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab290
    ; ####increment refcount
    add qword [r8 + 0], 1

lab290:
    jmp lab292

lab291:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab292:
    ; substitute (x1 := x1)(a1 := a1)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: List[List[Assign]] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab304
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab305

lab304:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab302
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab295
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab293
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab294

lab293:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab294:

lab295:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab298
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab296
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab297

lab296:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab297:

lab298:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab301
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab299
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab300

lab299:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab300:

lab301:
    jmp lab303

lab302:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab303:

lab305:
    ; #load tag
    mov r9, 5
    ; substitute (x1 := x1)(x2 := x2)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump mk_map_
    jmp mk_map_

Fun_List_Assign_Node_List_Assign_270:

Fun_List_Assign_Node_List_Assign_270_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab307
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab306
    ; ####increment refcount
    add qword [r8 + 0], 1

lab306:
    jmp lab308

lab307:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab308:
    ; substitute (f := f)(y := y)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump mk_init_tree_
    jmp mk_init_tree_

List_Node_List_Assign_255:
    jmp near List_Node_List_Assign_255_Nil
    jmp near List_Node_List_Assign_255_Cons

List_Node_List_Assign_255_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab311
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab309
    ; ####increment refcount
    add qword [rsi + 0], 1

lab309:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab310
    ; ####increment refcount
    add qword [rax + 0], 1

lab310:
    jmp lab312

lab311:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab312:
    ; let x0: List[Node[List[Assign]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x := x)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_List_Assign_255_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab315
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab313
    ; ####increment refcount
    add qword [r10 + 0], 1

lab313:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab314
    ; ####increment refcount
    add qword [r8 + 0], 1

lab314:
    jmp lab316

lab315:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab316:
    ; substitute (x := x)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[List[Assign]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab328
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab329

lab328:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab326
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab319
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab317
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab318

lab317:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab318:

lab319:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab322
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab320
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab321

lab320:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab321:

lab322:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab325
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab323
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab324

lab323:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab324:

lab325:
    jmp lab327

lab326:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab327:

lab329:
    ; #load tag
    mov r9, 5
    ; substitute (x := x)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

to_assign_:
    ; substitute (a0 := a0)(ss := ss)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_330]
    add rcx, r9
    jmp rcx

List_i64_330:
    jmp near List_i64_330_Nil
    jmp near List_i64_330_Cons

List_i64_330_Nil:
    ; substitute (a0 := a0);
    ; #erase ss
    cmp rsi, 0
    je lab333
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab331
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab332

lab331:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab332:

lab333:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_330_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab335
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab334
    ; ####increment refcount
    add qword [r10 + 0], 1

lab334:
    mov r9, [r8 + 40]
    jmp lab336

lab335:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab336:
    ; substitute (ss1 := ss)(ss := ss)(j := j)(t1 := t1)(a0 := a0);
    ; #share ss
    cmp rsi, 0
    je lab337
    ; ####increment refcount
    add qword [rsi + 0], 1

lab337:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, rsi
    mov rdx, rdi
    ; create a1: _Cont = (ss, j, t1, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab349
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab350

lab349:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab347
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab340
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab338
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab339

lab338:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab339:

lab340:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab343
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab341
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab342

lab341:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab342:

lab343:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab346
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab344
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab345

lab344:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab345:

lab346:
    jmp lab348

lab347:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab348:

lab350:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab362
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab363

lab362:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab360
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab353
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab351
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab352

lab351:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab352:

lab353:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab356
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab354
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab355

lab354:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab355:

lab356:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab359
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab357
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab358

lab357:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab358:

lab359:
    jmp lab361

lab360:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab361:

lab363:
    ; #load tag
    lea rdi, [rel _Cont_364]
    ; jump max_level_
    jmp max_level_

_Cont_364:

_Cont_364_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab368
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab365
    ; ####increment refcount
    add qword [rsi + 0], 1

lab365:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab366
    ; ####increment refcount
    add qword [r12 + 0], 1

lab366:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab367
    ; ####increment refcount
    add qword [r10 + 0], 1

lab367:
    mov r9, [r8 + 24]
    jmp lab369

lab368:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab369:
    ; lit x1 <- 1;
    mov r15, 1
    ; x2 <- x0 + x1;
    mov rcx, rdx
    add rcx, r15
    mov [rsp + 2024], rcx
    ; substitute (a0 := a0)(ss := ss)(t1 := t1)(x2 := x2)(j := j);
    ; #move variables
    mov rdx, r13
    mov r13, r9
    mov r8, r10
    mov r9, r11
    mov rax, r12
    mov r11, [rsp + 2024]
    ; let x3: Assign = Assign(x2, j);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab381
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab382

lab381:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab379
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab372
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab370
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab371

lab370:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab371:

lab372:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab375
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab373
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab374

lab373:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab374:

lab375:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab378
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab376
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab377

lab376:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab377:

lab378:
    jmp lab380

lab379:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab380:

lab382:
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(ss := ss)(t1 := t1)(x3 := x3)(ss0 := ss);
    ; #share ss
    cmp rsi, 0
    je lab383
    ; ####increment refcount
    add qword [rsi + 0], 1

lab383:
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    ; let x4: List[Assign] = Cons(x3, ss0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab395
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab396

lab395:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab393
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab386
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab384
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab385

lab384:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab385:

lab386:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab389
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab387
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab388

lab387:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab388:

lab389:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab392
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab390
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab391

lab390:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab391:

lab392:
    jmp lab394

lab393:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab394:

lab396:
    ; #load tag
    mov r11, 5
    ; substitute (t1 := t1)(ss := ss)(a0 := a0)(x4 := x4);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a2: List[List[Assign]] = (a0, x4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab408
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab409

lab408:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab406
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab399
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab397
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab398

lab397:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab398:

lab399:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab402
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab400
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab401

lab400:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab401:

lab402:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab405
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab403
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab404

lab403:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab404:

lab405:
    jmp lab407

lab406:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab407:

lab409:
    ; #load tag
    lea r9, [rel List_List_Assign_410]
    ; jump to_assign_
    jmp to_assign_

List_List_Assign_410:
    jmp near List_List_Assign_410_Nil
    jmp near List_List_Assign_410_Cons

List_List_Assign_410_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab413
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab411
    ; ####increment refcount
    add qword [rsi + 0], 1

lab411:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab412
    ; ####increment refcount
    add qword [rax + 0], 1

lab412:
    jmp lab414

lab413:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab414:
    ; let x5: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x4 := x4)(x5 := x5)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_410_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab417
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab415
    ; ####increment refcount
    add qword [r10 + 0], 1

lab415:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab416
    ; ####increment refcount
    add qword [r8 + 0], 1

lab416:
    jmp lab418

lab417:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab418:
    ; substitute (x4 := x4)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x5: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab430
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab431

lab430:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab428
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab421
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab419
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab420

lab419:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab420:

lab421:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab424
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab422
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab423

lab422:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab423:

lab424:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab427
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab425
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab426

lab425:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab426:

lab427:
    jmp lab429

lab428:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab429:

lab431:
    ; #load tag
    mov r9, 5
    ; substitute (x4 := x4)(x5 := x5)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

mk_tree_:
    ; substitute (a0 := a0)(csp := csp);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_432:

CSP_432_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab434
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab433
    ; ####increment refcount
    add qword [r10 + 0], 1

lab433:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab435

lab434:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab435:
    ; substitute (a0 := a0)(vars := vars)(vals := vals);
    ; #erase rel
    cmp r10, 0
    je lab438
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab436
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab437

lab436:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab437:

lab438:
    ; create next: Fun[List[Assign], List[List[Assign]]] = (vars, vals)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab450
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab451

lab450:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab448
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab441
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab439
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab440

lab439:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab440:

lab441:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab444
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab442
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab443

lab442:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab443:

lab444:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab447
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab445
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab446

lab445:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab446:

lab447:
    jmp lab449

lab448:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab449:

lab451:
    ; #load tag
    lea rdi, [rel Fun_List_Assign_List_List_Assign_452]
    ; let x3: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (next := next)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump mk_init_tree_
    jmp mk_init_tree_

Fun_List_Assign_List_List_Assign_452:

Fun_List_Assign_List_List_Assign_452_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab453
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab454

lab453:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab454:
    ; substitute (ss0 := ss)(a1 := a1)(vars := vars)(vals := vals)(ss := ss);
    ; #share ss
    cmp rax, 0
    je lab455
    ; ####increment refcount
    add qword [rax + 0], 1

lab455:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    ; create a2: _Cont = (a1, vars, vals, ss)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab467
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab468

lab467:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab465
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab458
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab456
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab457

lab456:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab457:

lab458:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab461
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab459
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab460

lab459:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab460:

lab461:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab464
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab462
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab463

lab462:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab463:

lab464:
    jmp lab466

lab465:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab466:

lab468:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab480
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab481

lab480:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab478
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab471
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab469
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab470

lab469:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab470:

lab471:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab474
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab472
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab473

lab472:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab473:

lab474:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab477
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab475
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab476

lab475:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab476:

lab477:
    jmp lab479

lab478:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab479:

lab481:
    ; #load tag
    lea rdi, [rel _Cont_482]
    ; jump max_level_
    jmp max_level_

_Cont_482:

_Cont_482_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab485
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab483
    ; ####increment refcount
    add qword [rsi + 0], 1

lab483:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab484
    ; ####increment refcount
    add qword [r12 + 0], 1

lab484:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab486

lab485:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab486:
    ; if x0 < vars \{ ... \}
    cmp rdx, r9
    jl lab487
    ; else branch
    ; substitute (a1 := a1);
    ; #erase ss
    cmp r12, 0
    je lab490
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab488
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab489

lab488:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab489:

lab490:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a1 Nil
    add rdx, 0
    jmp rdx

lab487:
    ; then branch
    ; substitute (vals := vals)(a1 := a1)(ss := ss);
    ; #move variables
    mov rdx, r11
    mov r8, r12
    mov r9, r13
    ; create a3: List[i64] = (a1, ss)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab502
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab503

lab502:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab500
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab493
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab491
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab492

lab491:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab492:

lab493:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab496
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab494
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab495

lab494:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab495:

lab496:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab499
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab497
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab498

lab497:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab498:

lab499:
    jmp lab501

lab500:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab501:

lab503:
    ; #load tag
    lea rdi, [rel List_i64_504]
    ; lit x2 <- 1;
    mov r9, 1
    ; substitute (x2 := x2)(vals := vals)(a3 := a3);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_504:
    jmp near List_i64_504_Nil
    jmp near List_i64_504_Cons

List_i64_504_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab507
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab505
    ; ####increment refcount
    add qword [rsi + 0], 1

lab505:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab506
    ; ####increment refcount
    add qword [rax + 0], 1

lab506:
    jmp lab508

lab507:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab508:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(ss := ss)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump to_assign_
    jmp to_assign_

List_i64_504_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab511
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab509
    ; ####increment refcount
    add qword [r10 + 0], 1

lab509:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab510
    ; ####increment refcount
    add qword [r8 + 0], 1

lab510:
    jmp lab512

lab511:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab512:
    ; substitute (ss := ss)(a1 := a1)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab524
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab525

lab524:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab522
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab515
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab513
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab514

lab513:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab514:

lab515:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab518
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab516
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab517

lab516:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab517:

lab518:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab521
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab519
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab520

lab519:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab520:

lab521:
    jmp lab523

lab522:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab523:

lab525:
    ; #load tag
    mov r9, 5
    ; substitute (x1 := x1)(ss := ss)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump to_assign_
    jmp to_assign_

ear_inc_filter_:
    ; substitute (f := f)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_526]
    add rcx, r9
    jmp rcx

List_Assign_526:
    jmp near List_Assign_526_Nil
    jmp near List_Assign_526_Cons

List_Assign_526_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab529
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab527
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab528

lab527:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab528:

lab529:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_526_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab532
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab530
    ; ####increment refcount
    add qword [r10 + 0], 1

lab530:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab531
    ; ####increment refcount
    add qword [r8 + 0], 1

lab531:
    jmp lab533

lab532:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab533:
    ; substitute (f0 := f)(a4 := a)(a := a)(as := as)(f := f)(a0 := a0);
    ; #share a
    cmp r8, 0
    je lab534
    ; ####increment refcount
    add qword [r8 + 0], 1

lab534:
    ; #share f
    cmp rax, 0
    je lab535
    ; ####increment refcount
    add qword [rax + 0], 1

lab535:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; create a2: Bool = (a, as, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab547
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab548

lab547:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab545
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab538
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab536
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab537

lab536:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab537:

lab538:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab541
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab539
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab540

lab539:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab540:

lab541:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab544
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab542
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab543

lab542:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab543:

lab544:
    jmp lab546

lab545:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab546:

lab548:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab560
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab561

lab560:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab558
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab551
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab549
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab550

lab549:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab550:

lab551:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab554
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab552
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab553

lab552:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab553:

lab554:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab557
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab555
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab556

lab555:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab556:

lab557:
    jmp lab559

lab558:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab559:

lab561:
    ; #load tag
    lea r9, [rel Bool_562]
    ; substitute (a4 := a4)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_562:
    jmp near Bool_562_True
    jmp near Bool_562_False

Bool_562_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab567
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab563
    ; ####increment refcount
    add qword [rax + 0], 1

lab563:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab564
    ; ####increment refcount
    add qword [r10 + 0], 1

lab564:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab565
    ; ####increment refcount
    add qword [r8 + 0], 1

lab565:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab566
    ; ####increment refcount
    add qword [rsi + 0], 1

lab566:
    jmp lab568

lab567:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab568:
    ; substitute (f := f)(as := as)(a := a)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Assign] = (a, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab580
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab581

lab580:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab578
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab571
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab569
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab570

lab569:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab570:

lab571:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab574
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab572
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab573

lab572:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab573:

lab574:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab577
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab575
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab576

lab575:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab576:

lab577:
    jmp lab579

lab578:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab579:

lab581:
    ; #load tag
    lea r9, [rel List_Assign_582]
    ; jump ear_inc_filter_
    jmp ear_inc_filter_

List_Assign_582:
    jmp near List_Assign_582_Nil
    jmp near List_Assign_582_Cons

List_Assign_582_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab585
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab583
    ; ####increment refcount
    add qword [rsi + 0], 1

lab583:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab584
    ; ####increment refcount
    add qword [rax + 0], 1

lab584:
    jmp lab586

lab585:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab586:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a := a)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Assign_582_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab589
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab587
    ; ####increment refcount
    add qword [r10 + 0], 1

lab587:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab588
    ; ####increment refcount
    add qword [r8 + 0], 1

lab588:
    jmp lab590

lab589:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab590:
    ; substitute (a0 := a0)(a := a)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab602
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab603

lab602:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab600
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab593
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab591
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab592

lab591:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab592:

lab593:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab596
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab594
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab595

lab594:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab595:

lab596:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab599
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab597
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab598

lab597:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab598:

lab599:
    jmp lab601

lab600:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab601:

lab603:
    ; #load tag
    mov r9, 5
    ; substitute (a := a)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_562_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab608
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab604
    ; ####increment refcount
    add qword [rax + 0], 1

lab604:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab605
    ; ####increment refcount
    add qword [r10 + 0], 1

lab605:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab606
    ; ####increment refcount
    add qword [r8 + 0], 1

lab606:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab607
    ; ####increment refcount
    add qword [rsi + 0], 1

lab607:
    jmp lab609

lab608:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab609:
    ; substitute (f := f)(as := as)(a0 := a0);
    ; #erase a
    cmp rax, 0
    je lab612
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab610
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab611

lab610:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab611:

lab612:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump ear_inc_filter_
    jmp ear_inc_filter_

earliest_inconsistency_:
    ; substitute (a0 := a0)(aas := aas)(csp := csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_613:

CSP_613_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab615
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab614
    ; ####increment refcount
    add qword [r12 + 0], 1

lab614:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab616

lab615:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab616:
    ; substitute (a0 := a0)(rel := rel)(aas := aas);
    ; #move variables
    mov r8, rsi
    mov r9, rdi
    mov rsi, r12
    mov rdi, r13
    ; switch aas \{ ... \};
    lea rcx, [rel List_Assign_617]
    add rcx, r9
    jmp rcx

List_Assign_617:
    jmp near List_Assign_617_Nil
    jmp near List_Assign_617_Cons

List_Assign_617_Nil:
    ; substitute (a0 := a0);
    ; #erase rel
    cmp rsi, 0
    je lab620
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab618
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab619

lab618:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab619:

lab620:
    ; invoke a0 None
    add rdx, 0
    jmp rdx

List_Assign_617_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab623
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab621
    ; ####increment refcount
    add qword [r10 + 0], 1

lab621:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab622
    ; ####increment refcount
    add qword [r8 + 0], 1

lab622:
    jmp lab624

lab623:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab624:
    ; substitute (a0 := a0)(as_ := as_)(a8 := a)(a := a)(rel := rel);
    ; #share a
    cmp r8, 0
    je lab625
    ; ####increment refcount
    add qword [r8 + 0], 1

lab625:
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    mov rsi, r10
    mov r10, r8
    mov rdi, r11
    mov r11, r9
    ; create x0: Fun[Assign, Bool] = (a, rel)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab637
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab638

lab637:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab635
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab628
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab626
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab627

lab626:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab627:

lab628:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab631
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab629
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab630

lab629:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab630:

lab631:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab634
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab632
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab633

lab632:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab633:

lab634:
    jmp lab636

lab635:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab636:

lab638:
    ; #load tag
    lea r11, [rel Fun_Assign_Bool_639]
    ; substitute (as_ := as_)(a0 := a0)(a8 := a8)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a5: List[Assign] = (a0, a8, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab651
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab652

lab651:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab649
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab642
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab640
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab641

lab640:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab641:

lab642:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab645
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab643
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab644

lab643:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab644:

lab645:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab648
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab646
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab647

lab646:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab647:

lab648:
    jmp lab650

lab649:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab650:

lab652:
    ; #load tag
    lea rdi, [rel List_Assign_653]
    ; jump reverse_
    jmp reverse_

List_Assign_653:
    jmp near List_Assign_653_Nil
    jmp near List_Assign_653_Cons

List_Assign_653_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab657
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab654
    ; ####increment refcount
    add qword [r8 + 0], 1

lab654:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab655
    ; ####increment refcount
    add qword [rsi + 0], 1

lab655:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab656
    ; ####increment refcount
    add qword [rax + 0], 1

lab656:
    jmp lab658

lab657:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab658:
    ; let x1: List[Assign] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a8 := a8)(a0 := a0)(x0 := x0)(x1 := x1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_earliest_inconsistency_0_
    jmp lift_earliest_inconsistency_0_

List_Assign_653_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab662
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab659
    ; ####increment refcount
    add qword [r12 + 0], 1

lab659:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab660
    ; ####increment refcount
    add qword [r10 + 0], 1

lab660:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab661
    ; ####increment refcount
    add qword [r8 + 0], 1

lab661:
    jmp lab663

lab662:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab663:
    ; substitute (x0 := x0)(a8 := a8)(a0 := a0)(a7 := a7)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x1: List[Assign] = Cons(a7, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab675
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab676

lab675:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab673
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab666
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab664
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab665

lab664:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab665:

lab666:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab669
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab667
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab668

lab667:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab668:

lab669:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab672
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab670
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab671

lab670:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab671:

lab672:
    jmp lab674

lab673:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab674:

lab676:
    ; #load tag
    mov r11, 5
    ; substitute (a8 := a8)(a0 := a0)(x0 := x0)(x1 := x1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_earliest_inconsistency_0_
    jmp lift_earliest_inconsistency_0_

Fun_Assign_Bool_639:

Fun_Assign_Bool_639_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab679
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab677
    ; ####increment refcount
    add qword [r10 + 0], 1

lab677:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab678
    ; ####increment refcount
    add qword [r8 + 0], 1

lab678:
    jmp lab680

lab679:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab680:
    ; substitute (x := x)(rel := rel)(a := a)(a3 := a3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a4: Bool = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab692
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab693

lab692:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab690
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab683
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab681
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab682

lab681:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab682:

lab683:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab686
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab684
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab685

lab684:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab685:

lab686:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab689
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab687
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab688

lab687:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab688:

lab689:
    jmp lab691

lab690:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab691:

lab693:
    ; #load tag
    lea r11, [rel Bool_694]
    ; substitute (a := a)(x := x)(a4 := a4)(rel := rel);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke rel Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

Bool_694:
    jmp near Bool_694_True
    jmp near Bool_694_False

Bool_694_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab696
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab695
    ; ####increment refcount
    add qword [rax + 0], 1

lab695:
    jmp lab697

lab696:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab697:
    ; let x5: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x5 := x5)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_694_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab699
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab698
    ; ####increment refcount
    add qword [rax + 0], 1

lab698:
    jmp lab700

lab699:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab700:
    ; let x5: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x5 := x5)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

lift_earliest_inconsistency_0_:
    ; substitute (x1 := x1)(x0 := x0)(a0 := a0)(a := a);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a6: List[Assign] = (a0, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab712
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab713

lab712:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab710
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab703
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab701
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab702

lab701:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab702:

lab703:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab706
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab704
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab705

lab704:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab705:

lab706:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab709
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab707
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab708

lab707:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab708:

lab709:
    jmp lab711

lab710:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab711:

lab713:
    ; #load tag
    lea r9, [rel List_Assign_714]
    ; substitute (x0 := x0)(x1 := x1)(a6 := a6);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump ear_inc_filter_
    jmp ear_inc_filter_

List_Assign_714:
    jmp near List_Assign_714_Nil
    jmp near List_Assign_714_Cons

List_Assign_714_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab717
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab715
    ; ####increment refcount
    add qword [rsi + 0], 1

lab715:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab716
    ; ####increment refcount
    add qword [rax + 0], 1

lab716:
    jmp lab718

lab717:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab718:
    ; substitute (a0 := a0);
    ; #erase a
    cmp rsi, 0
    je lab721
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab719
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab720

lab719:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab720:

lab721:
    ; invoke a0 None
    add rdx, 0
    jmp rdx

List_Assign_714_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab724
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab722
    ; ####increment refcount
    add qword [r10 + 0], 1

lab722:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab723
    ; ####increment refcount
    add qword [r8 + 0], 1

lab723:
    jmp lab725

lab724:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab725:
    ; substitute (a := a)(b := b)(a0 := a0);
    ; #erase bs_
    cmp rsi, 0
    je lab728
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab726
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab727

lab726:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab727:

lab728:
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r10
    mov rdx, r11
    ; create a1: _Cont = (b, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab740
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab741

lab740:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab738
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab731
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab729
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab730

lab729:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab730:

lab731:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab734
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab732
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab733

lab732:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab733:

lab734:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab737
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab735
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab736

lab735:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab736:

lab737:
    jmp lab739

lab738:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab739:

lab741:
    ; #load tag
    lea rdi, [rel _Cont_742]
    ; jump level_
    jmp level_

_Cont_742:

_Cont_742_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab745
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab743
    ; ####increment refcount
    add qword [r8 + 0], 1

lab743:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab744
    ; ####increment refcount
    add qword [rsi + 0], 1

lab744:
    jmp lab746

lab745:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab746:
    ; substitute (b := b)(x2 := x2)(a0 := a0);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; create a2: _Cont = (x2, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab758
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab759

lab758:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab756
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab749
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab747
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab748

lab747:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab748:

lab749:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab752
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab750
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab751

lab750:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab751:

lab752:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab755
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab753
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab754

lab753:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab754:

lab755:
    jmp lab757

lab756:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab757:

lab759:
    ; #load tag
    lea rdi, [rel _Cont_760]
    ; jump level_
    jmp level_

_Cont_760:

_Cont_760_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab762
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab761
    ; ####increment refcount
    add qword [r8 + 0], 1

lab761:
    mov rdi, [rsi + 40]
    jmp lab763

lab762:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab763:
    ; substitute (a0 := a0)(x2 := x2)(x3 := x3);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r8
    ; let x4: Pair[i64, i64] = Tup(x2, x3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab775
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab776

lab775:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab773
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab766
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab764
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab765

lab764:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab765:

lab766:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab769
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab767
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab768

lab767:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab768:

lab769:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab772
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab770
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab771

lab770:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab771:

lab772:
    jmp lab774

lab773:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab774:

lab776:
    ; #load tag
    mov rdi, 0
    ; substitute (x4 := x4)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Some
    add rdi, 5
    jmp rdi

known_conflict_:
    ; substitute (a0 := a0)(c := c);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_777]
    add rcx, rdi
    jmp rcx

ConflictSet_777:
    jmp near ConflictSet_777_Known
    jmp near ConflictSet_777_Unknown

ConflictSet_777_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab779
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab778
    ; ####increment refcount
    add qword [rsi + 0], 1

lab778:
    jmp lab780

lab779:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab780:
    ; switch vs \{ ... \};
    lea rcx, [rel List_i64_781]
    add rcx, rdi
    jmp rcx

List_i64_781:
    jmp near List_i64_781_Nil
    jmp near List_i64_781_Cons

List_i64_781_Nil:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

List_i64_781_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab783
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab782
    ; ####increment refcount
    add qword [r8 + 0], 1

lab782:
    mov rdi, [rsi + 40]
    jmp lab784

lab783:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab784:
    ; substitute (a0 := a0);
    ; #erase vs0
    cmp r8, 0
    je lab787
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab785
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab786

lab785:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab786:

lab787:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

ConflictSet_777_Unknown:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

known_solution_:
    ; substitute (a0 := a0)(c := c);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_788]
    add rcx, rdi
    jmp rcx

ConflictSet_788:
    jmp near ConflictSet_788_Known
    jmp near ConflictSet_788_Unknown

ConflictSet_788_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab790
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab789
    ; ####increment refcount
    add qword [rsi + 0], 1

lab789:
    jmp lab791

lab790:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab791:
    ; switch vs \{ ... \};
    lea rcx, [rel List_i64_792]
    add rcx, rdi
    jmp rcx

List_i64_792:
    jmp near List_i64_792_Nil
    jmp near List_i64_792_Cons

List_i64_792_Nil:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_i64_792_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab794
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab793
    ; ####increment refcount
    add qword [r8 + 0], 1

lab793:
    mov rdi, [rsi + 40]
    jmp lab795

lab794:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab795:
    ; substitute (a0 := a0);
    ; #erase vs0
    cmp r8, 0
    je lab798
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab796
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab797

lab796:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab797:

lab798:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

ConflictSet_788_Unknown:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

check_complete_:
    ; create a1: Bool = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab810
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab811

lab810:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab808
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab801
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab799
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab800

lab799:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab800:

lab801:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab804
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab802
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab803

lab802:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab803:

lab804:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab807
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab805
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab806

lab805:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab806:

lab807:
    jmp lab809

lab808:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab809:

lab811:
    ; #load tag
    lea r9, [rel Bool_812]
    ; jump complete_
    jmp complete_

Bool_812:
    jmp near Bool_812_True
    jmp near Bool_812_False

Bool_812_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab814
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab813
    ; ####increment refcount
    add qword [rax + 0], 1

lab813:
    jmp lab815

lab814:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab815:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Known
    add rdi, 0
    jmp rdi

Bool_812_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab817
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab816
    ; ####increment refcount
    add qword [rax + 0], 1

lab816:
    jmp lab818

lab817:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab818:
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

search_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_819]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_819:
    jmp near List_Node_Pair_List_Assign_ConflictSet_819_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_819_Cons

List_Node_Pair_List_Assign_ConflictSet_819_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab822
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab820
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab821

lab820:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab821:

lab822:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_819_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab825
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab823
    ; ####increment refcount
    add qword [r10 + 0], 1

lab823:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab824
    ; ####increment refcount
    add qword [r8 + 0], 1

lab824:
    jmp lab826

lab825:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab826:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab827
    ; ####increment refcount
    add qword [rax + 0], 1

lab827:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab839
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab840

lab839:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab837
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab830
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab828
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab829

lab828:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab829:

lab830:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab833
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab831
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab832

lab831:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab832:

lab833:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab835

lab834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab835:

lab836:
    jmp lab838

lab837:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab838:

lab840:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_841]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_841:

Node_Pair_List_Assign_ConflictSet_841_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab845
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab842
    ; ####increment refcount
    add qword [r12 + 0], 1

lab842:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab843
    ; ####increment refcount
    add qword [r10 + 0], 1

lab843:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab844
    ; ####increment refcount
    add qword [r8 + 0], 1

lab844:
    jmp lab846

lab845:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab846:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab858
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab859

lab858:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab856
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab849
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab847
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab848

lab847:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab848:

lab849:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab852
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab850
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab851

lab850:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab851:

lab852:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab855
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab853
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab854

lab853:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab854:

lab855:
    jmp lab857

lab856:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab857:

lab859:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab871
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab872

lab871:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab869
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab862
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab860
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab861

lab860:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab861:

lab862:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab865
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab863
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab864

lab863:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab864:

lab865:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab868
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab866
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab867

lab866:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab867:

lab868:
    jmp lab870

lab869:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab870:

lab872:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_873]
    ; jump search_map_
    jmp search_map_

List_Node_Pair_List_Assign_ConflictSet_873:
    jmp near List_Node_Pair_List_Assign_ConflictSet_873_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_873_Cons

List_Node_Pair_List_Assign_ConflictSet_873_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab876
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab874
    ; ####increment refcount
    add qword [rsi + 0], 1

lab874:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab875
    ; ####increment refcount
    add qword [rax + 0], 1

lab875:
    jmp lab877

lab876:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab877:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_873_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab880
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab878
    ; ####increment refcount
    add qword [r10 + 0], 1

lab878:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab879
    ; ####increment refcount
    add qword [r8 + 0], 1

lab879:
    jmp lab881

lab880:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab881:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab893
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab894

lab893:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab891
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab884
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab882
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab883

lab882:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab883:

lab884:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab887
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab885
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab886

lab885:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab886:

lab887:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab890
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab888
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab889

lab888:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab889:

lab890:
    jmp lab892

lab891:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab892:

lab894:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_filter_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_895]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_895:
    jmp near List_Node_Pair_List_Assign_ConflictSet_895_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_895_Cons

List_Node_Pair_List_Assign_ConflictSet_895_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab898
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab896
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab897

lab896:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab897:

lab898:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_895_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab901
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab899
    ; ####increment refcount
    add qword [r10 + 0], 1

lab899:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab900
    ; ####increment refcount
    add qword [r8 + 0], 1

lab900:
    jmp lab902

lab901:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab902:
    ; substitute (f0 := f)(p0 := p)(p := p)(ps := ps)(f := f)(a0 := a0);
    ; #share f
    cmp rax, 0
    je lab903
    ; ####increment refcount
    add qword [rax + 0], 1

lab903:
    ; #share p
    cmp r8, 0
    je lab904
    ; ####increment refcount
    add qword [r8 + 0], 1

lab904:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; create a2: Bool = (p, ps, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab916
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab917

lab916:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab914
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab907
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab905
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab906

lab905:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab906:

lab907:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab910
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab908
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab909

lab908:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab909:

lab910:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab913
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab911
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab912

lab911:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab912:

lab913:
    jmp lab915

lab914:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab915:

lab917:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab929
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab930

lab929:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab927
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab920
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab918
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab919

lab918:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab919:

lab920:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab923
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab921
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab922

lab921:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab922:

lab923:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab926
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab924
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab925

lab924:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab925:

lab926:
    jmp lab928

lab927:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab928:

lab930:
    ; #load tag
    lea r9, [rel Bool_931]
    ; substitute (p0 := p0)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_931:
    jmp near Bool_931_True
    jmp near Bool_931_False

Bool_931_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab936
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab932
    ; ####increment refcount
    add qword [rax + 0], 1

lab932:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab933
    ; ####increment refcount
    add qword [r10 + 0], 1

lab933:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab934
    ; ####increment refcount
    add qword [r8 + 0], 1

lab934:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab935
    ; ####increment refcount
    add qword [rsi + 0], 1

lab935:
    jmp lab937

lab936:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab937:
    ; substitute (f := f)(ps := ps)(p := p)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Node[Pair[List[Assign], ConflictSet]]] = (p, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab949
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab950

lab949:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab947
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab940
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab938
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab939

lab938:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab939:

lab940:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab943
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab941
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab942

lab941:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab942:

lab943:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab946
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab944
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab945

lab944:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab945:

lab946:
    jmp lab948

lab947:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab948:

lab950:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_951]
    ; jump search_filter_
    jmp search_filter_

List_Node_Pair_List_Assign_ConflictSet_951:
    jmp near List_Node_Pair_List_Assign_ConflictSet_951_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_951_Cons

List_Node_Pair_List_Assign_ConflictSet_951_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab954
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab952
    ; ####increment refcount
    add qword [rsi + 0], 1

lab952:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab953
    ; ####increment refcount
    add qword [rax + 0], 1

lab953:
    jmp lab955

lab954:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab955:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (p := p)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_951_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab958
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab956
    ; ####increment refcount
    add qword [r10 + 0], 1

lab956:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab957
    ; ####increment refcount
    add qword [r8 + 0], 1

lab957:
    jmp lab959

lab958:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab959:
    ; substitute (a0 := a0)(p := p)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab971
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab972

lab971:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab969
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab962
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab960
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab961

lab960:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab961:

lab962:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab965
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab963
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab964

lab963:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab964:

lab965:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab968
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab966
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab967

lab966:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab967:

lab968:
    jmp lab970

lab969:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab970:

lab972:
    ; #load tag
    mov r9, 5
    ; substitute (p := p)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_931_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab977
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab973
    ; ####increment refcount
    add qword [rax + 0], 1

lab973:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab974
    ; ####increment refcount
    add qword [r10 + 0], 1

lab974:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab975
    ; ####increment refcount
    add qword [r8 + 0], 1

lab975:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab976
    ; ####increment refcount
    add qword [rsi + 0], 1

lab976:
    jmp lab978

lab977:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab978:
    ; substitute (f := f)(ps := ps)(a0 := a0);
    ; #erase p
    cmp rax, 0
    je lab981
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab979
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab980

lab979:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab980:

lab981:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump search_filter_
    jmp search_filter_

search_label_:
    ; substitute (a0 := a0)(n := n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_982:

Node_Pair_List_Assign_ConflictSet_982_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab985
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab983
    ; ####increment refcount
    add qword [r8 + 0], 1

lab983:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab984
    ; ####increment refcount
    add qword [rsi + 0], 1

lab984:
    jmp lab986

lab985:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab986:
    ; substitute (a0 := a0)(p := p);
    ; #erase cs
    cmp r8, 0
    je lab989
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab987
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab988

lab987:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab988:

lab989:
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_990:

Pair_List_Assign_ConflictSet_990_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab993
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab991
    ; ####increment refcount
    add qword [r8 + 0], 1

lab991:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab992
    ; ####increment refcount
    add qword [rsi + 0], 1

lab992:
    jmp lab994

lab993:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab994:
    ; substitute (a1 := a1)(b0 := b0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

search_fold_tree_:
    ; substitute (f := f)(a0 := a0)(n := n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_995:

Node_Pair_List_Assign_ConflictSet_995_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab998
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab996
    ; ####increment refcount
    add qword [r10 + 0], 1

lab996:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab997
    ; ####increment refcount
    add qword [r8 + 0], 1

lab997:
    jmp lab999

lab998:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab999:
    ; substitute (f0 := f)(c := c)(l := l)(a0 := a0)(f := f);
    ; #share f
    cmp rax, 0
    je lab1000
    ; ####increment refcount
    add qword [rax + 0], 1

lab1000:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a1: List[Node[Pair[List[Assign], ConflictSet]]] = (l, a0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1012
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1013

lab1012:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1010
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1003
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1001
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1002

lab1001:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1002:

lab1003:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1006
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1004
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1005

lab1004:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1005:

lab1006:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1009
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1007
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1008

lab1007:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1008:

lab1009:
    jmp lab1011

lab1010:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1011:

lab1013:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_1014]
    ; substitute (a1 := a1)(c := c)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x1: Fun[Node[Pair[List[Assign], ConflictSet]], Node[Pair[List[Assign], ConflictSet]]] = (f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1026
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1027

lab1026:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1024
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1017
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1015
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1016

lab1015:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1016:

lab1017:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1020
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1018
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1019

lab1018:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1019:

lab1020:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1023
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1021
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1022

lab1021:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1022:

lab1023:
    jmp lab1025

lab1024:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1025:

lab1027:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1028]
    ; substitute (x1 := x1)(c := c)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_map_
    jmp search_map_

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1028:

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1028_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1030
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1029
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1029:
    jmp lab1031

lab1030:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1031:
    ; substitute (f0 := f0)(x := x)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_fold_tree_
    jmp search_fold_tree_

List_Node_Pair_List_Assign_ConflictSet_1014:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1014_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1014_Cons

List_Node_Pair_List_Assign_ConflictSet_1014_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1035
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab1032
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1032:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab1033
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1033:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab1034
    ; ####increment refcount
    add qword [rax + 0], 1

lab1034:
    jmp lab1036

lab1035:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab1036:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (l := l)(x0 := x0)(a0 := a0)(f := f);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

List_Node_Pair_List_Assign_ConflictSet_1014_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1040
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1037
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1037:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1038
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1038:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1039
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1039:
    jmp lab1041

lab1040:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1041:
    ; substitute (f := f)(a0 := a0)(l := l)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1053
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1054

lab1053:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1051
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1044
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1042
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1043

lab1042:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1043:

lab1044:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1047
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1045
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1046

lab1045:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1046:

lab1047:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1050
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1048
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1049

lab1048:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1049:

lab1050:
    jmp lab1052

lab1051:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1052:

lab1054:
    ; #load tag
    mov r11, 5
    ; substitute (l := l)(x0 := x0)(a0 := a0)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke f Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

search_filter_tree_:
    ; substitute (a0 := a0)(n := n)(p := p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create f: Fun2[Pair[List[Assign], ConflictSet], List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]] = (p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1066
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1067

lab1066:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1064
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1057
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1055
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1056

lab1055:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1056:

lab1057:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1060
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1058
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1059

lab1058:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1059:

lab1060:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1063
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1061
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1062

lab1061:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1062:

lab1063:
    jmp lab1065

lab1064:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1065:

lab1067:
    ; #load tag
    lea r9, [rel Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1068]
    ; substitute (f := f)(n := n)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_fold_tree_
    jmp search_fold_tree_

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1068:

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_1068_Apply2:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab1070
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab1069
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1069:
    jmp lab1071

lab1070:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab1071:
    ; substitute (p := p)(cs := cs)(a1 := a1)(a := a);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a1, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1083
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1084

lab1083:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1081
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1074
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1072
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1073

lab1072:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1073:

lab1074:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1077
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1075
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1076

lab1075:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1076:

lab1077:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1080
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1078
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1079

lab1078:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1079:

lab1080:
    jmp lab1082

lab1081:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1082:

lab1084:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_1085]
    ; substitute (a2 := a2)(cs := cs)(p := p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x1: Fun[Node[Pair[List[Assign], ConflictSet]], Bool] = (p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1097
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1098

lab1097:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1095
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1088
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1086
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1087

lab1086:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1087:

lab1088:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1091
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1089
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1090

lab1089:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1090:

lab1091:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1094
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1092
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1093

lab1092:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1093:

lab1094:
    jmp lab1096

lab1095:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1096:

lab1098:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Bool_1099]
    ; substitute (x1 := x1)(cs := cs)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_filter_
    jmp search_filter_

Fun_Node_Pair_List_Assign_ConflictSet_Bool_1099:

Fun_Node_Pair_List_Assign_ConflictSet_Bool_1099_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1101
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1100
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1100:
    jmp lab1102

lab1101:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1102:
    ; create a4: Pair[List[Assign], ConflictSet] = (a3, p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1114
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1115

lab1114:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1112
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1105
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1103
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1104

lab1103:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1104:

lab1105:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1108
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1106
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1107

lab1106:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1107:

lab1108:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1110

lab1109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1110:

lab1111:
    jmp lab1113

lab1112:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1113:

lab1115:
    ; #load tag
    lea rdi, [rel Pair_List_Assign_ConflictSet_1116]
    ; jump search_label_
    jmp search_label_

Pair_List_Assign_ConflictSet_1116:

Pair_List_Assign_ConflictSet_1116_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1119
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1117
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1117:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1118
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1118:
    jmp lab1120

lab1119:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1120:
    ; substitute (p := p)(a3 := a3)(a6 := a6)(b0 := b0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: Pair[List[Assign], ConflictSet] = Tup(a6, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1132
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1133

lab1132:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1130
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1123
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1121
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1122

lab1121:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1122:

lab1123:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1126
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1124
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1125

lab1124:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1125:

lab1126:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1128

lab1127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1128:

lab1129:
    jmp lab1131

lab1130:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1131:

lab1133:
    ; #load tag
    mov r9, 0
    ; substitute (x2 := x2)(a3 := a3)(p := p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke p Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1085:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1085_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1085_Cons

List_Node_Pair_List_Assign_ConflictSet_1085_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1136
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1134
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1134:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1135
    ; ####increment refcount
    add qword [rax + 0], 1

lab1135:
    jmp lab1137

lab1136:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1137:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a := a)(x0 := x0)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1085_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1140
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1138
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1138:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1139
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1139:
    jmp lab1141

lab1140:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1141:
    ; substitute (a := a)(a1 := a1)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1153
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1154

lab1153:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1151
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1144
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1142
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1143

lab1142:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1143:

lab1144:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1147
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1145
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1146

lab1145:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1146:

lab1147:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1150
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1148
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1149

lab1148:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1149:

lab1150:
    jmp lab1152

lab1151:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1152:

lab1154:
    ; #load tag
    mov r9, 5
    ; substitute (a := a)(x0 := x0)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

search_prune_:
    ; substitute (a0 := a0)(n := n)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x0: Fun[Pair[List[Assign], ConflictSet], Bool] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1166
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1167

lab1166:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1164
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1157
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1155
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1156

lab1155:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1156:

lab1157:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1160
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1158
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1159

lab1158:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1159:

lab1160:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1163
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1161
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1162

lab1161:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1162:

lab1163:
    jmp lab1165

lab1164:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1165:

lab1167:
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_ConflictSet_Bool_1168]
    ; substitute (x0 := x0)(n := n)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_filter_tree_
    jmp search_filter_tree_

Fun_Pair_List_Assign_ConflictSet_Bool_1168:

Fun_Pair_List_Assign_ConflictSet_Bool_1168_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1170
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1169
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1169:
    jmp lab1171

lab1170:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1171:
    ; substitute (x := x)(f := f)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a2: Bool = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1183
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1184

lab1183:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1181
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1174
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1172
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1173

lab1172:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1173:

lab1174:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1177
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1175
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1176

lab1175:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1176:

lab1177:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1180
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1178
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1179

lab1178:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1179:

lab1180:
    jmp lab1182

lab1181:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1182:

lab1184:
    ; #load tag
    lea r9, [rel Bool_1185]
    ; substitute (x := x)(a2 := a2)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_1185:
    jmp near Bool_1185_True
    jmp near Bool_1185_False

Bool_1185_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1187
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1186
    ; ####increment refcount
    add qword [rax + 0], 1

lab1186:
    jmp lab1188

lab1187:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1188:
    ; let x1: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_1185_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1190
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1189
    ; ####increment refcount
    add qword [rax + 0], 1

lab1189:
    jmp lab1191

lab1190:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1191:
    ; let x1: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

search_map2_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_1192]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_1192:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1192_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1192_Cons

List_Node_Pair_List_Assign_ConflictSet_1192_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab1195
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1193
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1194

lab1193:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1194:

lab1195:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_1192_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1198
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1196
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1196:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1197
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1197:
    jmp lab1199

lab1198:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1199:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab1200
    ; ####increment refcount
    add qword [rax + 0], 1

lab1200:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: List[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1212
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1213

lab1212:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1210
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1203
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1201
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1202

lab1201:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1202:

lab1203:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1206
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1204
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1205

lab1204:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1205:

lab1206:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1209
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1207
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1208

lab1207:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1208:

lab1209:
    jmp lab1211

lab1210:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1211:

lab1213:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1214]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Pair_List_Assign_ConflictSet_1214:
    jmp near List_Pair_List_Assign_ConflictSet_1214_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1214_Cons

List_Pair_List_Assign_ConflictSet_1214_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1218
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab1215
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1215:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab1216
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1216:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab1217
    ; ####increment refcount
    add qword [rax + 0], 1

lab1217:
    jmp lab1219

lab1218:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab1219:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_search_map2_0_
    jmp lift_search_map2_0_

List_Pair_List_Assign_ConflictSet_1214_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1223
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1220
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1220:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1221
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1221:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1222
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1222:
    jmp lab1224

lab1223:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1224:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1236
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1237

lab1236:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1234
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1227
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1225
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1226

lab1225:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1226:

lab1227:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1230
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1228
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1229

lab1228:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1229:

lab1230:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1233
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1231
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1232

lab1231:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1232:

lab1233:
    jmp lab1235

lab1234:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1235:

lab1237:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_search_map2_0_
    jmp lift_search_map2_0_

lift_search_map2_0_:
    ; substitute (ps := ps)(f := f)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a2: List[List[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1249
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1250

lab1249:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1247
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1239

lab1238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1239:

lab1240:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1242

lab1241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1242:

lab1243:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1246
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1244
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1245

lab1244:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1245:

lab1246:
    jmp lab1248

lab1247:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1248:

lab1250:
    ; #load tag
    lea r9, [rel List_List_Pair_List_Assign_ConflictSet_1251]
    ; substitute (f := f)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_map2_
    jmp search_map2_

List_List_Pair_List_Assign_ConflictSet_1251:
    jmp near List_List_Pair_List_Assign_ConflictSet_1251_Nil
    jmp near List_List_Pair_List_Assign_ConflictSet_1251_Cons

List_List_Pair_List_Assign_ConflictSet_1251_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1254
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1252
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1252:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1253
    ; ####increment refcount
    add qword [rax + 0], 1

lab1253:
    jmp lab1255

lab1254:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1255:
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Pair_List_Assign_ConflictSet_1251_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1258
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1256
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1256:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1257
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1257:
    jmp lab1259

lab1258:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1259:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1271
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1272

lab1271:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1269
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1262
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1260
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1261

lab1260:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1261:

lab1262:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1265
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1263
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1264

lab1263:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1264:

lab1265:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1268
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1266
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1267

lab1266:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1267:

lab1268:
    jmp lab1270

lab1269:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1270:

lab1272:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_rev_loop_:
    ; substitute (a0 := a0)(l2 := l2)(l1 := l1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch l1 \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_1273]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_1273:
    jmp near List_Pair_List_Assign_ConflictSet_1273_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1273_Cons

List_Pair_List_Assign_ConflictSet_1273_Nil:
    ; switch l2 \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_1274]
    add rcx, rdi
    jmp rcx

List_Pair_List_Assign_ConflictSet_1274:
    jmp near List_Pair_List_Assign_ConflictSet_1274_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1274_Cons

List_Pair_List_Assign_ConflictSet_1274_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_List_Assign_ConflictSet_1274_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1277
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1275
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1275:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1276
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1276:
    jmp lab1278

lab1277:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1278:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_1273_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1281
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1279
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1279:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1280
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1280:
    jmp lab1282

lab1281:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1282:
    ; substitute (a0 := a0)(ps := ps)(p := p)(l2 := l2);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(p, l2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1294
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1295

lab1294:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1292
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1285
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1283
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1284

lab1283:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1284:

lab1285:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1288
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1286
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1287

lab1286:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1287:

lab1288:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1291
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1289
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1290

lab1289:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1290:

lab1291:
    jmp lab1293

lab1292:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1293:

lab1295:
    ; #load tag
    mov r9, 5
    ; substitute (ps := ps)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_rev_loop_
    jmp search_rev_loop_

search_rev_:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l := l)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_rev_loop_
    jmp search_rev_loop_

search_concat_loop_:
    ; substitute (a0 := a0)(acc := acc)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Pair_List_Assign_ConflictSet_1296]
    add rcx, r9
    jmp rcx

List_List_Pair_List_Assign_ConflictSet_1296:
    jmp near List_List_Pair_List_Assign_ConflictSet_1296_Nil
    jmp near List_List_Pair_List_Assign_ConflictSet_1296_Cons

List_List_Pair_List_Assign_ConflictSet_1296_Nil:
    ; substitute (acc := acc)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_rev_
    jmp search_rev_

List_List_Pair_List_Assign_ConflictSet_1296_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1299
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1297
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1297:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1298
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1298:
    jmp lab1300

lab1299:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1300:
    ; substitute (l := l)(acc := acc)(a0 := a0)(ls0 := ls0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Pair[List[Assign], ConflictSet]] = (a0, ls0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1312
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1313

lab1312:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1310
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1303
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1301
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1302

lab1301:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1302:

lab1303:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1306
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1304
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1305

lab1304:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1305:

lab1306:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1309
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1307
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1308

lab1307:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1308:

lab1309:
    jmp lab1311

lab1310:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1311:

lab1313:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1314]
    ; jump search_rev_loop_
    jmp search_rev_loop_

List_Pair_List_Assign_ConflictSet_1314:
    jmp near List_Pair_List_Assign_ConflictSet_1314_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1314_Cons

List_Pair_List_Assign_ConflictSet_1314_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1317
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1315
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1315:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1316
    ; ####increment refcount
    add qword [rax + 0], 1

lab1316:
    jmp lab1318

lab1317:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1318:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (ls0 := ls0)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_concat_loop_
    jmp search_concat_loop_

List_Pair_List_Assign_ConflictSet_1314_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1321
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1319
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1319:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1320
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1320:
    jmp lab1322

lab1321:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1322:
    ; substitute (ls0 := ls0)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1334
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1335

lab1334:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1332
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1325
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1323
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1324

lab1323:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1324:

lab1325:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1328
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1326
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1327

lab1326:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1327:

lab1328:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1331
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1329
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1330

lab1329:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1330:

lab1331:
    jmp lab1333

lab1332:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1333:

lab1335:
    ; #load tag
    mov r9, 5
    ; substitute (ls0 := ls0)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_concat_loop_
    jmp search_concat_loop_

search_concat_:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (ls := ls)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_concat_loop_
    jmp search_concat_loop_

search_leaves_:
    ; substitute (a0 := a0)(n := n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_1336:

Node_Pair_List_Assign_ConflictSet_1336_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1339
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1337
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1337:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1338
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1338:
    jmp lab1340

lab1339:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1340:
    ; switch cs \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_1341]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_1341:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1341_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1341_Cons

List_Node_Pair_List_Assign_ConflictSet_1341_Nil:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (leaf := leaf)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1341_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1344
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1342
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1342:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1343
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1343:
    jmp lab1345

lab1344:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1345:
    ; substitute (cs0 := cs0)(c := c)(a0 := a0);
    ; #erase leaf
    cmp rsi, 0
    je lab1348
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab1346
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab1347

lab1346:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab1347:

lab1348:
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rdi, r9
    mov r9, rdx
    mov rax, r10
    mov rdx, r11
    ; create a1: List[List[Pair[List[Assign], ConflictSet]]] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1360
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1361

lab1360:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1358
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1351
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1349
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1350

lab1349:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1350:

lab1351:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1354
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1352
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1353

lab1352:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1353:

lab1354:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1357
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1355
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1356

lab1355:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1356:

lab1357:
    jmp lab1359

lab1358:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1359:

lab1361:
    ; #load tag
    lea r9, [rel List_List_Pair_List_Assign_ConflictSet_1362]
    ; create x2: Fun[Node[Pair[List[Assign], ConflictSet]], List[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Node_Pair_List_Assign_ConflictSet_List_Pair_List_Assign_ConflictSet_1363]
    ; substitute (x2 := x2)(a1 := a1)(c := c)(cs0 := cs0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; let x3: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(c, cs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1375
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1376

lab1375:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1373
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1366
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1364
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1365

lab1364:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1365:

lab1366:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1369
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1367
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1368

lab1367:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1368:

lab1369:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1372
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1370
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1371

lab1370:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1371:

lab1372:
    jmp lab1374

lab1373:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1374:

lab1376:
    ; #load tag
    mov r9, 5
    ; substitute (x2 := x2)(x3 := x3)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_map2_
    jmp search_map2_

Fun_Node_Pair_List_Assign_ConflictSet_List_Pair_List_Assign_ConflictSet_1363:

Fun_Node_Pair_List_Assign_ConflictSet_List_Pair_List_Assign_ConflictSet_1363_Apply:
    ; jump search_leaves_
    jmp search_leaves_

List_List_Pair_List_Assign_ConflictSet_1362:
    jmp near List_List_Pair_List_Assign_ConflictSet_1362_Nil
    jmp near List_List_Pair_List_Assign_ConflictSet_1362_Cons

List_List_Pair_List_Assign_ConflictSet_1362_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1378
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1377
    ; ####increment refcount
    add qword [rax + 0], 1

lab1377:
    jmp lab1379

lab1378:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1379:
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_concat_
    jmp search_concat_

List_List_Pair_List_Assign_ConflictSet_1362_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1381
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1380
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1380:
    jmp lab1382

lab1381:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1382:
    ; substitute (a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1394
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1395

lab1394:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1392
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1385
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1383
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1384

lab1383:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1384:

lab1385:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1388
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1386
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1387

lab1386:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1387:

lab1388:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1391
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1389
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1390

lab1389:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1390:

lab1391:
    jmp lab1393

lab1392:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1393:

lab1395:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_concat_
    jmp search_concat_

search_map3_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_1396]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_1396:
    jmp near List_Pair_List_Assign_ConflictSet_1396_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1396_Cons

List_Pair_List_Assign_ConflictSet_1396_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab1399
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1397
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1398

lab1397:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1398:

lab1399:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_List_Assign_ConflictSet_1396_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1402
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1400
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1400:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1401
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1401:
    jmp lab1403

lab1402:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1403:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab1404
    ; ####increment refcount
    add qword [rax + 0], 1

lab1404:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: List[Assign] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1416
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1417

lab1416:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1414
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1407
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1405
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1406

lab1405:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1406:

lab1407:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1410
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1408
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1409

lab1408:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1409:

lab1410:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1413
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1411
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1412

lab1411:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1412:

lab1413:
    jmp lab1415

lab1414:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1415:

lab1417:
    ; #load tag
    lea r9, [rel List_Assign_1418]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Assign_1418:
    jmp near List_Assign_1418_Nil
    jmp near List_Assign_1418_Cons

List_Assign_1418_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1422
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab1419
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1419:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab1420
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1420:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab1421
    ; ####increment refcount
    add qword [rax + 0], 1

lab1421:
    jmp lab1423

lab1422:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab1423:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_search_map3_0_
    jmp lift_search_map3_0_

List_Assign_1418_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1427
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1424
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1424:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1425
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1425:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1426
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1426:
    jmp lab1428

lab1427:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1428:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1440
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1441

lab1440:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1438
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1431
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1429
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1430

lab1429:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1430:

lab1431:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1434
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1432
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1433

lab1432:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1433:

lab1434:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1437
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1435
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1436

lab1435:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1436:

lab1437:
    jmp lab1439

lab1438:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1439:

lab1441:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_search_map3_0_
    jmp lift_search_map3_0_

lift_search_map3_0_:
    ; substitute (ps := ps)(f := f)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a2: List[List[Assign]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1453
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1454

lab1453:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1451
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1444
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1442
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1443

lab1442:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1443:

lab1444:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1447
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1445
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1446

lab1445:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1446:

lab1447:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1450
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1448
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1449

lab1448:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1449:

lab1450:
    jmp lab1452

lab1451:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1452:

lab1454:
    ; #load tag
    lea r9, [rel List_List_Assign_1455]
    ; substitute (f := f)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_map3_
    jmp search_map3_

List_List_Assign_1455:
    jmp near List_List_Assign_1455_Nil
    jmp near List_List_Assign_1455_Cons

List_List_Assign_1455_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1458
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1456
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1456:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1457
    ; ####increment refcount
    add qword [rax + 0], 1

lab1457:
    jmp lab1459

lab1458:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1459:
    ; let x1: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_1455_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1462
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1460
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1460:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1461
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1461:
    jmp lab1463

lab1462:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1463:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1475
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1476

lab1475:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1473
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1466
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1464
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1465

lab1464:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1465:

lab1466:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1469
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1467
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1468

lab1467:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1468:

lab1469:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1472
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1470
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1471

lab1470:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1471:

lab1472:
    jmp lab1474

lab1473:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1474:

lab1476:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_filter2_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_1477]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_1477:
    jmp near List_Pair_List_Assign_ConflictSet_1477_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1477_Cons

List_Pair_List_Assign_ConflictSet_1477_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab1480
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1478
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1479

lab1478:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1479:

lab1480:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_List_Assign_ConflictSet_1477_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1483
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1481
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1481:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1482
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1482:
    jmp lab1484

lab1483:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1484:
    ; substitute (f0 := f)(p0 := p)(p := p)(ps := ps)(f := f)(a0 := a0);
    ; #share f
    cmp rax, 0
    je lab1485
    ; ####increment refcount
    add qword [rax + 0], 1

lab1485:
    ; #share p
    cmp r8, 0
    je lab1486
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1486:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; create a2: Bool = (p, ps, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1498
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1499

lab1498:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1496
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1489
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1487
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1488

lab1487:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1488:

lab1489:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1492
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1490
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1491

lab1490:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1491:

lab1492:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1495
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1493
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1494

lab1493:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1494:

lab1495:
    jmp lab1497

lab1496:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1497:

lab1499:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1511
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1512

lab1511:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1509
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1502
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1500
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1501

lab1500:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1501:

lab1502:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1505
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1503
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1504

lab1503:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1504:

lab1505:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1508
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1506
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1507

lab1506:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1507:

lab1508:
    jmp lab1510

lab1509:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1510:

lab1512:
    ; #load tag
    lea r9, [rel Bool_1513]
    ; substitute (p0 := p0)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_1513:
    jmp near Bool_1513_True
    jmp near Bool_1513_False

Bool_1513_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1518
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1514
    ; ####increment refcount
    add qword [rax + 0], 1

lab1514:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab1515
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1515:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab1516
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1516:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab1517
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1517:
    jmp lab1519

lab1518:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab1519:
    ; substitute (f := f)(ps := ps)(p := p)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Pair[List[Assign], ConflictSet]] = (p, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1531
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1532

lab1531:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1529
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1522
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1520
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1521

lab1520:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1521:

lab1522:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1525
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1523
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1524

lab1523:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1524:

lab1525:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1528
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1526
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1527

lab1526:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1527:

lab1528:
    jmp lab1530

lab1529:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1530:

lab1532:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1533]
    ; jump search_filter2_
    jmp search_filter2_

List_Pair_List_Assign_ConflictSet_1533:
    jmp near List_Pair_List_Assign_ConflictSet_1533_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1533_Cons

List_Pair_List_Assign_ConflictSet_1533_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1536
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1534
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1534:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1535
    ; ####increment refcount
    add qword [rax + 0], 1

lab1535:
    jmp lab1537

lab1536:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1537:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (p := p)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_1533_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1540
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1538
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1538:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1539
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1539:
    jmp lab1541

lab1540:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1541:
    ; substitute (a0 := a0)(p := p)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1553
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1554

lab1553:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1551
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1544
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1542
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1543

lab1542:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1543:

lab1544:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1546

lab1545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1546:

lab1547:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1550
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1548
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1549

lab1548:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1549:

lab1550:
    jmp lab1552

lab1551:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1552:

lab1554:
    ; #load tag
    mov r9, 5
    ; substitute (p := p)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_1513_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1559
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1555
    ; ####increment refcount
    add qword [rax + 0], 1

lab1555:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab1556
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1556:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab1557
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1557:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab1558
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1558:
    jmp lab1560

lab1559:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab1560:
    ; substitute (f := f)(ps := ps)(a0 := a0);
    ; #erase p
    cmp rax, 0
    je lab1563
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1561
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1562

lab1561:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1562:

lab1563:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump search_filter2_
    jmp search_filter2_

search_fst_:
    ; substitute (a0 := a0)(p := p);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_1564:

Pair_List_Assign_ConflictSet_1564_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1567
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1565
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1565:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1566
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1566:
    jmp lab1568

lab1567:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1568:
    ; substitute (a0 := a0)(l := l);
    ; #erase c
    cmp r8, 0
    je lab1571
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab1569
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab1570

lab1569:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab1570:

lab1571:
    ; switch l \{ ... \};
    lea rcx, [rel List_Assign_1572]
    add rcx, rdi
    jmp rcx

List_Assign_1572:
    jmp near List_Assign_1572_Nil
    jmp near List_Assign_1572_Cons

List_Assign_1572_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_1572_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1575
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1573
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1573:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1574
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1574:
    jmp lab1576

lab1575:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1576:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_snd_:
    ; substitute (a0 := a0)(p := p);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_1577:

Pair_List_Assign_ConflictSet_1577_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1580
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab1578
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1578:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab1579
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1579:
    jmp lab1581

lab1580:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab1581:
    ; substitute (a0 := a0)(c := c);
    ; #erase l
    cmp rsi, 0
    je lab1584
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab1582
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab1583

lab1582:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab1583:

lab1584:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_1585]
    add rcx, rdi
    jmp rcx

ConflictSet_1585:
    jmp near ConflictSet_1585_Known
    jmp near ConflictSet_1585_Unknown

ConflictSet_1585_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1587
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab1586
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1586:
    jmp lab1588

lab1587:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab1588:
    ; substitute (vs0 := vs0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Known
    add rdi, 0
    jmp rdi

ConflictSet_1585_Unknown:
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

search_:
    ; create x2: Fun[Pair[List[Assign], ConflictSet], List[Assign]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_List_Assign_ConflictSet_List_Assign_1589]
    ; create a2: List[Pair[List[Assign], ConflictSet]] = (a0, x2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1601
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1602

lab1601:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1599
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1592
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1590
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1591

lab1590:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1591:

lab1592:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1595
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1593
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1594

lab1593:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1594:

lab1595:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1598
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1596
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1597

lab1596:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1597:

lab1598:
    jmp lab1600

lab1599:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1600:

lab1602:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1603]
    ; create x4: Fun[Pair[List[Assign], ConflictSet], Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_List_Assign_ConflictSet_Bool_1604]
    ; create a5: List[Pair[List[Assign], ConflictSet]] = (a2, x4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1616
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1617

lab1616:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1614
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1607
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1605
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1606

lab1605:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1606:

lab1607:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1610
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1608
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1609

lab1608:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1609:

lab1610:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1613
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1611
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1612

lab1611:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1612:

lab1613:
    jmp lab1615

lab1614:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1615:

lab1617:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_1618]
    ; create a6: Node[Pair[List[Assign], ConflictSet]] = (a5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1630
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1631

lab1630:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1628
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1621
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1619
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1620

lab1619:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1620:

lab1621:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1624
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1622
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1623

lab1622:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1623:

lab1624:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1627
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1625
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1626

lab1625:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1626:

lab1627:
    jmp lab1629

lab1628:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1629:

lab1631:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_1632]
    ; create x7: Fun[Pair[List[Assign], ConflictSet], Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_List_Assign_ConflictSet_Bool_1633]
    ; create a9: Node[Pair[List[Assign], ConflictSet]] = (a6, x7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1645
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1646

lab1645:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1643
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1636
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1634
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1635

lab1634:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1635:

lab1636:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1639
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1637
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1638

lab1637:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1638:

lab1639:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1642
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1640
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1641

lab1640:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1641:

lab1642:
    jmp lab1644

lab1643:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1644:

lab1646:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_1647]
    ; substitute (csp0 := csp)(csp := csp)(a9 := a9)(labeler := labeler);
    ; #share csp
    cmp rsi, 0
    je lab1648
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1648:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov rdx, rdi
    ; create a10: Node[List[Assign]] = (csp, a9, labeler)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1660
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1661

lab1660:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1658
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1651
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1649
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1650

lab1649:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1650:

lab1651:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1654
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1652
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1653

lab1652:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1653:

lab1654:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1657
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1655
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1656

lab1655:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1656:

lab1657:
    jmp lab1659

lab1658:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1659:

lab1661:
    ; #load tag
    lea rdi, [rel Node_List_Assign_1662]
    ; jump mk_tree_
    jmp mk_tree_

Node_List_Assign_1662:

Node_List_Assign_1662_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1666
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1663
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1663:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1664
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1664:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1665
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1665:
    jmp lab1667

lab1666:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1667:
    ; substitute (labeler := labeler)(a9 := a9)(csp := csp)(lab2 := lab2)(children2 := children2);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x9: Node[List[Assign]] = Node(lab2, children2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1679
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1680

lab1679:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1677
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1670
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1668
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1669

lab1668:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1669:

lab1670:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1673
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1671
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1672

lab1671:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1672:

lab1673:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1676
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1674
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1675

lab1674:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1675:

lab1676:
    jmp lab1678

lab1677:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1678:

lab1680:
    ; #load tag
    mov r11, 0
    ; substitute (csp := csp)(x9 := x9)(a9 := a9)(labeler := labeler);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke labeler Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

Node_Pair_List_Assign_ConflictSet_1647:

Node_Pair_List_Assign_ConflictSet_1647_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1683
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1681
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1681:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1682
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1682:
    jmp lab1684

lab1683:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1684:
    ; substitute (x7 := x7)(a6 := a6)(lab1 := lab1)(children1 := children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x8: Node[Pair[List[Assign], ConflictSet]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1696
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1697

lab1696:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1694
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1687
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1685
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1686

lab1685:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1686:

lab1687:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1690
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1688
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1689

lab1688:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1689:

lab1690:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1693
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1691
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1692

lab1691:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1692:

lab1693:
    jmp lab1695

lab1694:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1695:

lab1697:
    ; #load tag
    mov r9, 0
    ; substitute (x7 := x7)(x8 := x8)(a6 := a6);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_prune_
    jmp search_prune_

Fun_Pair_List_Assign_ConflictSet_Bool_1633:

Fun_Pair_List_Assign_ConflictSet_Bool_1633_Apply:
    ; create a8: ConflictSet = (a7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1709
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1710

lab1709:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1707
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1700
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1698
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1699

lab1698:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1699:

lab1700:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1703
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1701
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1702

lab1701:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1702:

lab1703:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1706
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1704
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1705

lab1704:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1705:

lab1706:
    jmp lab1708

lab1707:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1708:

lab1710:
    ; #load tag
    lea rdi, [rel ConflictSet_1711]
    ; jump search_snd_
    jmp search_snd_

ConflictSet_1711:
    jmp near ConflictSet_1711_Known
    jmp near ConflictSet_1711_Unknown

ConflictSet_1711_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1713
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab1712
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1712:
    jmp lab1714

lab1713:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab1714:
    ; substitute (a7 := a7)(vs1 := vs1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x10: ConflictSet = Known(vs1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1726
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1727

lab1726:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1724
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1717
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1715
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1716

lab1715:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1716:

lab1717:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1720
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1718
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1719

lab1718:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1719:

lab1720:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1723
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1721
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1722

lab1721:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1722:

lab1723:
    jmp lab1725

lab1724:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1725:

lab1727:
    ; #load tag
    mov rdi, 0
    ; substitute (x10 := x10)(a7 := a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_conflict_
    jmp known_conflict_

ConflictSet_1711_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1729
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1728
    ; ####increment refcount
    add qword [rax + 0], 1

lab1728:
    jmp lab1730

lab1729:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1730:
    ; let x10: ConflictSet = Unknown();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x10 := x10)(a7 := a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_conflict_
    jmp known_conflict_

Node_Pair_List_Assign_ConflictSet_1632:

Node_Pair_List_Assign_ConflictSet_1632_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1732
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1731
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1731:
    jmp lab1733

lab1732:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1733:
    ; substitute (a5 := a5)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x6: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1745
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1746

lab1745:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1743
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1736
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1734
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1735

lab1734:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1735:

lab1736:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1739
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1737
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1738

lab1737:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1738:

lab1739:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1742
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1740
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1741

lab1740:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1741:

lab1742:
    jmp lab1744

lab1743:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1744:

lab1746:
    ; #load tag
    mov rdi, 0
    ; substitute (x6 := x6)(a5 := a5);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_leaves_
    jmp search_leaves_

List_Pair_List_Assign_ConflictSet_1618:
    jmp near List_Pair_List_Assign_ConflictSet_1618_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1618_Cons

List_Pair_List_Assign_ConflictSet_1618_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1749
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1747
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1747:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1748
    ; ####increment refcount
    add qword [rax + 0], 1

lab1748:
    jmp lab1750

lab1749:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1750:
    ; let x5: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x4 := x4)(x5 := x5)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_filter2_
    jmp search_filter2_

List_Pair_List_Assign_ConflictSet_1618_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1753
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1751
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1751:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1752
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1752:
    jmp lab1754

lab1753:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1754:
    ; substitute (x4 := x4)(a2 := a2)(a12 := a12)(as1 := as1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x5: List[Pair[List[Assign], ConflictSet]] = Cons(a12, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1766
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1767

lab1766:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1764
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1757
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1755
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1756

lab1755:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1756:

lab1757:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1760
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1758
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1759

lab1758:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1759:

lab1760:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1763
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1761
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1762

lab1761:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1762:

lab1763:
    jmp lab1765

lab1764:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1765:

lab1767:
    ; #load tag
    mov r9, 5
    ; substitute (x4 := x4)(x5 := x5)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_filter2_
    jmp search_filter2_

Fun_Pair_List_Assign_ConflictSet_Bool_1604:

Fun_Pair_List_Assign_ConflictSet_Bool_1604_Apply:
    ; create a4: ConflictSet = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1779
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1780

lab1779:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1777
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1770
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1768
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1769

lab1768:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1769:

lab1770:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1773
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1771
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1772

lab1771:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1772:

lab1773:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1776
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1774
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1775

lab1774:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1775:

lab1776:
    jmp lab1778

lab1777:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1778:

lab1780:
    ; #load tag
    lea rdi, [rel ConflictSet_1781]
    ; jump search_snd_
    jmp search_snd_

ConflictSet_1781:
    jmp near ConflictSet_1781_Known
    jmp near ConflictSet_1781_Unknown

ConflictSet_1781_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab1783
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab1782
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1782:
    jmp lab1784

lab1783:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab1784:
    ; substitute (a3 := a3)(vs0 := vs0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x11: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1796
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab1797

lab1796:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1794
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1787
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1785
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1786

lab1785:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1786:

lab1787:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1790
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1788
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1789

lab1788:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1789:

lab1790:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1793
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1791
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1792

lab1791:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1792:

lab1793:
    jmp lab1795

lab1794:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1795:

lab1797:
    ; #load tag
    mov rdi, 0
    ; substitute (x11 := x11)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_solution_
    jmp known_solution_

ConflictSet_1781_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1799
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab1798
    ; ####increment refcount
    add qword [rax + 0], 1

lab1798:
    jmp lab1800

lab1799:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab1800:
    ; let x11: ConflictSet = Unknown();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x11 := x11)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_solution_
    jmp known_solution_

List_Pair_List_Assign_ConflictSet_1603:
    jmp near List_Pair_List_Assign_ConflictSet_1603_Nil
    jmp near List_Pair_List_Assign_ConflictSet_1603_Cons

List_Pair_List_Assign_ConflictSet_1603_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1803
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1801
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1801:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1802
    ; ####increment refcount
    add qword [rax + 0], 1

lab1802:
    jmp lab1804

lab1803:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1804:
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x2 := x2)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_map3_
    jmp search_map3_

List_Pair_List_Assign_ConflictSet_1603_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1807
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1805
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1805:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1806
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1806:
    jmp lab1808

lab1807:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1808:
    ; substitute (x2 := x2)(a0 := a0)(a11 := a11)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Cons(a11, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1820
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1821

lab1820:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1818
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1811
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1809
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1810

lab1809:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1810:

lab1811:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1814
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1812
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1813

lab1812:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1813:

lab1814:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1817
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1815
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1816

lab1815:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1816:

lab1817:
    jmp lab1819

lab1818:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1819:

lab1821:
    ; #load tag
    mov r9, 5
    ; substitute (x2 := x2)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_map3_
    jmp search_map3_

Fun_Pair_List_Assign_ConflictSet_List_Assign_1589:

Fun_Pair_List_Assign_ConflictSet_List_Assign_1589_Apply:
    ; jump search_fst_
    jmp search_fst_

bt_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_List_Assign_1822]
    add rcx, r9
    jmp rcx

List_Node_List_Assign_1822:
    jmp near List_Node_List_Assign_1822_Nil
    jmp near List_Node_List_Assign_1822_Cons

List_Node_List_Assign_1822_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab1825
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab1823
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab1824

lab1823:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab1824:

lab1825:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_List_Assign_1822_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1828
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1826
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1826:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1827
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1827:
    jmp lab1829

lab1828:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1829:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab1830
    ; ####increment refcount
    add qword [rax + 0], 1

lab1830:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1842
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1843

lab1842:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1840
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1833
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1831
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1832

lab1831:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1832:

lab1833:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1835

lab1834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1835:

lab1836:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1839
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1837
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1838

lab1837:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1838:

lab1839:
    jmp lab1841

lab1840:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1841:

lab1843:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_1844]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_1844:

Node_Pair_List_Assign_ConflictSet_1844_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1848
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1845
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1845:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1846
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1846:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1847
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1847:
    jmp lab1849

lab1848:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1849:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1861
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1862

lab1861:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1859
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1852
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1850
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1851

lab1850:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1851:

lab1852:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1855
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1853
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1854

lab1853:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1854:

lab1855:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1858
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1856
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1857

lab1856:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1857:

lab1858:
    jmp lab1860

lab1859:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1860:

lab1862:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1874
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1875

lab1874:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1872
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1865
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1863
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1864

lab1863:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1864:

lab1865:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1868
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1866
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1867

lab1866:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1867:

lab1868:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1871
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1869
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1870

lab1869:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1870:

lab1871:
    jmp lab1873

lab1872:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1873:

lab1875:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_1876]
    ; jump bt_map_
    jmp bt_map_

List_Node_Pair_List_Assign_ConflictSet_1876:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1876_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1876_Cons

List_Node_Pair_List_Assign_ConflictSet_1876_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1879
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1877
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1877:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1878
    ; ####increment refcount
    add qword [rax + 0], 1

lab1878:
    jmp lab1880

lab1879:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1880:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1876_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1883
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1881
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1881:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1882
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1882:
    jmp lab1884

lab1883:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1884:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1896
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1897

lab1896:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1894
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1887
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1885
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1886

lab1885:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1886:

lab1887:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1890
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1888
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1889

lab1888:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1889:

lab1890:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1893
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1891
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1892

lab1891:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1892:

lab1893:
    jmp lab1895

lab1894:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1895:

lab1897:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bt_map_tree_:
    ; substitute (f := f)(a0 := a0)(n := n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_List_Assign_1898:

Node_List_Assign_1898_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1901
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1899
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1899:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1900
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1900:
    jmp lab1902

lab1901:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1902:
    ; substitute (f0 := f)(l := l)(a0 := a0)(ls := ls)(f := f);
    ; #share f
    cmp rax, 0
    je lab1903
    ; ####increment refcount
    add qword [rax + 0], 1

lab1903:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[List[Assign], ConflictSet] = (a0, ls, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1915
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1916

lab1915:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1913
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1906
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1904
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1905

lab1904:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1905:

lab1906:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1909
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1907
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1908

lab1907:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1908:

lab1909:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1912
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1910
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1911

lab1910:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1911:

lab1912:
    jmp lab1914

lab1913:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1914:

lab1916:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_1917]
    ; substitute (l := l)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_List_Assign_ConflictSet_1917:

Pair_List_Assign_ConflictSet_1917_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1921
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab1918
    ; ####increment refcount
    add qword [r12 + 0], 1

lab1918:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab1919
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1919:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab1920
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1920:
    jmp lab1922

lab1921:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab1922:
    ; substitute (f := f)(ls := ls)(a0 := a0)(a5 := a5)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1934
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab1935

lab1934:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1932
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1925
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1923
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1924

lab1923:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1924:

lab1925:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1928
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1926
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1927

lab1926:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1927:

lab1928:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1931
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1929
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1930

lab1929:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1930:

lab1931:
    jmp lab1933

lab1932:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1933:

lab1935:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1947
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1948

lab1947:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1945
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1938
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1936
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1937

lab1936:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1937:

lab1938:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1941
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1939
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1940

lab1939:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1940:

lab1941:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1944
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1942
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1943

lab1942:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1943:

lab1944:
    jmp lab1946

lab1945:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1946:

lab1948:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_1949]
    ; substitute (a2 := a2)(ls := ls)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x2: Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1961
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1962

lab1961:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1959
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1952
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1950
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1951

lab1950:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1951:

lab1952:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1955
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1953
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1954

lab1953:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1954:

lab1955:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1958
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1956
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1957

lab1956:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1957:

lab1958:
    jmp lab1960

lab1959:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1960:

lab1962:
    ; #load tag
    lea r9, [rel Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_1963]
    ; substitute (x2 := x2)(ls := ls)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bt_map_
    jmp bt_map_

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_1963:

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_1963_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1965
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab1964
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1964:
    jmp lab1966

lab1965:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab1966:
    ; substitute (f := f)(x := x)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bt_map_tree_
    jmp bt_map_tree_

List_Node_Pair_List_Assign_ConflictSet_1949:
    jmp near List_Node_Pair_List_Assign_ConflictSet_1949_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_1949_Cons

List_Node_Pair_List_Assign_ConflictSet_1949_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab1969
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab1967
    ; ####increment refcount
    add qword [rsi + 0], 1

lab1967:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab1968
    ; ####increment refcount
    add qword [rax + 0], 1

lab1968:
    jmp lab1970

lab1969:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab1970:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_1949_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab1973
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab1971
    ; ####increment refcount
    add qword [r10 + 0], 1

lab1971:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab1972
    ; ####increment refcount
    add qword [r8 + 0], 1

lab1972:
    jmp lab1974

lab1973:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab1974:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1986
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab1987

lab1986:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1984
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1977
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1975
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1976

lab1975:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1976:

lab1977:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1980
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1978
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1979

lab1978:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1979:

lab1980:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1983
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1981
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1982

lab1981:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1982:

lab1983:
    jmp lab1985

lab1984:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1985:

lab1987:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bt_:
    ; substitute (a0 := a0)(t := t)(csp := csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create f3: Fun[List[Assign], Pair[List[Assign], ConflictSet]] = (csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab1999
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2000

lab1999:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab1997
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab1990
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1988
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1989

lab1988:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1989:

lab1990:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab1993
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1991
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1992

lab1991:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1992:

lab1993:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab1996
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab1994
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab1995

lab1994:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab1995:

lab1996:
    jmp lab1998

lab1997:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab1998:

lab2000:
    ; #load tag
    lea r9, [rel Fun_List_Assign_Pair_List_Assign_ConflictSet_2001]
    ; substitute (f3 := f3)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bt_map_tree_
    jmp bt_map_tree_

Fun_List_Assign_Pair_List_Assign_ConflictSet_2001:

Fun_List_Assign_Pair_List_Assign_ConflictSet_2001_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2003
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab2002
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2002:
    jmp lab2004

lab2003:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab2004:
    ; substitute (s0 := s)(csp := csp)(a1 := a1)(s := s);
    ; #share s
    cmp rax, 0
    je lab2005
    ; ####increment refcount
    add qword [rax + 0], 1

lab2005:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a2: ConflictSet = (a1, s)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2017
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2018

lab2017:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2015
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2008
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2006
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2007

lab2006:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2007:

lab2008:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2011
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2009
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2010

lab2009:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2010:

lab2011:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2014
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2012
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2013

lab2012:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2013:

lab2014:
    jmp lab2016

lab2015:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2016:

lab2018:
    ; #load tag
    lea r9, [rel ConflictSet_2019]
    ; substitute (s00 := s0)(csp0 := csp)(a2 := a2)(s0 := s0)(csp := csp);
    ; #share csp
    cmp rsi, 0
    je lab2020
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2020:
    ; #share s0
    cmp rax, 0
    je lab2021
    ; ####increment refcount
    add qword [rax + 0], 1

lab2021:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov r12, rsi
    mov r13, rdi
    ; create a3: Option[Pair[i64, i64]] = (a2, s0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2033
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2034

lab2033:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2031
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2024
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2022
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2023

lab2022:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2023:

lab2024:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2027
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2025
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2026

lab2025:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2026:

lab2027:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2030
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2028
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2029

lab2028:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2029:

lab2030:
    jmp lab2032

lab2031:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2032:

lab2034:
    ; #load tag
    lea r9, [rel Option_Pair_i64_i64_2035]
    ; substitute (csp0 := csp0)(s00 := s00)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump earliest_inconsistency_
    jmp earliest_inconsistency_

Option_Pair_i64_i64_2035:
    jmp near Option_Pair_i64_i64_2035_None
    jmp near Option_Pair_i64_i64_2035_Some

Option_Pair_i64_i64_2035_None:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2039
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab2036
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2036:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab2037
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2037:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab2038
    ; ####increment refcount
    add qword [rax + 0], 1

lab2038:
    jmp lab2040

lab2039:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab2040:
    ; substitute (csp := csp)(s0 := s0)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump check_complete_
    jmp check_complete_

Option_Pair_i64_i64_2035_Some:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2044
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2041
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2041:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2042
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2042:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab2043
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2043:
    jmp lab2045

lab2044:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab2045:
    ; substitute (a2 := a2)(p := p);
    ; #erase csp
    cmp r10, 0
    je lab2048
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab2046
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab2047

lab2046:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab2047:

lab2048:
    ; #erase s0
    cmp r8, 0
    je lab2051
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2049
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2050

lab2049:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2050:

lab2051:
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_i64_i64_2052:

Pair_i64_i64_2052_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2053
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab2054

lab2053:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab2054:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; let x2: List[i64] = Cons(b, x1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2066
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2067

lab2066:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2064
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2057
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2055
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2056

lab2055:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2056:

lab2057:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2060
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2058
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2059

lab2058:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2059:

lab2060:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2063
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2061
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2062

lab2061:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2062:

lab2063:
    jmp lab2065

lab2064:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2065:

lab2067:
    ; #load tag
    mov r9, 5
    ; let x3: List[i64] = Cons(a, x2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2079
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2080

lab2079:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2077
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2070
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2068
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2069

lab2068:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2069:

lab2070:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2073
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2071
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2072

lab2071:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2072:

lab2073:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2076
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2074
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2075

lab2074:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2075:

lab2076:
    jmp lab2078

lab2077:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2078:

lab2080:
    ; #load tag
    mov rdi, 5
    ; substitute (x3 := x3)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a2 Known
    add rdi, 0
    jmp rdi

ConflictSet_2019:
    jmp near ConflictSet_2019_Known
    jmp near ConflictSet_2019_Unknown

ConflictSet_2019_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2083
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab2081
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2081:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab2082
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2082:
    jmp lab2084

lab2083:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab2084:
    ; substitute (s := s)(a1 := a1)(vs0 := vs0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2096
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2097

lab2096:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2094
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2087
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2085
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2086

lab2085:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2086:

lab2087:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2090
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2088
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2089

lab2088:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2089:

lab2090:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2093
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2091
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2092

lab2091:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2092:

lab2093:
    jmp lab2095

lab2094:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2095:

lab2097:
    ; #load tag
    mov r9, 0
    ; substitute (s := s)(x0 := x0)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a1 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

ConflictSet_2019_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2100
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2098
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2098:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2099
    ; ####increment refcount
    add qword [rax + 0], 1

lab2099:
    jmp lab2101

lab2100:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2101:
    ; let x0: ConflictSet = Unknown();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 5
    ; substitute (s := s)(x0 := x0)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

to_unknown_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_2102]
    add rcx, rdi
    jmp rcx

List_i64_2102:
    jmp near List_i64_2102_Nil
    jmp near List_i64_2102_Cons

List_i64_2102_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_2102_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2104
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab2103
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2103:
    mov rdi, [rsi + 40]
    jmp lab2105

lab2104:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab2105:
    ; substitute (a0 := a0)(t2 := t2);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; let x0: ConflictSet = Unknown();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 5
    ; substitute (t2 := t2)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: List[ConflictSet] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2117
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2118

lab2117:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2115
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2108
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2106
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2107

lab2106:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2107:

lab2108:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2110

lab2109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2110:

lab2111:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2114
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2112
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2113

lab2112:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2113:

lab2114:
    jmp lab2116

lab2115:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2116:

lab2118:
    ; #load tag
    lea rdi, [rel List_ConflictSet_2119]
    ; jump to_unknown_
    jmp to_unknown_

List_ConflictSet_2119:
    jmp near List_ConflictSet_2119_Nil
    jmp near List_ConflictSet_2119_Cons

List_ConflictSet_2119_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2122
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2120
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2120:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2121
    ; ####increment refcount
    add qword [rax + 0], 1

lab2121:
    jmp lab2123

lab2122:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2123:
    ; let x1: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_ConflictSet_2119_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2126
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2124
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2124:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2125
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2125:
    jmp lab2127

lab2126:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2127:
    ; substitute (x0 := x0)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[ConflictSet] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2139
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2140

lab2139:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2137
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2130
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2128
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2129

lab2128:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2129:

lab2130:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2133
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2131
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2132

lab2131:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2132:

lab2133:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2136
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2134
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2135

lab2134:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2135:

lab2136:
    jmp lab2138

lab2137:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2138:

lab2140:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

n_unknown_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_2141]
    add rcx, rdi
    jmp rcx

List_i64_2141:
    jmp near List_i64_2141_Nil
    jmp near List_i64_2141_Cons

List_i64_2141_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_2141_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2143
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab2142
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2142:
    mov rdi, [rsi + 40]
    jmp lab2144

lab2143:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab2144:
    ; substitute (n00 := n0)(n0 := n0)(t1 := t1)(a0 := a0);
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rdx, rdi
    ; create a1: List[ConflictSet] = (n0, t1, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2156
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2157

lab2156:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2154
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2147
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2145
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2146

lab2145:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2146:

lab2147:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2150
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2148
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2149

lab2148:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2149:

lab2150:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2153
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2151
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2152

lab2151:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2152:

lab2153:
    jmp lab2155

lab2154:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2155:

lab2157:
    ; #load tag
    lea rdi, [rel List_ConflictSet_2158]
    ; create a2: List[i64] = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2170
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2171

lab2170:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2168
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2161
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2159
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2160

lab2159:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2160:

lab2161:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2164
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2162
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2163

lab2162:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2163:

lab2164:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2167
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2165
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2166

lab2165:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2166:

lab2167:
    jmp lab2169

lab2168:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2169:

lab2171:
    ; #load tag
    lea rdi, [rel List_i64_2172]
    ; lit x2 <- 1;
    mov r9, 1
    ; substitute (x2 := x2)(n00 := n00)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_2172:
    jmp near List_i64_2172_Nil
    jmp near List_i64_2172_Cons

List_i64_2172_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2174
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab2173
    ; ####increment refcount
    add qword [rax + 0], 1

lab2173:
    jmp lab2175

lab2174:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab2175:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump to_unknown_
    jmp to_unknown_

List_i64_2172_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2177
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab2176
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2176:
    jmp lab2178

lab2177:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab2178:
    ; substitute (a1 := a1)(a6 := a6)(as2 := as2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; let x1: List[i64] = Cons(a6, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2190
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2191

lab2190:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2188
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2181
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2179
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2180

lab2179:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2180:

lab2181:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2184
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2182
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2183

lab2182:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2183:

lab2184:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2187
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2185
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2186

lab2185:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2186:

lab2187:
    jmp lab2189

lab2188:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2189:

lab2191:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump to_unknown_
    jmp to_unknown_

List_ConflictSet_2158:
    jmp near List_ConflictSet_2158_Nil
    jmp near List_ConflictSet_2158_Cons

List_ConflictSet_2158_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2194
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab2192
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2192:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab2193
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2193:
    mov rdx, [rax + 24]
    jmp lab2195

lab2194:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab2195:
    ; let x0: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(n0 := n0)(t1 := t1)(x0 := x0);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump lift_n_unknown_0_
    jmp lift_n_unknown_0_

List_ConflictSet_2158_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2198
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab2196
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2196:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab2197
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2197:
    mov r9, [r8 + 24]
    jmp lab2199

lab2198:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab2199:
    ; substitute (a0 := a0)(t1 := t1)(n0 := n0)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[ConflictSet] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2211
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2212

lab2211:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2209
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2202
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2200
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2201

lab2200:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2201:

lab2202:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2205
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2203
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2204

lab2203:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2204:

lab2205:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2208
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2206
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2207

lab2206:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2207:

lab2208:
    jmp lab2210

lab2209:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2210:

lab2212:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(n0 := n0)(t1 := t1)(x0 := x0);
    ; #move variables
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_n_unknown_0_
    jmp lift_n_unknown_0_

lift_n_unknown_0_:
    ; substitute (t1 := t1)(n0 := n0)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a3: List[List[ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2224
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2225

lab2224:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2222
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2215
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2213
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2214

lab2213:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2214:

lab2215:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2218
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2216
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2217

lab2216:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2217:

lab2218:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2221
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2219
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2220

lab2219:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2220:

lab2221:
    jmp lab2223

lab2222:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2223:

lab2225:
    ; #load tag
    lea r9, [rel List_List_ConflictSet_2226]
    ; jump n_unknown_
    jmp n_unknown_

List_List_ConflictSet_2226:
    jmp near List_List_ConflictSet_2226_Nil
    jmp near List_List_ConflictSet_2226_Cons

List_List_ConflictSet_2226_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2229
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2227
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2227:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2228
    ; ####increment refcount
    add qword [rax + 0], 1

lab2228:
    jmp lab2230

lab2229:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2230:
    ; let x3: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_2226_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2233
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2231
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2231:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2232
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2232:
    jmp lab2234

lab2233:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2234:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2246
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2247

lab2246:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2244
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2237
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2235
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2236

lab2235:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2236:

lab2237:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2239

lab2238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2239:

lab2240:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2242

lab2241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2242:

lab2243:
    jmp lab2245

lab2244:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2245:

lab2247:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

empty_table_:
    ; substitute (a0 := a0)(csp := csp);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_2248:

CSP_2248_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2250
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2249
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2249:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab2251

lab2250:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab2251:
    ; substitute (a0 := a0)(vars := vars)(vals := vals);
    ; #erase rel
    cmp r10, 0
    je lab2254
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab2252
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab2253

lab2252:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab2253:

lab2254:
    ; let x0: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (vals := vals)(vars := vars)(a0 := a0)(x0 := x0);
    ; #move variables
    mov r8, rax
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[List[ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2266
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2267

lab2266:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2264
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2257
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2255
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2256

lab2255:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2256:

lab2257:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2259

lab2258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2259:

lab2260:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2263
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2261
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2262

lab2261:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2262:

lab2263:
    jmp lab2265

lab2264:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2265:

lab2267:
    ; #load tag
    lea r9, [rel List_List_ConflictSet_2268]
    ; substitute (vars := vars)(vals := vals)(a1 := a1);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a2: List[i64] = (vals, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2280
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2281

lab2280:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2278
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2271
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2269
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2270

lab2269:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2270:

lab2271:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2274
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2272
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2273

lab2272:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2273:

lab2274:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2277
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2275
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2276

lab2275:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2276:

lab2277:
    jmp lab2279

lab2278:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2279:

lab2281:
    ; #load tag
    lea rdi, [rel List_i64_2282]
    ; lit x3 <- 1;
    mov r9, 1
    ; substitute (x3 := x3)(vars := vars)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_2282:
    jmp near List_i64_2282_Nil
    jmp near List_i64_2282_Cons

List_i64_2282_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2284
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2283
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2283:
    mov rdx, [rax + 40]
    jmp lab2285

lab2284:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab2285:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x2 := x2)(vals := vals)(a1 := a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump n_unknown_
    jmp n_unknown_

List_i64_2282_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2287
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2286
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2286:
    mov r9, [r8 + 40]
    jmp lab2288

lab2287:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2288:
    ; substitute (a1 := a1)(vals := vals)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x2: List[i64] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2300
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2301

lab2300:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2298
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2291
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2289
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2290

lab2289:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2290:

lab2291:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2294
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2292
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2293

lab2292:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2293:

lab2294:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2297
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2295
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2296

lab2295:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2296:

lab2297:
    jmp lab2299

lab2298:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2299:

lab2301:
    ; #load tag
    mov r9, 5
    ; substitute (x2 := x2)(vals := vals)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump n_unknown_
    jmp n_unknown_

List_List_ConflictSet_2268:
    jmp near List_List_ConflictSet_2268_Nil
    jmp near List_List_ConflictSet_2268_Cons

List_List_ConflictSet_2268_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2304
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2302
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2302:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2303
    ; ####increment refcount
    add qword [rax + 0], 1

lab2303:
    jmp lab2305

lab2304:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2305:
    ; let x1: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_2268_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2308
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2306
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2306:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2307
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2307:
    jmp lab2309

lab2308:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2309:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2321
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2322

lab2321:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2319
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2312
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2310
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2311

lab2310:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2311:

lab2312:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2315
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2313
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2314

lab2313:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2314:

lab2315:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2318
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2316
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2317

lab2316:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2317:

lab2318:
    jmp lab2320

lab2319:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2320:

lab2322:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

to_pair_:
    ; substitute (a0 := a0)(varrr := varrr)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_2323]
    add rcx, r9
    jmp rcx

List_i64_2323:
    jmp near List_i64_2323_Nil
    jmp near List_i64_2323_Cons

List_i64_2323_Nil:
    ; substitute (a0 := a0);
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_2323_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2325
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2324
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2324:
    mov r9, [r8 + 40]
    jmp lab2326

lab2325:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2326:
    ; substitute (a0 := a0)(varrr := varrr)(t2 := t2)(varrr0 := varrr)(valll := valll);
    ; #move variables
    mov r13, r9
    mov r9, r11
    mov r11, rdi
    mov r8, r10
    ; let x0: Pair[i64, i64] = Tup(varrr0, valll);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2338
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2339

lab2338:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2336
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2329
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2327
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2328

lab2327:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2328:

lab2329:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2332
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2330
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2331

lab2330:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2331:

lab2332:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2335
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2333
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2334

lab2333:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2334:

lab2335:
    jmp lab2337

lab2336:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2337:

lab2339:
    ; #load tag
    mov r11, 0
    ; substitute (t2 := t2)(varrr := varrr)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a1: List[Pair[i64, i64]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2351
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2352

lab2351:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2349
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2342
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2340
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2341

lab2340:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2341:

lab2342:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2345
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2343
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2344

lab2343:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2344:

lab2345:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2348
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2346
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2347

lab2346:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2347:

lab2348:
    jmp lab2350

lab2349:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2350:

lab2352:
    ; #load tag
    lea r9, [rel List_Pair_i64_i64_2353]
    ; jump to_pair_
    jmp to_pair_

List_Pair_i64_i64_2353:
    jmp near List_Pair_i64_i64_2353_Nil
    jmp near List_Pair_i64_i64_2353_Cons

List_Pair_i64_i64_2353_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2356
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2354
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2354:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2355
    ; ####increment refcount
    add qword [rax + 0], 1

lab2355:
    jmp lab2357

lab2356:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2357:
    ; let x1: List[Pair[i64, i64]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_i64_i64_2353_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2360
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2358
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2358:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2359
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2359:
    jmp lab2361

lab2360:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2361:
    ; substitute (x0 := x0)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Pair[i64, i64]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2373
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2374

lab2373:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2371
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2364
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2362
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2363

lab2362:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2363:

lab2364:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2367
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2365
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2366

lab2365:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2366:

lab2367:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2370
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2368
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2369

lab2368:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2369:

lab2370:
    jmp lab2372

lab2371:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2372:

lab2374:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

n_pairs_:
    ; substitute (a0 := a0)(n := n)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_2375]
    add rcx, r9
    jmp rcx

List_i64_2375:
    jmp near List_i64_2375_Nil
    jmp near List_i64_2375_Cons

List_i64_2375_Nil:
    ; substitute (a0 := a0);
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_2375_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2377
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2376
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2376:
    mov r9, [r8 + 40]
    jmp lab2378

lab2377:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2378:
    ; substitute (varrr := varrr)(n0 := n)(n := n)(t1 := t1)(a0 := a0);
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rdx, r9
    mov r9, rdi
    ; create a1: List[Pair[i64, i64]] = (n, t1, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2390
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2391

lab2390:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2388
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2381
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2379
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2380

lab2379:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2380:

lab2381:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2384
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2382
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2383

lab2382:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2383:

lab2384:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2387
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2385
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2386

lab2385:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2386:

lab2387:
    jmp lab2389

lab2388:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2389:

lab2391:
    ; #load tag
    lea r9, [rel List_Pair_i64_i64_2392]
    ; substitute (n0 := n0)(varrr := varrr)(a1 := a1);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a2: List[i64] = (varrr, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2404
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2405

lab2404:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2402
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2395
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2393
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2394

lab2393:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2394:

lab2395:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2398
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2396
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2397

lab2396:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2397:

lab2398:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2401
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2399
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2400

lab2399:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2400:

lab2401:
    jmp lab2403

lab2402:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2403:

lab2405:
    ; #load tag
    lea rdi, [rel List_i64_2406]
    ; lit x2 <- 1;
    mov r9, 1
    ; substitute (x2 := x2)(n0 := n0)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_2406:
    jmp near List_i64_2406_Nil
    jmp near List_i64_2406_Cons

List_i64_2406_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2408
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2407
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2407:
    mov rdx, [rax + 40]
    jmp lab2409

lab2408:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab2409:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(varrr := varrr)(a1 := a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump to_pair_
    jmp to_pair_

List_i64_2406_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2411
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2410
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2410:
    mov r9, [r8 + 40]
    jmp lab2412

lab2411:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2412:
    ; substitute (a1 := a1)(varrr := varrr)(a6 := a6)(as2 := as2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x1: List[i64] = Cons(a6, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2424
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2425

lab2424:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2422
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2415
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2413
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2414

lab2413:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2414:

lab2415:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2418
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2416
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2417

lab2416:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2417:

lab2418:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2421
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2419
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2420

lab2419:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2420:

lab2421:
    jmp lab2423

lab2422:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2423:

lab2425:
    ; #load tag
    mov r9, 5
    ; substitute (x1 := x1)(varrr := varrr)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump to_pair_
    jmp to_pair_

List_Pair_i64_i64_2392:
    jmp near List_Pair_i64_i64_2392_Nil
    jmp near List_Pair_i64_i64_2392_Cons

List_Pair_i64_i64_2392_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2428
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab2426
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2426:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab2427
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2427:
    mov rdx, [rax + 24]
    jmp lab2429

lab2428:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab2429:
    ; let x0: List[Pair[i64, i64]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(n := n)(t1 := t1)(x0 := x0);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump lift_n_pairs_0_
    jmp lift_n_pairs_0_

List_Pair_i64_i64_2392_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2432
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab2430
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2430:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab2431
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2431:
    mov r9, [r8 + 24]
    jmp lab2433

lab2432:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab2433:
    ; substitute (a0 := a0)(t1 := t1)(n := n)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Pair[i64, i64]] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2445
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2446

lab2445:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2443
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2436
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2434
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2435

lab2434:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2435:

lab2436:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2438

lab2437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2438:

lab2439:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2442
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2440
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2441

lab2440:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2441:

lab2442:
    jmp lab2444

lab2443:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2444:

lab2446:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(n := n)(t1 := t1)(x0 := x0);
    ; #move variables
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_n_pairs_0_
    jmp lift_n_pairs_0_

lift_n_pairs_0_:
    ; substitute (t1 := t1)(n := n)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a3: List[List[Pair[i64, i64]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2458
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2459

lab2458:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2456
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2449
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2447
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2448

lab2447:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2448:

lab2449:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2452
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2450
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2451

lab2450:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2451:

lab2452:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2455
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2453
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2454

lab2453:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2454:

lab2455:
    jmp lab2457

lab2456:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2457:

lab2459:
    ; #load tag
    lea r9, [rel List_List_Pair_i64_i64_2460]
    ; jump n_pairs_
    jmp n_pairs_

List_List_Pair_i64_i64_2460:
    jmp near List_List_Pair_i64_i64_2460_Nil
    jmp near List_List_Pair_i64_i64_2460_Cons

List_List_Pair_i64_i64_2460_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2463
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2461
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2461:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2462
    ; ####increment refcount
    add qword [rax + 0], 1

lab2462:
    jmp lab2464

lab2463:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2464:
    ; let x3: List[List[Pair[i64, i64]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Pair_i64_i64_2460_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2467
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2465
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2465:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2466
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2466:
    jmp lab2468

lab2467:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2468:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[List[Pair[i64, i64]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2480
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2481

lab2480:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2478
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2471
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2469
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2470

lab2469:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2470:

lab2471:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2474
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2472
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2473

lab2472:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2473:

lab2474:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2477
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2475
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2476

lab2475:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2476:

lab2477:
    jmp lab2479

lab2478:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2479:

lab2481:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x3 := x3)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_zip_with_:
    ; substitute (f := f)(a0 := a0)(y := y)(x := x);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch x \{ ... \};
    lea rcx, [rel List_ConflictSet_2482]
    add rcx, r11
    jmp rcx

List_ConflictSet_2482:
    jmp near List_ConflictSet_2482_Nil
    jmp near List_ConflictSet_2482_Cons

List_ConflictSet_2482_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab2485
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2483
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2484

lab2483:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2484:

lab2485:
    ; #erase y
    cmp r8, 0
    je lab2488
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2486
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2487

lab2486:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2487:

lab2488:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_2482_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2491
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab2489
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2489:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab2490
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2490:
    jmp lab2492

lab2491:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab2492:
    ; substitute (f := f)(a0 := a0)(cs := cs)(c := c)(y := y);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    ; switch y \{ ... \};
    lea rcx, [rel List_Pair_i64_i64_2493]
    add rcx, r13
    jmp rcx

List_Pair_i64_i64_2493:
    jmp near List_Pair_i64_i64_2493_Nil
    jmp near List_Pair_i64_i64_2493_Cons

List_Pair_i64_i64_2493_Nil:
    ; substitute (a0 := a0);
    ; #erase c
    cmp r10, 0
    je lab2496
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab2494
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab2495

lab2494:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab2495:

lab2496:
    ; #erase cs
    cmp r8, 0
    je lab2499
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2497
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2498

lab2497:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2498:

lab2499:
    ; #erase f
    cmp rax, 0
    je lab2502
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2500
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2501

lab2500:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2501:

lab2502:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_i64_i64_2493_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab2505
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab2503
    ; ####increment refcount
    add qword [r14 + 0], 1

lab2503:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab2504
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2504:
    jmp lab2506

lab2505:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab2506:
    ; substitute (f0 := f)(p := p)(c := c)(cs := cs)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab2507
    ; ####increment refcount
    add qword [rax + 0], 1

lab2507:
    ; #move variables
    mov [rsp + 2032], rax
    mov [rsp + 2024], rdx
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; create a1: ConflictSet = (cs, a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2519
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2520

lab2519:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2517
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2510
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2508
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2509

lab2508:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2509:

lab2510:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2513
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2511
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2512

lab2511:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2512:

lab2513:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2516
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2514
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2515

lab2514:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2515:

lab2516:
    jmp lab2518

lab2517:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2518:

lab2520:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2532
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2533

lab2532:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2530
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2523
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2521
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2522

lab2521:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2522:

lab2523:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2526
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2524
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2525

lab2524:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2525:

lab2526:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2529
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2527
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2528

lab2527:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2528:

lab2529:
    jmp lab2531

lab2530:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2531:

lab2533:
    ; #load tag
    lea r11, [rel ConflictSet_2534]
    ; substitute (c := c)(p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke f0 Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

ConflictSet_2534:
    jmp near ConflictSet_2534_Known
    jmp near ConflictSet_2534_Unknown

ConflictSet_2534_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2539
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab2535
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2535:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab2536
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2536:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab2537
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2537:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab2538
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2538:
    jmp lab2540

lab2539:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab2540:
    ; substitute (f := f)(cs := cs)(a0 := a0)(ps := ps)(vs0 := vs0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2552
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2553

lab2552:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2550
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2543
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2541
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2542

lab2541:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2542:

lab2543:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2546
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2544
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2545

lab2544:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2545:

lab2546:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2549
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2547
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2548

lab2547:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2548:

lab2549:
    jmp lab2551

lab2550:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2551:

lab2553:
    ; #load tag
    mov r13, 0
    ; substitute (a0 := a0)(cs := cs)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_fill_zip_with_0_
    jmp lift_fill_zip_with_0_

ConflictSet_2534_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2558
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2554
    ; ####increment refcount
    add qword [rax + 0], 1

lab2554:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2555
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2555:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2556
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2556:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab2557
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2557:
    jmp lab2559

lab2558:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab2559:
    ; let x0: ConflictSet = Unknown();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 5
    ; substitute (a0 := a0)(cs := cs)(f := f)(ps := ps)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; jump lift_fill_zip_with_0_
    jmp lift_fill_zip_with_0_

lift_fill_zip_with_0_:
    ; substitute (ps := ps)(cs := cs)(f := f)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a2: List[ConflictSet] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2571
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2572

lab2571:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2569
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2562
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2560
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2561

lab2560:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2561:

lab2562:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2565
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2563
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2564

lab2563:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2564:

lab2565:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2568
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2566
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2567

lab2566:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2567:

lab2568:
    jmp lab2570

lab2569:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2570:

lab2572:
    ; #load tag
    lea r11, [rel List_ConflictSet_2573]
    ; substitute (f := f)(cs := cs)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump fill_zip_with_
    jmp fill_zip_with_

List_ConflictSet_2573:
    jmp near List_ConflictSet_2573_Nil
    jmp near List_ConflictSet_2573_Cons

List_ConflictSet_2573_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2576
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2574
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2574:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2575
    ; ####increment refcount
    add qword [rax + 0], 1

lab2575:
    jmp lab2577

lab2576:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2577:
    ; let x1: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_ConflictSet_2573_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2580
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2578
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2578:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2579
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2579:
    jmp lab2581

lab2580:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2581:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[ConflictSet] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2593
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2594

lab2593:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2591
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2584
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2582
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2583

lab2582:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2583:

lab2584:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2587
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2585
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2586

lab2585:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2586:

lab2587:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2590
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2588
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2589

lab2588:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2589:

lab2590:
    jmp lab2592

lab2591:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2592:

lab2594:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_zip_with2_:
    ; substitute (f := f)(a0 := a0)(ls := ls)(tbl := tbl);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch tbl \{ ... \};
    lea rcx, [rel List_List_ConflictSet_2595]
    add rcx, r11
    jmp rcx

List_List_ConflictSet_2595:
    jmp near List_List_ConflictSet_2595_Nil
    jmp near List_List_ConflictSet_2595_Cons

List_List_ConflictSet_2595_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab2598
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2596
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2597

lab2596:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2597:

lab2598:
    ; #erase ls
    cmp r8, 0
    je lab2601
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2599
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2600

lab2599:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2600:

lab2601:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_2595_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2604
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab2602
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2602:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab2603
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2603:
    jmp lab2605

lab2604:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab2605:
    ; substitute (f := f)(a0 := a0)(css := css)(cs := cs)(ls := ls);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Pair_i64_i64_2606]
    add rcx, r13
    jmp rcx

List_List_Pair_i64_i64_2606:
    jmp near List_List_Pair_i64_i64_2606_Nil
    jmp near List_List_Pair_i64_i64_2606_Cons

List_List_Pair_i64_i64_2606_Nil:
    ; substitute (a0 := a0);
    ; #erase cs
    cmp r10, 0
    je lab2609
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab2607
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab2608

lab2607:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab2608:

lab2609:
    ; #erase css
    cmp r8, 0
    je lab2612
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab2610
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab2611

lab2610:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab2611:

lab2612:
    ; #erase f
    cmp rax, 0
    je lab2615
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2613
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2614

lab2613:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2614:

lab2615:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Pair_i64_i64_2606_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab2618
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab2616
    ; ####increment refcount
    add qword [r14 + 0], 1

lab2616:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab2617
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2617:
    jmp lab2619

lab2618:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab2619:
    ; substitute (f0 := f)(ps := ps)(cs := cs)(css := css)(a0 := a0)(pss := pss)(f := f);
    ; #share f
    cmp rax, 0
    je lab2620
    ; ####increment refcount
    add qword [rax + 0], 1

lab2620:
    ; #move variables
    mov [rsp + 2032], rax
    mov [rsp + 2024], rdx
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; create a1: List[ConflictSet] = (css, a0, pss, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2632
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2633

lab2632:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2630
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2623
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2621
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2622

lab2621:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2622:

lab2623:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2626
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2624
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2625

lab2624:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2625:

lab2626:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2629
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2627
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2628

lab2627:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2628:

lab2629:
    jmp lab2631

lab2630:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2631:

lab2633:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2645
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2646

lab2645:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2643
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2636
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2634
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2635

lab2634:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2635:

lab2636:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2639
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2637
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2638

lab2637:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2638:

lab2639:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2642
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2640
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2641

lab2640:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2641:

lab2642:
    jmp lab2644

lab2643:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2644:

lab2646:
    ; #load tag
    lea r11, [rel List_ConflictSet_2647]
    ; substitute (cs := cs)(ps := ps)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke f0 Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

List_ConflictSet_2647:
    jmp near List_ConflictSet_2647_Nil
    jmp near List_ConflictSet_2647_Cons

List_ConflictSet_2647_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2652
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2648
    ; ####increment refcount
    add qword [rax + 0], 1

lab2648:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2649
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2649:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2650
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2650:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab2651
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2651:
    jmp lab2653

lab2652:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab2653:
    ; let x0: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (a0 := a0)(css := css)(f := f)(pss := pss)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; jump lift_fill_zip_with2_0_
    jmp lift_fill_zip_with2_0_

List_ConflictSet_2647_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2658
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2654
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2654:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab2655
    ; ####increment refcount
    add qword [r14 + 0], 1

lab2655:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab2656
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2656:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab2657
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2657:
    jmp lab2659

lab2658:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab2659:
    ; substitute (f := f)(pss := pss)(css := css)(a0 := a0)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r14
    mov r14, rsi
    mov rsi, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: List[ConflictSet] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2671
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2672

lab2671:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2669
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2662
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2660
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2661

lab2660:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2661:

lab2662:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2665
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2663
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2664

lab2663:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2664:

lab2665:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2668
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2666
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2667

lab2666:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2667:

lab2668:
    jmp lab2670

lab2669:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2670:

lab2672:
    ; #load tag
    mov r13, 5
    ; substitute (a0 := a0)(css := css)(f := f)(pss := pss)(x0 := x0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_fill_zip_with2_0_
    jmp lift_fill_zip_with2_0_

lift_fill_zip_with2_0_:
    ; substitute (pss := pss)(css := css)(f := f)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a2: List[List[ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2684
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2685

lab2684:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2682
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2675
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2673
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2674

lab2673:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2674:

lab2675:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2678
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2676
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2677

lab2676:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2677:

lab2678:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2681
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2679
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2680

lab2679:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2680:

lab2681:
    jmp lab2683

lab2682:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2683:

lab2685:
    ; #load tag
    lea r11, [rel List_List_ConflictSet_2686]
    ; substitute (f := f)(css := css)(pss := pss)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump fill_zip_with2_
    jmp fill_zip_with2_

List_List_ConflictSet_2686:
    jmp near List_List_ConflictSet_2686_Nil
    jmp near List_List_ConflictSet_2686_Cons

List_List_ConflictSet_2686_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2689
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2687
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2687:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2688
    ; ####increment refcount
    add qword [rax + 0], 1

lab2688:
    jmp lab2690

lab2689:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab2690:
    ; let x1: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_2686_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2693
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2691
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2691:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2692
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2692:
    jmp lab2694

lab2693:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2694:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2706
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2707

lab2706:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2704
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2697
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2695
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2696

lab2695:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2696:

lab2697:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2700
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2698
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2699

lab2698:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2699:

lab2700:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2703
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2701
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2702

lab2701:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2702:

lab2703:
    jmp lab2705

lab2704:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2705:

lab2707:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_table_:
    ; substitute (a0 := a0)(csp := csp)(tbl := tbl)(s := s);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; switch s \{ ... \};
    lea rcx, [rel List_Assign_2708]
    add rcx, r11
    jmp rcx

List_Assign_2708:
    jmp near List_Assign_2708_Nil
    jmp near List_Assign_2708_Cons

List_Assign_2708_Nil:
    ; substitute (a0 := a0)(tbl := tbl);
    ; #erase csp
    cmp rsi, 0
    je lab2711
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab2709
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab2710

lab2709:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab2710:

lab2711:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch tbl \{ ... \};
    lea rcx, [rel List_List_ConflictSet_2712]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_2712:
    jmp near List_List_ConflictSet_2712_Nil
    jmp near List_List_ConflictSet_2712_Cons

List_List_ConflictSet_2712_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_2712_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2715
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab2713
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2713:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab2714
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2714:
    jmp lab2716

lab2715:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab2716:
    ; substitute (a7 := a7)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Assign_2708_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2719
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab2717
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2717:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab2718
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2718:
    jmp lab2720

lab2719:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab2720:
    ; substitute (a0 := a0)(csp := csp)(tbl := tbl)(as := as);
    ; #erase as_
    cmp r12, 0
    je lab2723
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab2721
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab2722

lab2721:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab2722:

lab2723:
    ; switch as \{ ... \};
    ; #there is only one clause, so we can just fall through

Assign_2724:

Assign_2724_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2725
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab2726

lab2725:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab2726:
    ; substitute (a0 := a0)(val_ := val_)(tbl := tbl)(var_ := var_)(csp := csp);
    ; #move variables
    mov r12, rsi
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_2727:

CSP_2727_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab2729
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab2728
    ; ####increment refcount
    add qword [rcx + 0], 1

lab2728:
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]
    jmp lab2730

lab2729:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]

lab2730:
    ; substitute (a0 := a0)(vals := vals)(tbl := tbl)(var_1 := var_)(vars := vars)(var_ := var_)(rel := rel)(val_ := val_);
    ; #move variables
    mov [rsp + 2008], rdi
    mov rdi, r15
    mov r15, r11
    ; create f4: Fun2[ConflictSet, Pair[i64, i64], ConflictSet] = (var_, rel, val_)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    mov [rbx + 24], r15
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2742
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab2743

lab2742:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2740
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2733
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2731
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2732

lab2731:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2732:

lab2733:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2736
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2734
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2735

lab2734:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2735:

lab2736:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2739
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2737
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2738

lab2737:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2738:

lab2739:
    jmp lab2741

lab2740:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2741:

lab2743:
    ; #load tag
    lea r15, [rel Fun2_ConflictSet_Pair_i64_i64_ConflictSet_2744]
    ; create x6: Fun2[List[ConflictSet], List[Pair[i64, i64]], List[ConflictSet]] = (f4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2756
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab2757

lab2756:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2754
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2747
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2745
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2746

lab2745:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2746:

lab2747:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2750
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2748
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2749

lab2748:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2749:

lab2750:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2753
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2751
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2752

lab2751:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2752:

lab2753:
    jmp lab2755

lab2754:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2755:

lab2757:
    ; #load tag
    lea r15, [rel Fun2_List_ConflictSet_List_Pair_i64_i64_List_ConflictSet_2758]
    ; substitute (vars := vars)(vals := vals)(var_1 := var_1)(tbl := tbl)(a0 := a0)(x6 := x6);
    ; #move variables
    mov r12, rax
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov r10, r8
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; create a2: List[List[Pair[i64, i64]]] = (tbl, a0, x6)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2770
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2771

lab2770:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2768
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2761
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2759
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2760

lab2759:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2760:

lab2761:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2764
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2762
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2763

lab2762:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2763:

lab2764:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2767
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2765
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2766

lab2765:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2766:

lab2767:
    jmp lab2769

lab2768:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2769:

lab2771:
    ; #load tag
    lea r11, [rel List_List_Pair_i64_i64_2772]
    ; substitute (vars := vars)(var_1 := var_1)(vals := vals)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a3: List[i64] = (vals, a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2784
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2785

lab2784:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2782
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2775
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2773
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2774

lab2773:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2774:

lab2775:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2778
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2776
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2777

lab2776:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2777:

lab2778:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2781
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2779
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2780

lab2779:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2780:

lab2781:
    jmp lab2783

lab2782:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2783:

lab2785:
    ; #load tag
    lea r9, [rel List_i64_2786]
    ; lit x9 <- 1;
    mov r11, 1
    ; x10 <- var_1 + x9;
    mov r13, rdi
    add r13, r11
    ; substitute (x10 := x10)(vars := vars)(a3 := a3);
    ; #move variables
    mov rdi, rdx
    mov rdx, r13
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_2786:
    jmp near List_i64_2786_Nil
    jmp near List_i64_2786_Cons

List_i64_2786_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2788
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab2787
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2787:
    mov rdx, [rax + 40]
    jmp lab2789

lab2788:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab2789:
    ; let x8: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x8 := x8)(vals := vals)(a2 := a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump n_pairs_
    jmp n_pairs_

List_i64_2786_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2791
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2790
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2790:
    mov r9, [r8 + 40]
    jmp lab2792

lab2791:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab2792:
    ; substitute (a2 := a2)(vals := vals)(a9 := a9)(as2 := as2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x8: List[i64] = Cons(a9, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2804
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2805

lab2804:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2802
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2795
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2793
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2794

lab2793:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2794:

lab2795:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2798
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2796
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2797

lab2796:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2797:

lab2798:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2801
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2799
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2800

lab2799:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2800:

lab2801:
    jmp lab2803

lab2802:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2803:

lab2805:
    ; #load tag
    mov r9, 5
    ; substitute (x8 := x8)(vals := vals)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump n_pairs_
    jmp n_pairs_

List_List_Pair_i64_i64_2772:
    jmp near List_List_Pair_i64_i64_2772_Nil
    jmp near List_List_Pair_i64_i64_2772_Cons

List_List_Pair_i64_i64_2772_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2809
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab2806
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2806:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab2807
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2807:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab2808
    ; ####increment refcount
    add qword [rax + 0], 1

lab2808:
    jmp lab2810

lab2809:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab2810:
    ; let x7: List[List[Pair[i64, i64]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (x6 := x6)(tbl := tbl)(x7 := x7)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump fill_zip_with2_
    jmp fill_zip_with2_

List_List_Pair_i64_i64_2772_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2814
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab2811
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2811:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab2812
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2812:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab2813
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2813:
    jmp lab2815

lab2814:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab2815:
    ; substitute (x6 := x6)(a0 := a0)(tbl := tbl)(a8 := a8)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x7: List[List[Pair[i64, i64]]] = Cons(a8, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2827
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2828

lab2827:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2825
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2818
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2816
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2817

lab2816:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2817:

lab2818:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2821
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2819
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2820

lab2819:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2820:

lab2821:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2824
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2822
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2823

lab2822:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2823:

lab2824:
    jmp lab2826

lab2825:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2826:

lab2828:
    ; #load tag
    mov r11, 5
    ; substitute (x6 := x6)(tbl := tbl)(x7 := x7)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump fill_zip_with2_
    jmp fill_zip_with2_

Fun2_List_ConflictSet_List_Pair_i64_i64_List_ConflictSet_2758:

Fun2_List_ConflictSet_List_Pair_i64_i64_List_ConflictSet_2758_Apply2:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2830
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab2829
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2829:
    jmp lab2831

lab2830:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab2831:
    ; substitute (f4 := f4)(x := x)(y := y)(a1 := a1);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump fill_zip_with_
    jmp fill_zip_with_

Fun2_ConflictSet_Pair_i64_i64_ConflictSet_2744:

Fun2_ConflictSet_Pair_i64_i64_ConflictSet_2744_Apply2:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab2833
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab2832
    ; ####increment refcount
    add qword [r12 + 0], 1

lab2832:
    mov r11, [r10 + 24]
    jmp lab2834

lab2833:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]

lab2834:
    ; substitute (cs := cs)(val_ := val_)(a4 := a4)(var_ := var_)(rel := rel)(varval := varval);
    ; #move variables
    mov r14, rsi
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    ; switch varval \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_i64_i64_2835:

Pair_i64_i64_2835_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r14 + 0], 0
    je lab2836
    ; ##either decrement refcount and share children...
    add qword [r14 + 0], -1
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 40]
    jmp lab2837

lab2836:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 40]

lab2837:
    ; substitute (cs := cs)(val_ := val_)(a4 := a4)(var_ := var_)(rel := rel)(varr := varr)(vall := vall)(cs0 := cs);
    ; #share cs
    cmp rax, 0
    je lab2838
    ; ####increment refcount
    add qword [rax + 0], 1

lab2838:
    ; #move variables
    mov [rsp + 2016], rax
    mov [rsp + 2008], rdx
    ; switch cs0 \{ ... \};
    lea rcx, [rel ConflictSet_2839]
    add rcx, [rsp + 2008]
    jmp rcx

ConflictSet_2839:
    jmp near ConflictSet_2839_Known
    jmp near ConflictSet_2839_Unknown

ConflictSet_2839_Known:
    ; #load from memory
    mov rcx, [rsp + 2016]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab2841
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    ; ###evacuate additional scratch register for memory block
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab2840
    ; ####increment refcount
    add qword [rcx + 0], 1

lab2840:
    ; ###restore evacuated register
    mov rax, [rsp + 2040]
    jmp lab2842

lab2841:
    ; ##... or release blocks onto linear free list when loading
    ; ###evacuate additional scratch register for memory block
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    ; ###restore evacuated register
    mov rax, [rsp + 2040]

lab2842:
    ; substitute (a4 := a4)(cs := cs);
    ; #erase rel
    cmp r12, 0
    je lab2845
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab2843
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab2844

lab2843:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab2844:

lab2845:
    ; #erase vs
    mov rcx, [rsp + 2016]
    cmp rcx, 0
    je lab2848
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2846
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2847

lab2846:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2847:

lab2848:
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    ; switch cs \{ ... \};
    lea rcx, [rel ConflictSet_2849]
    add rcx, rdi
    jmp rcx

ConflictSet_2849:
    jmp near ConflictSet_2849_Known
    jmp near ConflictSet_2849_Unknown

ConflictSet_2849_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2851
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab2850
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2850:
    jmp lab2852

lab2851:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab2852:
    ; substitute (vs0 := vs0)(a4 := a4);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a4 Known
    add rdi, 0
    jmp rdi

ConflictSet_2849_Unknown:
    ; invoke a4 Unknown
    add rdx, 5
    jmp rdx

ConflictSet_2839_Unknown:
    ; substitute (vall := vall)(val_ := val_)(varr0 := varr)(var_0 := var_)(rel := rel)(varr := varr)(var_ := var_)(cs := cs)(a4 := a4);
    ; #move variables
    mov [rsp + 2016], rax
    mov [rsp + 2008], rdx
    mov [rsp + 2000], r8
    mov [rsp + 1992], r9
    mov rdx, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r9, r15
    ; create a5: Bool = (varr, var_, cs, a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2864
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab2865

lab2864:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2862
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2855
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2853
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2854

lab2853:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2854:

lab2855:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2858
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2856
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2857

lab2856:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2857:

lab2858:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2861
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2859
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2860

lab2859:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2860:

lab2861:
    jmp lab2863

lab2862:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2863:

lab2865:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2877
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab2878

lab2877:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2875
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2868
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2866
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2867

lab2866:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2867:

lab2868:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2871
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2869
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2870

lab2869:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2870:

lab2871:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2874
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2872
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2873

lab2872:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2873:

lab2874:
    jmp lab2876

lab2875:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2876:

lab2878:
    ; #load tag
    lea r15, [rel Bool_2879]
    ; substitute (vall := vall)(a5 := a5)(varr0 := varr0)(rel := rel)(var_0 := var_0)(val_ := val_);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, rcx
    mov r10, r12
    mov rsi, r14
    ; let x1: Assign = Assign(var_0, val_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2891
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab2892

lab2891:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2889
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2882
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2880
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2881

lab2880:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2881:

lab2882:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2885
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2883
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2884

lab2883:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2884:

lab2885:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2888
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2886
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2887

lab2886:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2887:

lab2888:
    jmp lab2890

lab2889:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2890:

lab2892:
    ; #load tag
    mov r13, 0
    ; substitute (x1 := x1)(a5 := a5)(rel := rel)(varr0 := varr0)(vall := vall);
    ; #move variables
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    mov r8, r10
    mov rax, r12
    ; let x2: Assign = Assign(varr0, vall);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2904
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab2905

lab2904:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2902
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2895
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2893
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2894

lab2893:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2894:

lab2895:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2898
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2896
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2897

lab2896:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2897:

lab2898:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2901
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2899
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2900

lab2899:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2900:

lab2901:
    jmp lab2903

lab2902:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2903:

lab2905:
    ; #load tag
    mov r11, 0
    ; substitute (x1 := x1)(x2 := x2)(a5 := a5)(rel := rel);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke rel Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

Bool_2879:
    jmp near Bool_2879_True
    jmp near Bool_2879_False

Bool_2879_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2908
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2906
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2906:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2907
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2907:
    mov rdi, [rsi + 24]
    jmp lab2909

lab2908:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]

lab2909:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (a4 := a4)(cs := cs)(var_ := var_)(varr := varr)(x0 := x0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rsi, r8
    mov rax, r10
    ; jump lift_fill_table_0_
    jmp lift_fill_table_0_

Bool_2879_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2912
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2910
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2910:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab2911
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2911:
    mov rdi, [rsi + 24]
    jmp lab2913

lab2912:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]

lab2913:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 5
    ; substitute (a4 := a4)(cs := cs)(var_ := var_)(varr := varr)(x0 := x0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rsi, r8
    mov rax, r10
    ; jump lift_fill_table_0_
    jmp lift_fill_table_0_

lift_fill_table_0_:
    ; substitute (x0 := x0)(cs := cs)(var_ := var_)(varr := varr)(a4 := a4);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; create a6: Bool = (cs, var_, varr, a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2925
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2926

lab2925:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2923
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2916
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2914
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2915

lab2914:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2915:

lab2916:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2919
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2917
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2918

lab2917:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2918:

lab2919:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2922
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2920
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2921

lab2920:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2921:

lab2922:
    jmp lab2924

lab2923:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2924:

lab2926:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2938
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2939

lab2938:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2936
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2929
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2927
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2928

lab2927:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2928:

lab2929:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2932
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2930
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2931

lab2930:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2931:

lab2932:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2935
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2933
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2934

lab2933:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2934:

lab2935:
    jmp lab2937

lab2936:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2937:

lab2939:
    ; #load tag
    lea rdi, [rel Bool_2940]
    ; jump not_
    jmp not_

Bool_2940:
    jmp near Bool_2940_True
    jmp near Bool_2940_False

Bool_2940_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2943
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2941
    ; ####increment refcount
    add qword [rax + 0], 1

lab2941:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2942
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2942:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab2944

lab2943:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab2944:
    ; substitute (a4 := a4)(var_ := var_)(varr := varr);
    ; #erase cs
    cmp rax, 0
    je lab2947
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2945
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2946

lab2945:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2946:

lab2947:
    ; #move variables
    mov rax, r10
    mov rdx, r11
    ; let x3: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; let x4: List[i64] = Cons(varr, x3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2959
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab2960

lab2959:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2957
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2950
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2948
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2949

lab2948:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2949:

lab2950:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2953
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2951
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2952

lab2951:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2952:

lab2953:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2956
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2954
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2955

lab2954:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2955:

lab2956:
    jmp lab2958

lab2957:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2958:

lab2960:
    ; #load tag
    mov r9, 5
    ; let x5: List[i64] = Cons(var_, x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab2972
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab2973

lab2972:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab2970
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2963
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2961
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2962

lab2961:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2962:

lab2963:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2965

lab2964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2965:

lab2966:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2969
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2967
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2968

lab2967:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2968:

lab2969:
    jmp lab2971

lab2970:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab2971:

lab2973:
    ; #load tag
    mov rdi, 5
    ; substitute (x5 := x5)(a4 := a4);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a4 Known
    add rdi, 0
    jmp rdi

Bool_2940_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab2976
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab2974
    ; ####increment refcount
    add qword [rax + 0], 1

lab2974:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab2975
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2975:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab2977

lab2976:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab2977:
    ; substitute (a4 := a4)(cs := cs);
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r10
    mov rdx, r11
    ; switch cs \{ ... \};
    lea rcx, [rel ConflictSet_2978]
    add rcx, rdi
    jmp rcx

ConflictSet_2978:
    jmp near ConflictSet_2978_Known
    jmp near ConflictSet_2978_Unknown

ConflictSet_2978_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab2980
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab2979
    ; ####increment refcount
    add qword [rsi + 0], 1

lab2979:
    jmp lab2981

lab2980:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab2981:
    ; substitute (vs1 := vs1)(a4 := a4);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a4 Known
    add rdi, 0
    jmp rdi

ConflictSet_2978_Unknown:
    ; invoke a4 Unknown
    add rdx, 5
    jmp rdx

lookup_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_List_List_ConflictSet_2982]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_List_List_ConflictSet_2982:
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_2982_Nil
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_2982_Cons

List_Node_Pair_List_Assign_List_List_ConflictSet_2982_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab2985
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab2983
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab2984

lab2983:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab2984:

lab2985:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_List_List_ConflictSet_2982_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab2988
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab2986
    ; ####increment refcount
    add qword [r10 + 0], 1

lab2986:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab2987
    ; ####increment refcount
    add qword [r8 + 0], 1

lab2987:
    jmp lab2989

lab2988:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab2989:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab2990
    ; ####increment refcount
    add qword [rax + 0], 1

lab2990:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3002
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3003

lab3002:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3000
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab2993
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2991
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2992

lab2991:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2992:

lab2993:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab2996
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2994
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2995

lab2994:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2995:

lab2996:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab2999
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab2997
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab2998

lab2997:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab2998:

lab2999:
    jmp lab3001

lab3000:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3001:

lab3003:
    ; #load tag
    lea r9, [rel Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3004]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3004:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3004_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3008
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3005
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3005:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3006
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3006:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3007
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3007:
    jmp lab3009

lab3008:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3009:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3021
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3022

lab3021:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3019
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3012
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3010
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3011

lab3010:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3011:

lab3012:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3015
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3013
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3014

lab3013:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3014:

lab3015:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3018
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3016
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3017

lab3016:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3017:

lab3018:
    jmp lab3020

lab3019:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3020:

lab3022:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3034
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3035

lab3034:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3032
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3025
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3023
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3024

lab3023:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3024:

lab3025:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3028
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3026
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3027

lab3026:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3027:

lab3028:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3031
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3029
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3030

lab3029:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3030:

lab3031:
    jmp lab3033

lab3032:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3033:

lab3035:
    ; #load tag
    lea r9, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3036]
    ; jump lookup_map_
    jmp lookup_map_

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3036:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3036_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3036_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3036_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3039
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3037
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3037:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3038
    ; ####increment refcount
    add qword [rax + 0], 1

lab3038:
    jmp lab3040

lab3039:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3040:
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3036_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3043
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3041
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3041:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3042
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3042:
    jmp lab3044

lab3043:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3044:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3056
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3057

lab3056:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3054
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3047
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3045
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3046

lab3045:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3046:

lab3047:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3050
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3048
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3049

lab3048:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3049:

lab3050:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3053
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3051
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3052

lab3051:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3052:

lab3053:
    jmp lab3055

lab3054:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3055:

lab3057:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

lookup_map_tree_:
    ; substitute (f := f)(a0 := a0)(t := t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_List_List_ConflictSet_3058:

Node_Pair_List_Assign_List_List_ConflictSet_3058_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3061
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3059
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3059:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3060
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3060:
    jmp lab3062

lab3061:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3062:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab3063
    ; ####increment refcount
    add qword [rax + 0], 1

lab3063:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3075
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3076

lab3075:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3073
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3066
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3064
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3065

lab3064:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3065:

lab3066:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3069
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3067
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3068

lab3067:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3068:

lab3069:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3072
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3070
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3071

lab3070:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3071:

lab3072:
    jmp lab3074

lab3073:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3074:

lab3076:
    ; #load tag
    lea r9, [rel Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3077]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3077:

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3077_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3081
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3078
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3078:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3079
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3079:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3080
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3080:
    jmp lab3082

lab3081:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3082:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a5 := a5)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3094
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3095

lab3094:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3092
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3085
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3083
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3084

lab3083:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3084:

lab3085:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3088
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3086
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3087

lab3086:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3087:

lab3088:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3091
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3089
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3090

lab3089:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3090:

lab3091:
    jmp lab3093

lab3092:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3093:

lab3095:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3107
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3108

lab3107:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3105
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3098
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3096
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3097

lab3096:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3097:

lab3098:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3101
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3099
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3100

lab3099:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3100:

lab3101:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3104
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3102
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3103

lab3102:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3103:

lab3104:
    jmp lab3106

lab3105:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3106:

lab3108:
    ; #load tag
    lea r9, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3109]
    ; substitute (a2 := a2)(ps := ps)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x2: Fun[Node[Pair[List[Assign], List[List[ConflictSet]]]], Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3121
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3122

lab3121:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3119
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3112
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3110
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3111

lab3110:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3111:

lab3112:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3115
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3113
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3114

lab3113:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3114:

lab3115:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3118
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3116
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3117

lab3116:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3117:

lab3118:
    jmp lab3120

lab3119:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3120:

lab3122:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_List_List_ConflictSet_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3123]
    ; substitute (x2 := x2)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lookup_map_
    jmp lookup_map_

Fun_Node_Pair_List_Assign_List_List_ConflictSet_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3123:

Fun_Node_Pair_List_Assign_List_List_ConflictSet_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3123_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3125
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab3124
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3124:
    jmp lab3126

lab3125:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab3126:
    ; substitute (f := f)(x := x)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lookup_map_tree_
    jmp lookup_map_tree_

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3109:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3109_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3109_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3109_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3129
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3127
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3127:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3128
    ; ####increment refcount
    add qword [rax + 0], 1

lab3128:
    jmp lab3130

lab3129:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3130:
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3109_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3133
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3131
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3131:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3132
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3132:
    jmp lab3134

lab3133:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3134:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3146
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3147

lab3146:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3144
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3137
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3135
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3136

lab3135:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3136:

lab3137:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3140
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3138
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3139

lab3138:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3139:

lab3140:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3143
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3141
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3142

lab3141:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3142:

lab3143:
    jmp lab3145

lab3144:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3145:

lab3147:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

lookup_at_index_:
    ; substitute (ind := ind)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_ConflictSet_3148]
    add rcx, r9
    jmp rcx

List_ConflictSet_3148:
    jmp near List_ConflictSet_3148_Nil
    jmp near List_ConflictSet_3148_Cons

List_ConflictSet_3148_Nil:
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

List_ConflictSet_3148_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3151
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3149
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3149:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3150
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3150:
    jmp lab3152

lab3151:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3152:
    ; if ind == 0 \{ ... \}
    cmp rdx, 0
    je lab3153
    ; else branch
    ; substitute (ind := ind)(a0 := a0)(cs := cs);
    ; #erase c
    cmp r8, 0
    je lab3156
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab3154
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab3155

lab3154:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab3155:

lab3156:
    ; #move variables
    mov r8, r10
    mov r9, r11
    ; lit x0 <- 1;
    mov r11, 1
    ; x1 <- ind - x0;
    mov r13, rdx
    sub r13, r11
    ; substitute (x1 := x1)(cs := cs)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rdx, r13
    ; jump lookup_at_index_
    jmp lookup_at_index_

lab3153:
    ; then branch
    ; substitute (a0 := a0)(c := c);
    ; #erase cs
    cmp r10, 0
    je lab3159
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab3157
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab3158

lab3157:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab3158:

lab3159:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_3160]
    add rcx, rdi
    jmp rcx

ConflictSet_3160:
    jmp near ConflictSet_3160_Known
    jmp near ConflictSet_3160_Unknown

ConflictSet_3160_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3162
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab3161
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3161:
    jmp lab3163

lab3162:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab3163:
    ; substitute (vs0 := vs0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Known
    add rdi, 0
    jmp rdi

ConflictSet_3160_Unknown:
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

lookup_head_:
    ; substitute (a0 := a0)(tbl := tbl);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch tbl \{ ... \};
    lea rcx, [rel List_List_ConflictSet_3164]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_3164:
    jmp near List_List_ConflictSet_3164_Nil
    jmp near List_List_ConflictSet_3164_Cons

List_List_ConflictSet_3164_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_3164_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3167
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3165
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3165:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3166
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3166:
    jmp lab3168

lab3167:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3168:
    ; substitute (a0 := a0)(cs := cs);
    ; #erase css
    cmp r8, 0
    je lab3171
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab3169
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab3170

lab3169:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab3170:

lab3171:
    ; switch cs \{ ... \};
    lea rcx, [rel List_ConflictSet_3172]
    add rcx, rdi
    jmp rcx

List_ConflictSet_3172:
    jmp near List_ConflictSet_3172_Nil
    jmp near List_ConflictSet_3172_Cons

List_ConflictSet_3172_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_3172_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3175
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3173
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3173:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3174
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3174:
    jmp lab3176

lab3175:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3176:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

lookup_cache_:
    ; create f5: Fun2[CSP, Pair[List[Assign], List[List[ConflictSet]]], Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun2_CSP_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3177]
    ; substitute (a0 := a0)(t := t)(csp := csp)(f5 := f5);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x8: Fun[Pair[List[Assign], List[List[ConflictSet]]], Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (csp, f5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3189
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3190

lab3189:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3187
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3180
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3178
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3179

lab3178:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3179:

lab3180:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3183
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3181
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3182

lab3181:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3182:

lab3183:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3186
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3184
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3185

lab3184:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3185:

lab3186:
    jmp lab3188

lab3187:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3188:

lab3190:
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3191]
    ; substitute (x8 := x8)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lookup_map_tree_
    jmp lookup_map_tree_

Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3191:

Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3191_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3194
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3192
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3192:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3193
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3193:
    jmp lab3195

lab3194:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3195:
    ; substitute (csp := csp)(x := x)(a1 := a1)(f5 := f5);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke f5 Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

Fun2_CSP_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3177:

Fun2_CSP_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3177_Apply2:
    ; substitute (csp0 := csp0)(a2 := a2)(tp := tp);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch tp \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_List_List_ConflictSet_3196:

Pair_List_Assign_List_List_ConflictSet_3196_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3199
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3197
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3197:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3198
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3198:
    jmp lab3200

lab3199:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3200:
    ; substitute (csp0 := csp0)(a2 := a2)(tbl := tbl)(ls := ls);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_3201]
    add rcx, r11
    jmp rcx

List_Assign_3201:
    jmp near List_Assign_3201_Nil
    jmp near List_Assign_3201_Cons

List_Assign_3201_Nil:
    ; substitute (tbl := tbl)(a2 := a2);
    ; #erase csp0
    cmp rax, 0
    je lab3204
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab3202
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab3203

lab3202:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab3203:

lab3204:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; let x1: ConflictSet = Unknown();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 5
    ; let x2: Pair[List[Assign], ConflictSet] = Tup(x0, x1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3216
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3217

lab3216:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3214
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3207
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3205
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3206

lab3205:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3206:

lab3207:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3210
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3208
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3209

lab3208:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3209:

lab3210:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3213
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3211
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3212

lab3211:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3212:

lab3213:
    jmp lab3215

lab3214:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3215:

lab3217:
    ; #load tag
    mov r9, 0
    ; substitute (x2 := x2)(tbl := tbl)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a2 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Assign_3201_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab3220
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab3218
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3218:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab3219
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3219:
    jmp lab3221

lab3220:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab3221:
    ; substitute (a8 := a)(a2 := a2)(tbl := tbl)(a := a)(as_ := as_)(csp0 := csp0);
    ; #share a
    cmp r10, 0
    je lab3222
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3222:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov rax, r10
    mov rdx, r11
    ; create a3: _Cont = (a2, tbl, a, as_, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3234
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3235

lab3234:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3232
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3225
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3223
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3224

lab3223:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3224:

lab3225:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3228
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3226
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3227

lab3226:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3227:

lab3228:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3231
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3229
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3230

lab3229:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3230:

lab3231:
    jmp lab3233

lab3232:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3233:

lab3235:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3247
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab3248

lab3247:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3245
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3238
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3236
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3237

lab3236:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3237:

lab3238:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3241
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3239
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3240

lab3239:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3240:

lab3241:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3244
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3242
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3243

lab3242:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3243:

lab3244:
    jmp lab3246

lab3245:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3246:

lab3248:
    ; #load tag
    lea rdi, [rel _Cont_3249]
    ; jump value_
    jmp value_

_Cont_3249:

_Cont_3249_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3255
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab3250
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3250:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab3251
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3251:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab3252
    ; ####increment refcount
    add qword [r14 + 0], 1

lab3252:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab3253
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3253:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab3254
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3254:
    jmp lab3256

lab3255:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab3256:
    ; lit x4 <- 1;
    mov qword [rsp + 2024], 1
    ; x5 <- x3 - x4;
    mov rcx, rdx
    sub rcx, [rsp + 2024]
    mov [rsp + 2008], rcx
    ; substitute (tbl0 := tbl)(a2 := a2)(tbl := tbl)(a := a)(as_ := as_)(csp0 := csp0)(x5 := x5);
    ; #share tbl
    cmp r8, 0
    je lab3257
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3257:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov rcx, [rsp + 2008]
    mov [rsp + 2024], rcx
    ; create a4: List[ConflictSet] = (a2, tbl, a, as_, csp0, x5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3269
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab3270

lab3269:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3267
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3259

lab3258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3259:

lab3260:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3263
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3261
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3262

lab3261:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3262:

lab3263:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3266
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3264
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3265

lab3264:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3265:

lab3266:
    jmp lab3268

lab3267:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3268:

lab3270:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3282
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3283

lab3282:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3280
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3273
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3271
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3272

lab3271:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3272:

lab3273:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3276
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3274
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3275

lab3274:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3275:

lab3276:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3279
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3277
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3278

lab3277:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3278:

lab3279:
    jmp lab3281

lab3280:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3281:

lab3283:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3295
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab3296

lab3295:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3293
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3286
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3284
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3285

lab3284:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3285:

lab3286:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3289
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3287
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3288

lab3287:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3288:

lab3289:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3292
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3290
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3291

lab3290:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3291:

lab3292:
    jmp lab3294

lab3293:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3294:

lab3296:
    ; #load tag
    lea rdi, [rel List_ConflictSet_3297]
    ; jump lookup_head_
    jmp lookup_head_

List_ConflictSet_3297:
    jmp near List_ConflictSet_3297_Nil
    jmp near List_ConflictSet_3297_Cons

List_ConflictSet_3297_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3303
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3298
    ; ####increment refcount
    add qword [rax + 0], 1

lab3298:
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab3299
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3299:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab3300
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3300:
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab3301
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3301:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab3302
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3302:
    jmp lab3304

lab3303:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab3304:
    ; let x6: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    mov qword [rsp + 2024], 0
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(tbl := tbl)(x5 := x5)(x6 := x6);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, r12
    mov r12, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, r13
    mov r13, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_lookup_cache_0_
    jmp lift_lookup_cache_0_

List_ConflictSet_3297_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3310
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3305
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3305:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab3306
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3306:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab3307
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3307:
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab3308
    ; ####increment refcount
    add qword [rcx + 0], 1

lab3308:
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab3309
    ; ####increment refcount
    add qword [r14 + 0], 1

lab3309:
    jmp lab3311

lab3310:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab3311:
    ; substitute (x5 := x5)(csp0 := csp0)(a2 := a2)(tbl := tbl)(a := a)(as_ := as_)(a7 := a7)(as0 := as0);
    ; #move variables
    mov [rsp + 2016], rsi
    mov rsi, [rsp + 2032]
    mov [rsp + 2032], rax
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    ; let x6: List[ConflictSet] = Cons(a7, as0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3323
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab3324

lab3323:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3321
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3314
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3312
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3313

lab3312:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3313:

lab3314:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3317
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3315
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3316

lab3315:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3316:

lab3317:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3320
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3318
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3319

lab3318:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3319:

lab3320:
    jmp lab3322

lab3321:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3322:

lab3324:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(tbl := tbl)(x5 := x5)(x6 := x6);
    ; #move variables
    mov rcx, r13
    mov r13, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, r15
    mov r15, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, r14
    ; jump lift_lookup_cache_0_
    jmp lift_lookup_cache_0_

lift_lookup_cache_0_:
    ; substitute (x6 := x6)(x5 := x5)(as_ := as_)(csp0 := csp0)(tbl := tbl)(a2 := a2)(a := a);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], rax
    mov rax, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    mov r14, rsi
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    ; create a5: ConflictSet = (as_, csp0, tbl, a2, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3336
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab3337

lab3336:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3334
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3327
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3325
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3326

lab3325:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3326:

lab3327:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3330
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3328
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3329

lab3328:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3329:

lab3330:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3333
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3331
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3332

lab3331:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3332:

lab3333:
    jmp lab3335

lab3334:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3335:

lab3337:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3349
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3350

lab3349:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3347
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3340
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3338
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3339

lab3338:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3339:

lab3340:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3343
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3341
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3342

lab3341:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3342:

lab3343:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3346
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3344
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3345

lab3344:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3345:

lab3346:
    jmp lab3348

lab3347:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3348:

lab3350:
    ; #load tag
    lea r9, [rel ConflictSet_3351]
    ; substitute (x5 := x5)(x6 := x6)(a5 := a5);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lookup_at_index_
    jmp lookup_at_index_

ConflictSet_3351:
    jmp near ConflictSet_3351_Known
    jmp near ConflictSet_3351_Unknown

ConflictSet_3351_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3357
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab3352
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3352:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab3353
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3353:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab3354
    ; ####increment refcount
    add qword [r14 + 0], 1

lab3354:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab3355
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3355:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab3356
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3356:
    jmp lab3358

lab3357:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab3358:
    ; substitute (a := a)(as_ := as_)(csp0 := csp0)(tbl := tbl)(a2 := a2)(vs1 := vs1);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    ; let table_entry: ConflictSet = Known(vs1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3370
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab3371

lab3370:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3368
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3361
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3359
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3360

lab3359:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3360:

lab3361:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3364
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3362
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3363

lab3362:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3363:

lab3364:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3367
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3365
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3366

lab3365:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3366:

lab3367:
    jmp lab3369

lab3368:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3369:

lab3371:
    ; #load tag
    mov r15, 0
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(table_entry := table_entry)(tbl := tbl);
    ; #move variables
    mov rcx, r12
    mov r12, r14
    mov r14, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, r15
    mov r15, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_lookup_cache_1_
    jmp lift_lookup_cache_1_

ConflictSet_3351_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3377
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab3372
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3372:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab3373
    ; ####increment refcount
    add qword [rax + 0], 1

lab3373:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3374
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3374:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3375
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3375:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3376
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3376:
    jmp lab3378

lab3377:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3378:
    ; let table_entry: ConflictSet = Unknown();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 5
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(table_entry := table_entry)(tbl := tbl);
    ; #move variables
    mov rcx, r12
    mov r12, r14
    mov r14, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r15
    mov r15, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump lift_lookup_cache_1_
    jmp lift_lookup_cache_1_

lift_lookup_cache_1_:
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(table_entry := table_entry)(tbl := tbl)(table_entry0 := table_entry);
    ; #share table_entry
    cmp r12, 0
    je lab3379
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3379:
    ; #move variables
    mov [rsp + 2032], r12
    mov [rsp + 2024], r13
    ; switch table_entry0 \{ ... \};
    lea rcx, [rel ConflictSet_3380]
    add rcx, [rsp + 2024]
    jmp rcx

ConflictSet_3380:
    jmp near ConflictSet_3380_Known
    jmp near ConflictSet_3380_Unknown

ConflictSet_3380_Known:
    ; #load from memory
    mov rcx, [rsp + 2032]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab3382
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    ; ###evacuate additional scratch register for memory block
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab3381
    ; ####increment refcount
    add qword [rcx + 0], 1

lab3381:
    ; ###restore evacuated register
    mov rax, [rsp + 2040]
    jmp lab3383

lab3382:
    ; ##... or release blocks onto linear free list when loading
    ; ###evacuate additional scratch register for memory block
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2032], rcx
    ; ###restore evacuated register
    mov rax, [rsp + 2040]

lab3383:
    ; substitute (a := a)(a2 := a2)(as_ := as_)(table_entry := table_entry)(tbl := tbl);
    ; #erase csp0
    cmp r10, 0
    je lab3386
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab3384
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab3385

lab3384:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab3385:

lab3386:
    ; #erase vals
    mov rcx, [rsp + 2032]
    cmp rcx, 0
    je lab3389
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3387
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3388

lab3387:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3388:

lab3389:
    ; #move variables
    mov r10, r12
    mov r11, r13
    mov r12, r14
    mov r13, r15
    ; jump share_lookup_cache_0_
    jmp share_lookup_cache_0_

ConflictSet_3380_Unknown:
    ; substitute (a := a)(a2 := a2)(as_ := as_)(csp0 := csp0)(tbl := tbl)(a7 := a)(as_0 := as_);
    ; #share a
    cmp rax, 0
    je lab3390
    ; ####increment refcount
    add qword [rax + 0], 1

lab3390:
    ; #share as_
    cmp r8, 0
    je lab3391
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3391:
    ; #erase table_entry
    cmp r12, 0
    je lab3394
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab3392
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab3393

lab3392:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab3393:

lab3394:
    ; #move variables
    mov r12, r14
    mov r14, rax
    mov r13, r15
    mov r15, rdx
    mov [rsp + 2032], r8
    mov [rsp + 2024], r9
    ; let x7: List[Assign] = Cons(a7, as_0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3406
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab3407

lab3406:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3404
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3397
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3395
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3396

lab3395:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3396:

lab3397:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3400
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3398
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3399

lab3398:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3399:

lab3400:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3403
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3401
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3402

lab3401:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3402:

lab3403:
    jmp lab3405

lab3404:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3405:

lab3407:
    ; #load tag
    mov r15, 5
    ; substitute (x7 := x7)(csp0 := csp0)(as_ := as_)(a2 := a2)(tbl := tbl)(a := a);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a6: ConflictSet = (as_, a2, tbl, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3419
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3420

lab3419:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3417
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3410
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3408
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3409

lab3408:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3409:

lab3410:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3413
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3411
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3412

lab3411:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3412:

lab3413:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3416
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3414
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3415

lab3414:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3415:

lab3416:
    jmp lab3418

lab3417:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3418:

lab3420:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3432
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3433

lab3432:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3430
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3423
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3421
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3422

lab3421:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3422:

lab3423:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3426
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3424
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3425

lab3424:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3425:

lab3426:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3429
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3427
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3428

lab3427:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3428:

lab3429:
    jmp lab3431

lab3430:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3431:

lab3433:
    ; #load tag
    lea r9, [rel ConflictSet_3434]
    ; substitute (csp0 := csp0)(x7 := x7)(a6 := a6);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump check_complete_
    jmp check_complete_

ConflictSet_3434:
    jmp near ConflictSet_3434_Known
    jmp near ConflictSet_3434_Unknown

ConflictSet_3434_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3439
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3435
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3435:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3436
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3436:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3437
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3437:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3438
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3438:
    jmp lab3440

lab3439:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3440:
    ; substitute (a := a)(as_ := as_)(a2 := a2)(tbl := tbl)(vs0 := vs0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; let cs: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3452
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab3453

lab3452:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3450
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3443
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3441
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3442

lab3441:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3442:

lab3443:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3446
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3444
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3445

lab3444:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3445:

lab3446:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3449
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3447
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3448

lab3447:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3448:

lab3449:
    jmp lab3451

lab3450:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3451:

lab3453:
    ; #load tag
    mov r13, 0
    ; substitute (a := a)(a2 := a2)(as_ := as_)(cs := cs)(tbl := tbl);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rcx, r12
    mov r12, r10
    mov r10, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, rcx
    ; jump share_lookup_cache_0_
    jmp share_lookup_cache_0_

ConflictSet_3434_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3458
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3454
    ; ####increment refcount
    add qword [rax + 0], 1

lab3454:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab3455
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3455:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab3456
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3456:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab3457
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3457:
    jmp lab3459

lab3458:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab3459:
    ; let cs: ConflictSet = Unknown();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 5
    ; substitute (a := a)(a2 := a2)(as_ := as_)(cs := cs)(tbl := tbl);
    ; #move variables
    mov rcx, r10
    mov r10, r12
    mov r12, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, r13
    mov r13, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump share_lookup_cache_0_
    jmp share_lookup_cache_0_

share_lookup_cache_0_:
    ; substitute (tbl := tbl)(a2 := a2)(cs := cs)(a := a)(as_ := as_);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a, as_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3471
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3472

lab3471:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3469
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3462
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3460
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3461

lab3460:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3461:

lab3462:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3465
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3463
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3464

lab3463:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3464:

lab3465:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3468
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3466
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3467

lab3466:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3467:

lab3468:
    jmp lab3470

lab3469:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3470:

lab3472:
    ; #load tag
    mov r11, 5
    ; substitute (tbl := tbl)(a2 := a2)(x0 := x0)(cs := cs);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; let x1: Pair[List[Assign], ConflictSet] = Tup(x0, cs);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3484
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3485

lab3484:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3482
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3475
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3473
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3474

lab3473:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3474:

lab3475:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3478
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3476
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3477

lab3476:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3477:

lab3478:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3481
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3479
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3480

lab3479:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3480:

lab3481:
    jmp lab3483

lab3482:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3483:

lab3485:
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(tbl := tbl)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a2 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

checks_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_List_Assign_3486]
    add rcx, r9
    jmp rcx

List_Node_List_Assign_3486:
    jmp near List_Node_List_Assign_3486_Nil
    jmp near List_Node_List_Assign_3486_Cons

List_Node_List_Assign_3486_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab3489
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab3487
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab3488

lab3487:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab3488:

lab3489:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_List_Assign_3486_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3492
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3490
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3490:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3491
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3491:
    jmp lab3493

lab3492:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3493:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab3494
    ; ####increment refcount
    add qword [rax + 0], 1

lab3494:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], List[List[ConflictSet]]]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3506
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3507

lab3506:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3504
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3497
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3495
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3496

lab3495:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3496:

lab3497:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3500
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3498
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3499

lab3498:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3499:

lab3500:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3503
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3501
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3502

lab3501:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3502:

lab3503:
    jmp lab3505

lab3504:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3505:

lab3507:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_List_List_ConflictSet_3508]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_List_List_ConflictSet_3508:

Node_Pair_List_Assign_List_List_ConflictSet_3508_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3512
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3509
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3509:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3510
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3510:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3511
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3511:
    jmp lab3513

lab3512:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3513:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3525
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3526

lab3525:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3523
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3516
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3514
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3515

lab3514:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3515:

lab3516:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3519
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3517
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3518

lab3517:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3518:

lab3519:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3522
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3520
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3521

lab3520:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3521:

lab3522:
    jmp lab3524

lab3523:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3524:

lab3526:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3538
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3539

lab3538:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3536
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3529
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3527
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3528

lab3527:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3528:

lab3529:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3532
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3530
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3531

lab3530:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3531:

lab3532:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3535
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3533
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3534

lab3533:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3534:

lab3535:
    jmp lab3537

lab3536:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3537:

lab3539:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_List_List_ConflictSet_3540]
    ; jump checks_map_
    jmp checks_map_

List_Node_Pair_List_Assign_List_List_ConflictSet_3540:
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3540_Nil
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3540_Cons

List_Node_Pair_List_Assign_List_List_ConflictSet_3540_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3543
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3541
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3541:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3542
    ; ####increment refcount
    add qword [rax + 0], 1

lab3542:
    jmp lab3544

lab3543:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3544:
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_List_List_ConflictSet_3540_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3547
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3545
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3545:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3546
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3546:
    jmp lab3548

lab3547:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3548:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3560
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3561

lab3560:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3558
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3551
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3549
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3550

lab3549:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3550:

lab3551:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3554
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3552
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3553

lab3552:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3553:

lab3554:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3557
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3555
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3556

lab3555:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3556:

lab3557:
    jmp lab3559

lab3558:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3559:

lab3561:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

checks_tail_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_3562]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_3562:
    jmp near List_List_ConflictSet_3562_Nil
    jmp near List_List_ConflictSet_3562_Cons

List_List_ConflictSet_3562_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_3562_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3565
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3563
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3563:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3564
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3564:
    jmp lab3566

lab3565:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3566:
    ; substitute (a0 := a0)(ls0 := ls0);
    ; #erase l
    cmp rsi, 0
    je lab3569
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab3567
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab3568

lab3567:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab3568:

lab3569:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch ls0 \{ ... \};
    lea rcx, [rel List_List_ConflictSet_3570]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_3570:
    jmp near List_List_ConflictSet_3570_Nil
    jmp near List_List_ConflictSet_3570_Cons

List_List_ConflictSet_3570_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_3570_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3573
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3571
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3571:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3572
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3572:
    jmp lab3574

lab3573:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3574:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

cache_checks_:
    ; substitute (csp := csp)(tbl := tbl)(a0 := a0)(n := n);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_List_Assign_3575:

Node_List_Assign_3575_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab3578
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab3576
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3576:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab3577
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3577:
    jmp lab3579

lab3578:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab3579:
    ; substitute (csp := csp)(tbl := tbl)(a0 := a0)(s := s)(cs := cs)(s0 := s)(tbl0 := tbl);
    ; #share s
    cmp r10, 0
    je lab3580
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3580:
    ; #share tbl
    cmp rsi, 0
    je lab3581
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3581:
    ; #move variables
    mov [rsp + 2032], rsi
    mov [rsp + 2024], rdi
    mov r14, r10
    mov r15, r11
    ; let x0: Pair[List[Assign], List[List[ConflictSet]]] = Tup(s0, tbl0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3593
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab3594

lab3593:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3591
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3584
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3582
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3583

lab3582:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3583:

lab3584:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3587
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3585
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3586

lab3585:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3586:

lab3587:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3590
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3588
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3589

lab3588:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3589:

lab3590:
    jmp lab3592

lab3591:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3592:

lab3594:
    ; #load tag
    mov r15, 0
    ; substitute (csp := csp)(tbl := tbl)(cs := cs)(s := s)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    ; create a1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3606
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab3607

lab3606:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3604
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3597
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3595
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3596

lab3595:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3596:

lab3597:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3600
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3598
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3599

lab3598:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3599:

lab3600:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3603
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3601
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3602

lab3601:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3602:

lab3603:
    jmp lab3605

lab3604:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3605:

lab3607:
    ; #load tag
    lea r13, [rel List_Node_Pair_List_Assign_List_List_ConflictSet_3608]
    ; substitute (a1 := a1)(cs := cs)(tbl := tbl)(s := s)(csp := csp);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create x2: Fun[Node[List[Assign]], Node[Pair[List[Assign], List[List[ConflictSet]]]]] = (tbl, s, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3620
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3621

lab3620:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3618
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3611
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3609
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3610

lab3609:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3610:

lab3611:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3614
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3612
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3613

lab3612:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3613:

lab3614:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3617
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3615
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3616

lab3615:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3616:

lab3617:
    jmp lab3619

lab3618:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3619:

lab3621:
    ; #load tag
    lea r9, [rel Fun_Node_List_Assign_Node_Pair_List_Assign_List_List_ConflictSet_3622]
    ; substitute (x2 := x2)(cs := cs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump checks_map_
    jmp checks_map_

Fun_Node_List_Assign_Node_Pair_List_Assign_List_List_ConflictSet_3622:

Fun_Node_List_Assign_Node_Pair_List_Assign_List_List_ConflictSet_3622_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3626
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3623
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3623:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3624
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3624:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3625
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3625:
    jmp lab3627

lab3626:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3627:
    ; substitute (csp0 := csp)(s := s)(tbl := tbl)(a2 := a2)(csp := csp)(x := x);
    ; #share csp
    cmp r12, 0
    je lab3628
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3628:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    mov rax, r12
    mov rdx, r13
    ; create a3: List[List[ConflictSet]] = (a2, csp, x)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3640
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3641

lab3640:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3638
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3631
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3629
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3630

lab3629:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3630:

lab3631:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3634
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3632
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3633

lab3632:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3633:

lab3634:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3637
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3635
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3636

lab3635:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3636:

lab3637:
    jmp lab3639

lab3638:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3639:

lab3641:
    ; #load tag
    lea r11, [rel List_List_ConflictSet_3642]
    ; substitute (tbl := tbl)(s := s)(csp0 := csp0)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create a4: List[List[ConflictSet]] = (s, csp0, a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3654
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab3655

lab3654:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3652
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3645
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3643
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3644

lab3643:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3644:

lab3645:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3648
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3646
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3647

lab3646:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3647:

lab3648:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3651
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3649
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3650

lab3649:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3650:

lab3651:
    jmp lab3653

lab3652:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3653:

lab3655:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_3656]
    ; jump checks_tail_
    jmp checks_tail_

List_List_ConflictSet_3656:
    jmp near List_List_ConflictSet_3656_Nil
    jmp near List_List_ConflictSet_3656_Cons

List_List_ConflictSet_3656_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3660
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab3657
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3657:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab3658
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3658:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab3659
    ; ####increment refcount
    add qword [rax + 0], 1

lab3659:
    jmp lab3661

lab3660:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab3661:
    ; let x4: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (s := s)(csp0 := csp0)(x4 := x4)(a3 := a3);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; jump fill_table_
    jmp fill_table_

List_List_ConflictSet_3656_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3665
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3662
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3662:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3663
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3663:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3664
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3664:
    jmp lab3666

lab3665:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3666:
    ; substitute (a3 := a3)(csp0 := csp0)(s := s)(a7 := a7)(as2 := as2);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x4: List[List[ConflictSet]] = Cons(a7, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3678
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3679

lab3678:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3676
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3669
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3667
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3668

lab3667:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3668:

lab3669:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3672
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3670
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3671

lab3670:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3671:

lab3672:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3675
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3673
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3674

lab3673:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3674:

lab3675:
    jmp lab3677

lab3676:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3677:

lab3679:
    ; #load tag
    mov r11, 5
    ; substitute (s := s)(csp0 := csp0)(x4 := x4)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump fill_table_
    jmp fill_table_

List_List_ConflictSet_3642:
    jmp near List_List_ConflictSet_3642_Nil
    jmp near List_List_ConflictSet_3642_Cons

List_List_ConflictSet_3642_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3683
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab3680
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3680:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab3681
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3681:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab3682
    ; ####increment refcount
    add qword [rax + 0], 1

lab3682:
    jmp lab3684

lab3683:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab3684:
    ; let x3: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (csp := csp)(x3 := x3)(x := x)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_List_ConflictSet_3642_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3688
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3685
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3685:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3686
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3686:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3687
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3687:
    jmp lab3689

lab3688:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3689:
    ; substitute (x := x)(csp := csp)(a2 := a2)(a6 := a6)(as1 := as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x3: List[List[ConflictSet]] = Cons(a6, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3701
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3702

lab3701:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3699
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3692
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3690
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3691

lab3690:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3691:

lab3692:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3695
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3693
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3694

lab3693:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3694:

lab3695:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3698
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3696
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3697

lab3696:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3697:

lab3698:
    jmp lab3700

lab3699:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3700:

lab3702:
    ; #load tag
    mov r11, 5
    ; substitute (csp := csp)(x3 := x3)(x := x)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r10
    mov r10, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r11
    mov r11, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_Node_Pair_List_Assign_List_List_ConflictSet_3608:
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3608_Nil
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_3608_Cons

List_Node_Pair_List_Assign_List_List_ConflictSet_3608_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3705
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3703
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3703:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3704
    ; ####increment refcount
    add qword [rax + 0], 1

lab3704:
    jmp lab3706

lab3705:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3706:
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_List_List_ConflictSet_3608_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3709
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3707
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3707:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3708
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3708:
    jmp lab3710

lab3709:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3710:
    ; substitute (x0 := x0)(a0 := a0)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3722
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3723

lab3722:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3720
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3713
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3711
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3712

lab3711:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3712:

lab3713:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3716
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3714
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3715

lab3714:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3715:

lab3716:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3719
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3717
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3718

lab3717:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3718:

lab3719:
    jmp lab3721

lab3720:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3721:

lab3723:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bm_fst_:
    ; substitute (a0 := a0)(x := x);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch x \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3724:

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3724_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3727
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3725
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3725:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3726
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3726:
    jmp lab3728

lab3727:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3728:
    ; substitute (a0 := a0)(p := p);
    ; #erase ls
    cmp r8, 0
    je lab3731
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab3729
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab3730

lab3729:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab3730:

lab3731:
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_3732:

Pair_List_Assign_ConflictSet_3732_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab3735
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab3733
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3733:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab3734
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3734:
    jmp lab3736

lab3735:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab3736:
    ; substitute (a1 := a1)(b0 := b0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

bm_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3737]
    add rcx, r9
    jmp rcx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3737:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3737_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3737_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3737_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab3740
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab3738
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab3739

lab3738:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab3739:

lab3740:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3737_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3743
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3741
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3741:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3742
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3742:
    jmp lab3744

lab3743:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3744:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab3745
    ; ####increment refcount
    add qword [rax + 0], 1

lab3745:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3757
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3758

lab3757:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3755
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3748
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3746
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3747

lab3746:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3747:

lab3748:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3751
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3749
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3750

lab3749:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3750:

lab3751:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3754
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3752
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3753

lab3752:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3753:

lab3754:
    jmp lab3756

lab3755:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3756:

lab3758:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_3759]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_3759:

Node_Pair_List_Assign_ConflictSet_3759_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3763
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3760
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3760:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3761
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3761:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3762
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3762:
    jmp lab3764

lab3763:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3764:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3776
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3777

lab3776:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3774
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3767
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3765
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3766

lab3765:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3766:

lab3767:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3770
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3768
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3769

lab3768:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3769:

lab3770:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3773
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3771
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3772

lab3771:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3772:

lab3773:
    jmp lab3775

lab3774:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3775:

lab3777:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3789
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3790

lab3789:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3787
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3780
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3778
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3779

lab3778:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3779:

lab3780:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3783
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3781
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3782

lab3781:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3782:

lab3783:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3786
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3784
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3785

lab3784:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3785:

lab3786:
    jmp lab3788

lab3787:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3788:

lab3790:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_3791]
    ; jump bm_map_
    jmp bm_map_

List_Node_Pair_List_Assign_ConflictSet_3791:
    jmp near List_Node_Pair_List_Assign_ConflictSet_3791_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_3791_Cons

List_Node_Pair_List_Assign_ConflictSet_3791_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3794
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3792
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3792:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3793
    ; ####increment refcount
    add qword [rax + 0], 1

lab3793:
    jmp lab3795

lab3794:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3795:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_3791_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3798
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3796
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3796:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3797
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3797:
    jmp lab3799

lab3798:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3799:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3811
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3812

lab3811:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3809
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3802
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3800
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3801

lab3800:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3801:

lab3802:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3805
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3803
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3804

lab3803:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3804:

lab3805:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3808
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3806
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3807

lab3806:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3807:

lab3808:
    jmp lab3810

lab3809:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3810:

lab3812:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bm_map_tree_:
    ; substitute (f := f)(a0 := a0)(t := t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3813:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3813_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3816
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3814
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3814:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3815
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3815:
    jmp lab3817

lab3816:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3817:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab3818
    ; ####increment refcount
    add qword [rax + 0], 1

lab3818:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[List[Assign], ConflictSet] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3830
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3831

lab3830:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3828
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3821
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3819
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3820

lab3819:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3820:

lab3821:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3824
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3822
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3823

lab3822:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3823:

lab3824:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3827
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3825
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3826

lab3825:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3826:

lab3827:
    jmp lab3829

lab3828:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3829:

lab3831:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_3832]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_List_Assign_ConflictSet_3832:

Pair_List_Assign_ConflictSet_3832_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3836
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3833
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3833:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3834
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3834:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3835
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3835:
    jmp lab3837

lab3836:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3837:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a5 := a5)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3849
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3850

lab3849:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3847
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3840
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3838
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3839

lab3838:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3839:

lab3840:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3843
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3841
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3842

lab3841:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3842:

lab3843:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3846
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3844
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3845

lab3844:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3845:

lab3846:
    jmp lab3848

lab3847:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3848:

lab3850:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3862
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3863

lab3862:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3860
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3853
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3851
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3852

lab3851:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3852:

lab3853:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3856
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3854
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3855

lab3854:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3855:

lab3856:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3859
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3857
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3858

lab3857:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3858:

lab3859:
    jmp lab3861

lab3860:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3861:

lab3863:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_3864]
    ; substitute (a2 := a2)(ps := ps)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x2: Fun[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]], Node[Pair[List[Assign], ConflictSet]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3876
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3877

lab3876:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3874
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3867
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3865
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3866

lab3865:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3866:

lab3867:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3870
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3868
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3869

lab3868:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3869:

lab3870:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3873
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3871
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3872

lab3871:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3872:

lab3873:
    jmp lab3875

lab3874:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3875:

lab3877:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_3878]
    ; substitute (x2 := x2)(ps := ps)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bm_map_
    jmp bm_map_

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_3878:

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_3878_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3880
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab3879
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3879:
    jmp lab3881

lab3880:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab3881:
    ; substitute (f := f)(x := x)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bm_map_tree_
    jmp bm_map_tree_

List_Node_Pair_List_Assign_ConflictSet_3864:
    jmp near List_Node_Pair_List_Assign_ConflictSet_3864_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_3864_Cons

List_Node_Pair_List_Assign_ConflictSet_3864_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3884
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab3882
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3882:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab3883
    ; ####increment refcount
    add qword [rax + 0], 1

lab3883:
    jmp lab3885

lab3884:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab3885:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_3864_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3888
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3886
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3886:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3887
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3887:
    jmp lab3889

lab3888:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3889:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3901
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3902

lab3901:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3899
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3892
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3890
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3891

lab3890:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3891:

lab3892:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3895
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3893
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3894

lab3893:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3894:

lab3895:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3898
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3896
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3897

lab3896:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3897:

lab3898:
    jmp lab3900

lab3899:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3900:

lab3902:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bm_:
    ; create x0: Fun[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_3903]
    ; create a2: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3915
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3916

lab3915:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3913
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3906
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3904
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3905

lab3904:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3905:

lab3906:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3909
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3907
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3908

lab3907:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3908:

lab3909:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3912
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3910
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3911

lab3910:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3911:

lab3912:
    jmp lab3914

lab3913:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3914:

lab3916:
    ; #load tag
    lea r9, [rel Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3917]
    ; substitute (csp0 := csp)(t := t)(a2 := a2)(csp := csp);
    ; #share csp
    cmp rax, 0
    je lab3918
    ; ####increment refcount
    add qword [rax + 0], 1

lab3918:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a3: Node[Pair[List[Assign], List[List[ConflictSet]]]] = (a2, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3930
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3931

lab3930:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3928
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3921
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3919
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3920

lab3919:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3920:

lab3921:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3924
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3922
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3923

lab3922:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3923:

lab3924:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3927
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3925
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3926

lab3925:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3926:

lab3927:
    jmp lab3929

lab3928:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3929:

lab3931:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_List_List_ConflictSet_3932]
    ; substitute (csp00 := csp0)(t := t)(a3 := a3)(csp0 := csp0);
    ; #share csp0
    cmp rax, 0
    je lab3933
    ; ####increment refcount
    add qword [rax + 0], 1

lab3933:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a4: List[List[ConflictSet]] = (t, a3, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3945
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab3946

lab3945:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3943
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3936
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3934
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3935

lab3934:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3935:

lab3936:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3939
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3937
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3938

lab3937:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3938:

lab3939:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3942
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3940
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3941

lab3940:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3941:

lab3942:
    jmp lab3944

lab3943:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3944:

lab3946:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_3947]
    ; jump empty_table_
    jmp empty_table_

List_List_ConflictSet_3947:
    jmp near List_List_ConflictSet_3947_Nil
    jmp near List_List_ConflictSet_3947_Cons

List_List_ConflictSet_3947_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab3951
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab3948
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3948:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab3949
    ; ####increment refcount
    add qword [rsi + 0], 1

lab3949:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab3950
    ; ####increment refcount
    add qword [rax + 0], 1

lab3950:
    jmp lab3952

lab3951:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab3952:
    ; let x3: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (csp0 := csp0)(x3 := x3)(t := t)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_List_ConflictSet_3947_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3956
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab3953
    ; ####increment refcount
    add qword [r12 + 0], 1

lab3953:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab3954
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3954:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab3955
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3955:
    jmp lab3957

lab3956:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab3957:
    ; substitute (csp0 := csp0)(a3 := a3)(t := t)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x3: List[List[ConflictSet]] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3969
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab3970

lab3969:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3967
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3960
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3958
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3959

lab3958:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3959:

lab3960:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3963
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3961
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3962

lab3961:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3962:

lab3963:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3965

lab3964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3965:

lab3966:
    jmp lab3968

lab3967:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3968:

lab3970:
    ; #load tag
    mov r11, 5
    ; substitute (csp0 := csp0)(x3 := x3)(t := t)(a3 := a3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

Node_Pair_List_Assign_List_List_ConflictSet_3932:

Node_Pair_List_Assign_List_List_ConflictSet_3932_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3973
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3971
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3971:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3972
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3972:
    jmp lab3974

lab3973:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3974:
    ; substitute (csp := csp)(a2 := a2)(lab1 := lab1)(children1 := children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: Node[Pair[List[Assign], List[List[ConflictSet]]]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab3986
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab3987

lab3986:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab3984
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3977
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3975
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3976

lab3975:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3976:

lab3977:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3980
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3978
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3979

lab3978:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3979:

lab3980:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab3983
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3981
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3982

lab3981:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3982:

lab3983:
    jmp lab3985

lab3984:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab3985:

lab3987:
    ; #load tag
    mov r9, 0
    ; substitute (csp := csp)(x2 := x2)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lookup_cache_
    jmp lookup_cache_

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3917:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_3917_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab3990
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab3988
    ; ####increment refcount
    add qword [r10 + 0], 1

lab3988:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab3989
    ; ####increment refcount
    add qword [r8 + 0], 1

lab3989:
    jmp lab3991

lab3990:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab3991:
    ; substitute (x0 := x0)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4003
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4004

lab4003:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4001
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab3994
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3992
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3993

lab3992:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3993:

lab3994:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab3997
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3995
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3996

lab3995:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3996:

lab3997:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4000
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab3998
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab3999

lab3998:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab3999:

lab4000:
    jmp lab4002

lab4001:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4002:

lab4004:
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump bm_map_tree_
    jmp bm_map_tree_

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_3903:

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_3903_Apply:
    ; jump bm_fst_
    jmp bm_fst_

in_list_:
    ; substitute (i := i)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_4005]
    add rcx, r9
    jmp rcx

List_i64_4005:
    jmp near List_i64_4005_Nil
    jmp near List_i64_4005_Cons

List_i64_4005_Nil:
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 False
    add rdx, 5
    jmp rdx

List_i64_4005_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4007
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4006
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4006:
    mov r9, [r8 + 40]
    jmp lab4008

lab4007:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4008:
    ; if i == j \{ ... \}
    cmp rdx, r9
    je lab4009
    ; else branch
    ; substitute (i := i)(js := js)(a0 := a0);
    ; #move variables
    mov r8, rsi
    mov r9, rdi
    mov rsi, r10
    mov rdi, r11
    ; jump in_list_
    jmp in_list_

lab4009:
    ; then branch
    ; substitute (a0 := a0);
    ; #erase js
    cmp r10, 0
    je lab4012
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab4010
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab4011

lab4010:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab4011:

lab4012:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 True
    add rdx, 0
    jmp rdx

not_elem_:
    ; create a1: Bool = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4024
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4025

lab4024:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4022
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4015
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4013
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4014

lab4013:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4014:

lab4015:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4018
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4016
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4017

lab4016:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4017:

lab4018:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4021
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4019
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4020

lab4019:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4020:

lab4021:
    jmp lab4023

lab4022:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4023:

lab4025:
    ; #load tag
    lea r9, [rel Bool_4026]
    ; jump in_list_
    jmp in_list_

Bool_4026:
    jmp near Bool_4026_True
    jmp near Bool_4026_False

Bool_4026_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4028
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4027
    ; ####increment refcount
    add qword [rax + 0], 1

lab4027:
    jmp lab4029

lab4028:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4029:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_4026_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4031
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4030
    ; ####increment refcount
    add qword [rax + 0], 1

lab4030:
    jmp lab4032

lab4031:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4032:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

append_:
    ; substitute (a0 := a0)(l2 := l2)(l1 := l1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch l1 \{ ... \};
    lea rcx, [rel List_i64_4033]
    add rcx, r9
    jmp rcx

List_i64_4033:
    jmp near List_i64_4033_Nil
    jmp near List_i64_4033_Cons

List_i64_4033_Nil:
    ; switch l2 \{ ... \};
    lea rcx, [rel List_i64_4034]
    add rcx, rdi
    jmp rcx

List_i64_4034:
    jmp near List_i64_4034_Nil
    jmp near List_i64_4034_Cons

List_i64_4034_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4034_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4036
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4035
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4035:
    mov rdi, [rsi + 40]
    jmp lab4037

lab4036:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4037:
    ; substitute (a2 := a2)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4033_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4039
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4038
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4038:
    mov r9, [r8 + 40]
    jmp lab4040

lab4039:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4040:
    ; substitute (iss := iss)(l2 := l2)(is := is)(a0 := a0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a1: List[i64] = (is, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4052
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4053

lab4052:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4050
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4043
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4041
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4042

lab4041:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4042:

lab4043:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4046
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4044
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4045

lab4044:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4045:

lab4046:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4049
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4047
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4048

lab4047:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4048:

lab4049:
    jmp lab4051

lab4050:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4051:

lab4053:
    ; #load tag
    lea r9, [rel List_i64_4054]
    ; jump append_
    jmp append_

List_i64_4054:
    jmp near List_i64_4054_Nil
    jmp near List_i64_4054_Cons

List_i64_4054_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4056
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4055
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4055:
    mov rdx, [rax + 40]
    jmp lab4057

lab4056:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab4057:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (is := is)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4054_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4059
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4058
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4058:
    mov r9, [r8 + 40]
    jmp lab4060

lab4059:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4060:
    ; substitute (a0 := a0)(is := is)(a3 := a3)(as1 := as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a3, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4072
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4073

lab4072:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4070
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4063
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4061
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4062

lab4061:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4062:

lab4063:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4066
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4064
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4065

lab4064:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4065:

lab4066:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4069
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4067
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4068

lab4067:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4068:

lab4069:
    jmp lab4071

lab4070:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4071:

lab4073:
    ; #load tag
    mov r9, 5
    ; substitute (is := is)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

delete_by_:
    ; substitute (f := f)(x := x)(a0 := a0)(ys := ys);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch ys \{ ... \};
    lea rcx, [rel List_i64_4074]
    add rcx, r11
    jmp rcx

List_i64_4074:
    jmp near List_i64_4074_Nil
    jmp near List_i64_4074_Cons

List_i64_4074_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab4077
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4075
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4076

lab4075:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4076:

lab4077:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4074_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab4079
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab4078
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4078:
    mov r11, [r10 + 40]
    jmp lab4080

lab4079:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]

lab4080:
    ; substitute (f0 := f)(x1 := x)(y0 := y)(y := y)(ys0 := ys0)(f := f)(x := x)(a0 := a0);
    ; #share f
    cmp rax, 0
    je lab4081
    ; ####increment refcount
    add qword [rax + 0], 1

lab4081:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov [rsp + 2024], rdi
    mov [rsp + 2016], r8
    mov [rsp + 2008], r9
    mov r9, r11
    ; create a2: Bool = (y, ys0, f, x, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov [rbx + 24], r15
    mov [rbx + 16], r14
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4093
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab4094

lab4093:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4091
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4084
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4082
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4083

lab4082:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4083:

lab4084:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4087
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4085
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4086

lab4085:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4086:

lab4087:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4090
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4088
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4089

lab4088:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4089:

lab4090:
    jmp lab4092

lab4091:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4092:

lab4094:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4106
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4107

lab4106:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4104
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4097
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4095
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4096

lab4095:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4096:

lab4097:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4100
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4098
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4099

lab4098:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4099:

lab4100:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4103
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4101
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4102

lab4101:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4102:

lab4103:
    jmp lab4105

lab4104:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4105:

lab4107:
    ; #load tag
    lea r11, [rel Bool_4108]
    ; let a3: Fun[i64, Bool] = Apply(y0, a2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4120
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4121

lab4120:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4118
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4110

lab4109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4110:

lab4111:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4114
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4112
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4113

lab4112:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4113:

lab4114:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4117
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4115
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4116

lab4115:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4116:

lab4117:
    jmp lab4119

lab4118:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4119:

lab4121:
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(a3 := a3)(f0 := f0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_4108:
    jmp near Bool_4108_True
    jmp near Bool_4108_False

Bool_4108_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4125
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4122
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4122:
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4123
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4123:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4124
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4124:
    jmp lab4126

lab4125:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4126:
    ; substitute (a0 := a0)(ys0 := ys0);
    ; #erase f
    cmp r8, 0
    je lab4129
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab4127
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab4128

lab4127:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab4128:

lab4129:
    ; #move variables
    mov rax, r12
    mov rdx, r13
    ; switch ys0 \{ ... \};
    lea rcx, [rel List_i64_4130]
    add rcx, rdi
    jmp rcx

List_i64_4130:
    jmp near List_i64_4130_Nil
    jmp near List_i64_4130_Cons

List_i64_4130_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4130_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4132
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4131
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4131:
    mov rdi, [rsi + 40]
    jmp lab4133

lab4132:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4133:
    ; substitute (a4 := a4)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_4108_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4137
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4134
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4134:
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4135
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4135:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4136
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4136:
    jmp lab4138

lab4137:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4138:
    ; substitute (x := x)(ys0 := ys0)(f := f)(y := y)(a0 := a0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a1: List[i64] = (y, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4150
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4151

lab4150:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4148
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4141
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4139
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4140

lab4139:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4140:

lab4141:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4144
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4142
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4143

lab4142:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4143:

lab4144:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4147
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4145
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4146

lab4145:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4146:

lab4147:
    jmp lab4149

lab4148:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4149:

lab4151:
    ; #load tag
    lea r11, [rel List_i64_4152]
    ; substitute (f := f)(x := x)(ys0 := ys0)(a1 := a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump delete_by_
    jmp delete_by_

List_i64_4152:
    jmp near List_i64_4152_Nil
    jmp near List_i64_4152_Cons

List_i64_4152_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4154
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4153
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4153:
    mov rdx, [rax + 40]
    jmp lab4155

lab4154:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab4155:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (y := y)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4152_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4157
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4156
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4156:
    mov r9, [r8 + 40]
    jmp lab4158

lab4157:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4158:
    ; substitute (a0 := a0)(y := y)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4170
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4171

lab4170:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4168
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4161
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4159
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4160

lab4159:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4160:

lab4161:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4164
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4162
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4163

lab4162:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4163:

lab4164:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4167
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4165
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4166

lab4165:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4166:

lab4167:
    jmp lab4169

lab4168:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4169:

lab4171:
    ; #load tag
    mov r9, 5
    ; substitute (y := y)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

nub_by_:
    ; substitute (f := f)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_4172]
    add rcx, r9
    jmp rcx

List_i64_4172:
    jmp near List_i64_4172_Nil
    jmp near List_i64_4172_Cons

List_i64_4172_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab4175
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4173
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4174

lab4173:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4174:

lab4175:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4172_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4177
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4176
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4176:
    mov r9, [r8 + 40]
    jmp lab4178

lab4177:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4178:
    ; substitute (f := f)(t := t)(h0 := h)(h := h)(a0 := a0);
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    mov rdi, r11
    mov r11, r9
    mov rsi, r10
    ; create a1: List[i64] = (h, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4190
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4191

lab4190:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4188
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4181
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4179
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4180

lab4179:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4180:

lab4181:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4184
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4182
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4183

lab4182:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4183:

lab4184:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4187
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4185
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4186

lab4185:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4186:

lab4187:
    jmp lab4189

lab4188:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4189:

lab4191:
    ; #load tag
    lea r11, [rel List_i64_4192]
    ; substitute (f0 := f)(t := t)(h0 := h0)(a1 := a1)(f := f);
    ; #share f
    cmp rax, 0
    je lab4193
    ; ####increment refcount
    add qword [rax + 0], 1

lab4193:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    ; create a2: List[i64] = (a1, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4205
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4206

lab4205:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4203
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4196
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4194
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4195

lab4194:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4195:

lab4196:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4199
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4197
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4198

lab4197:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4198:

lab4199:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4202
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4200
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4201

lab4200:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4201:

lab4202:
    jmp lab4204

lab4203:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4204:

lab4206:
    ; #load tag
    lea r11, [rel List_i64_4207]
    ; substitute (a2 := a2)(t := t)(h0 := h0)(f0 := f0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create x2: Fun[i64, Bool] = (h0, f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4219
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4220

lab4219:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4217
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4210
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4208
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4209

lab4208:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4209:

lab4210:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4213
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4211
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4212

lab4211:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4212:

lab4213:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4216
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4214
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4215

lab4214:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4215:

lab4216:
    jmp lab4218

lab4217:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4218:

lab4220:
    ; #load tag
    lea r9, [rel Fun_i64_Bool_4221]
    ; substitute (x2 := x2)(t := t)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump filter_union_
    jmp filter_union_

Fun_i64_Bool_4221:

Fun_i64_Bool_4221_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4223
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4222
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4222:
    mov r9, [r8 + 40]
    jmp lab4224

lab4223:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4224:
    ; substitute (y := y)(f0 := f0)(h0 := h0)(a3 := a3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a4: Bool = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4236
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4237

lab4236:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4234
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4227
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4225
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4226

lab4225:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4226:

lab4227:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4230
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4228
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4229

lab4228:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4229:

lab4230:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4233
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4231
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4232

lab4231:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4232:

lab4233:
    jmp lab4235

lab4234:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4235:

lab4237:
    ; #load tag
    lea r11, [rel Bool_4238]
    ; substitute (h0 := h0)(f0 := f0)(y := y)(a4 := a4);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let a5: Fun[i64, Bool] = Apply(y, a4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4250
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4251

lab4250:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4248
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4241
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4239
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4240

lab4239:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4240:

lab4241:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4244
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4242
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4243

lab4242:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4243:

lab4244:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4247
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4245
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4246

lab4245:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4246:

lab4247:
    jmp lab4249

lab4248:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4249:

lab4251:
    ; #load tag
    mov r9, 0
    ; substitute (h0 := h0)(a5 := a5)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_4238:
    jmp near Bool_4238_True
    jmp near Bool_4238_False

Bool_4238_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4253
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4252
    ; ####increment refcount
    add qword [rax + 0], 1

lab4252:
    jmp lab4254

lab4253:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4254:
    ; let x3: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x3 := x3)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_4238_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4256
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4255
    ; ####increment refcount
    add qword [rax + 0], 1

lab4255:
    jmp lab4257

lab4256:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4257:
    ; let x3: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x3 := x3)(a3 := a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

List_i64_4207:
    jmp near List_i64_4207_Nil
    jmp near List_i64_4207_Cons

List_i64_4207_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4260
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4258
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4258:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4259
    ; ####increment refcount
    add qword [rax + 0], 1

lab4259:
    jmp lab4261

lab4260:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab4261:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (f := f)(x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump nub_by_
    jmp nub_by_

List_i64_4207_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4264
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4262
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4262:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4263
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4263:
    jmp lab4265

lab4264:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4265:
    ; substitute (f := f)(a1 := a1)(a7 := a7)(as1 := as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a7, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4277
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4278

lab4277:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4275
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4268
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4266
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4267

lab4266:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4267:

lab4268:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4271
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4269
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4270

lab4269:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4270:

lab4271:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4274
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4272
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4273

lab4272:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4273:

lab4274:
    jmp lab4276

lab4275:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4276:

lab4278:
    ; #load tag
    mov r9, 5
    ; substitute (f := f)(x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump nub_by_
    jmp nub_by_

List_i64_4192:
    jmp near List_i64_4192_Nil
    jmp near List_i64_4192_Cons

List_i64_4192_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4280
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4279
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4279:
    mov rdx, [rax + 40]
    jmp lab4281

lab4280:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab4281:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (h := h)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4192_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4283
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4282
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4282:
    mov r9, [r8 + 40]
    jmp lab4284

lab4283:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4284:
    ; substitute (a0 := a0)(h := h)(a6 := a6)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4296
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4297

lab4296:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4294
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4287
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4285
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4286

lab4285:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4286:

lab4287:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4290
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4288
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4289

lab4288:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4289:

lab4290:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4293
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4291
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4292

lab4291:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4292:

lab4293:
    jmp lab4295

lab4294:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4295:

lab4297:
    ; #load tag
    mov r9, 5
    ; substitute (h := h)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

filter_union_:
    ; substitute (f := f)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_4298]
    add rcx, r9
    jmp rcx

List_i64_4298:
    jmp near List_i64_4298_Nil
    jmp near List_i64_4298_Cons

List_i64_4298_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab4301
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4299
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4300

lab4299:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4300:

lab4301:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4298_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4303
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4302
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4302:
    mov r9, [r8 + 40]
    jmp lab4304

lab4303:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4304:
    ; substitute (f0 := f)(i0 := i)(i := i)(is := is)(f := f)(a0 := a0);
    ; #share f
    cmp rax, 0
    je lab4305
    ; ####increment refcount
    add qword [rax + 0], 1

lab4305:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rdi, r9
    ; create a2: Bool = (i, is, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4317
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4318

lab4317:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4315
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4308
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4306
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4307

lab4306:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4307:

lab4308:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4311
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4309
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4310

lab4309:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4310:

lab4311:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4314
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4312
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4313

lab4312:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4313:

lab4314:
    jmp lab4316

lab4315:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4316:

lab4318:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4330
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4331

lab4330:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4328
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4321
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4319
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4320

lab4319:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4320:

lab4321:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4324
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4322
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4323

lab4322:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4323:

lab4324:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4327
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4325
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4326

lab4325:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4326:

lab4327:
    jmp lab4329

lab4328:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4329:

lab4331:
    ; #load tag
    lea r9, [rel Bool_4332]
    ; substitute (i0 := i0)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_4332:
    jmp near Bool_4332_True
    jmp near Bool_4332_False

Bool_4332_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4336
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4333
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4333:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4334
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4334:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4335
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4335:
    jmp lab4337

lab4336:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4337:
    ; substitute (f := f)(is := is)(i := i)(a0 := a0);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r8
    ; create a1: List[i64] = (i, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4349
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4350

lab4349:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4347
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4340
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4338
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4339

lab4338:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4339:

lab4340:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4343
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4341
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4342

lab4341:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4342:

lab4343:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4346
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4344
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4345

lab4344:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4345:

lab4346:
    jmp lab4348

lab4347:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4348:

lab4350:
    ; #load tag
    lea r9, [rel List_i64_4351]
    ; jump filter_union_
    jmp filter_union_

List_i64_4351:
    jmp near List_i64_4351_Nil
    jmp near List_i64_4351_Cons

List_i64_4351_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4353
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4352
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4352:
    mov rdx, [rax + 40]
    jmp lab4354

lab4353:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab4354:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (i := i)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4351_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4356
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4355
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4355:
    mov r9, [r8 + 40]
    jmp lab4357

lab4356:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4357:
    ; substitute (a0 := a0)(i := i)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4369
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4370

lab4369:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4367
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4360
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4358
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4359

lab4358:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4359:

lab4360:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4363
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4361
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4362

lab4361:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4362:

lab4363:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4366
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4364
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4365

lab4364:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4365:

lab4366:
    jmp lab4368

lab4367:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4368:

lab4370:
    ; #load tag
    mov r9, 5
    ; substitute (i := i)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_4332_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4374
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4371
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4371:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4372
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4372:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4373
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4373:
    jmp lab4375

lab4374:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4375:
    ; substitute (f := f)(is := is)(a0 := a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump filter_union_
    jmp filter_union_

foldl_:
    ; substitute (f := f)(a := a)(a0 := a0)(xs := xs);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch xs \{ ... \};
    lea rcx, [rel List_i64_4376]
    add rcx, r11
    jmp rcx

List_i64_4376:
    jmp near List_i64_4376_Nil
    jmp near List_i64_4376_Cons

List_i64_4376_Nil:
    ; substitute (a0 := a0)(a := a);
    ; #erase f
    cmp rax, 0
    je lab4379
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4377
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4378

lab4377:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4378:

lab4379:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; switch a \{ ... \};
    lea rcx, [rel List_i64_4380]
    add rcx, rdi
    jmp rcx

List_i64_4380:
    jmp near List_i64_4380_Nil
    jmp near List_i64_4380_Cons

List_i64_4380_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4380_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4382
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4381
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4381:
    mov rdi, [rsi + 40]
    jmp lab4383

lab4382:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4383:
    ; substitute (a3 := a3)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_4376_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab4385
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab4384
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4384:
    mov r11, [r10 + 40]
    jmp lab4386

lab4385:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]

lab4386:
    ; substitute (f0 := f)(a := a)(h := h)(a0 := a0)(t := t)(f := f);
    ; #share f
    cmp rax, 0
    je lab4387
    ; ####increment refcount
    add qword [rax + 0], 1

lab4387:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov r10, r8
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; create a1: List[i64] = (a0, t, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4399
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4400

lab4399:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4397
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4390
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4388
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4389

lab4388:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4389:

lab4390:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4392

lab4391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4392:

lab4393:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4396
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4394
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4395

lab4394:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4395:

lab4396:
    jmp lab4398

lab4397:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4398:

lab4400:
    ; #load tag
    lea r11, [rel List_i64_4401]
    ; let a2: Fun[i64, List[i64]] = Apply(h, a1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4413
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4414

lab4413:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4411
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4404
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4402
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4403

lab4402:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4403:

lab4404:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4407
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4405
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4406

lab4405:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4406:

lab4407:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4410
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4408
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4409

lab4408:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4409:

lab4410:
    jmp lab4412

lab4411:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4412:

lab4414:
    ; #load tag
    mov r9, 0
    ; substitute (a := a)(a2 := a2)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_i64_4401:
    jmp near List_i64_4401_Nil
    jmp near List_i64_4401_Cons

List_i64_4401_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4418
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab4415
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4415:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4416
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4416:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab4417
    ; ####increment refcount
    add qword [rax + 0], 1

lab4417:
    jmp lab4419

lab4418:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab4419:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (f := f)(x0 := x0)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump foldl_
    jmp foldl_

List_i64_4401_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4423
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4420
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4420:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4421
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4421:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4422
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4422:
    jmp lab4424

lab4423:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4424:
    ; substitute (f := f)(t := t)(a0 := a0)(a4 := a4)(as1 := as1);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x0: List[i64] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4436
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4437

lab4436:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4434
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4427
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4425
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4426

lab4425:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4426:

lab4427:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4430
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4428
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4429

lab4428:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4429:

lab4430:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4433
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4431
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4432

lab4431:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4432:

lab4433:
    jmp lab4435

lab4434:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4435:

lab4437:
    ; #load tag
    mov r11, 5
    ; substitute (f := f)(x0 := x0)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump foldl_
    jmp foldl_

union_by_:
    ; substitute (f := f)(l10 := l1)(l2 := l2)(a0 := a0)(l1 := l1);
    ; #share l1
    cmp rsi, 0
    je lab4438
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4438:
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    ; create a1: List[i64] = (a0, l1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4450
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4451

lab4450:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4448
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4441
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4439
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4440

lab4439:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4440:

lab4441:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4444
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4442
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4443

lab4442:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4443:

lab4444:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4447
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4445
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4446

lab4445:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4446:

lab4447:
    jmp lab4449

lab4448:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4449:

lab4451:
    ; #load tag
    lea r11, [rel List_i64_4452]
    ; substitute (f0 := f)(l10 := l10)(l2 := l2)(a1 := a1)(f := f);
    ; #share f
    cmp rax, 0
    je lab4453
    ; ####increment refcount
    add qword [rax + 0], 1

lab4453:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    ; create x1: Fun[List[i64], Fun[i64, List[i64]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4465
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab4466

lab4465:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4463
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4456
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4454
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4455

lab4454:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4455:

lab4456:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4459
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4457
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4458

lab4457:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4458:

lab4459:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4462
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4460
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4461

lab4460:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4461:

lab4462:
    jmp lab4464

lab4463:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4464:

lab4466:
    ; #load tag
    lea r13, [rel Fun_List_i64_Fun_i64_List_i64_4467]
    ; substitute (f0 := f0)(l2 := l2)(l10 := l10)(a1 := a1)(x1 := x1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a4: List[i64] = (l10, a1, x1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4479
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4480

lab4479:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4477
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4470
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4468
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4469

lab4468:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4469:

lab4470:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4473
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4471
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4472

lab4471:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4472:

lab4473:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4476
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4474
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4475

lab4474:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4475:

lab4476:
    jmp lab4478

lab4477:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4478:

lab4480:
    ; #load tag
    lea r9, [rel List_i64_4481]
    ; jump nub_by_
    jmp nub_by_

List_i64_4481:
    jmp near List_i64_4481_Nil
    jmp near List_i64_4481_Cons

List_i64_4481_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4485
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab4482
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4482:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4483
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4483:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab4484
    ; ####increment refcount
    add qword [rax + 0], 1

lab4484:
    jmp lab4486

lab4485:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab4486:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (x1 := x1)(x2 := x2)(l10 := l10)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump foldl_
    jmp foldl_

List_i64_4481_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4490
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4487
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4487:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4488
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4488:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4489
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4489:
    jmp lab4491

lab4490:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4491:
    ; substitute (x1 := x1)(a1 := a1)(l10 := l10)(a6 := a6)(as1 := as1);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x2: List[i64] = Cons(a6, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4503
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4504

lab4503:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4501
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4494
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4492
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4493

lab4492:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4493:

lab4494:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4497
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4495
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4496

lab4495:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4496:

lab4497:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4500
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4498
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4499

lab4498:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4499:

lab4500:
    jmp lab4502

lab4501:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4502:

lab4504:
    ; #load tag
    mov r11, 5
    ; substitute (x1 := x1)(x2 := x2)(l10 := l10)(a1 := a1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump foldl_
    jmp foldl_

Fun_List_i64_Fun_i64_List_i64_4467:

Fun_List_i64_Fun_i64_List_i64_4467_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4506
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab4505
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4505:
    jmp lab4507

lab4506:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab4507:
    ; substitute (acc := acc)(f := f)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Fun_i64_List_i64_4508:

Fun_i64_List_i64_4508_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4510
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4509
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4509:
    mov r9, [r8 + 40]
    jmp lab4511

lab4510:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab4511:
    ; substitute (f := f)(y := y)(acc := acc)(a3 := a3);
    ; #move variables
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump delete_by_
    jmp delete_by_

List_i64_4452:
    jmp near List_i64_4452_Nil
    jmp near List_i64_4452_Cons

List_i64_4452_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4514
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4512
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4512:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4513
    ; ####increment refcount
    add qword [rax + 0], 1

lab4513:
    jmp lab4515

lab4514:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab4515:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l1 := l1)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump append_
    jmp append_

List_i64_4452_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4518
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4516
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4516:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4517
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4517:
    jmp lab4519

lab4518:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4519:
    ; substitute (l1 := l1)(a0 := a0)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4531
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4532

lab4531:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4529
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4522
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4520
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4521

lab4520:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4521:

lab4522:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4525
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4523
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4524

lab4523:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4524:

lab4525:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4528
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4526
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4527

lab4526:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4527:

lab4528:
    jmp lab4530

lab4529:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4530:

lab4532:
    ; #load tag
    mov r9, 5
    ; substitute (l1 := l1)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump append_
    jmp append_

union_:
    ; create x0: Fun[i64, Fun[i64, Bool]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_i64_Fun_i64_Bool_4533]
    ; substitute (x0 := x0)(l1 := l1)(l2 := l2)(a0 := a0);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump union_by_
    jmp union_by_

Fun_i64_Fun_i64_Bool_4533:

Fun_i64_Fun_i64_Bool_4533_Apply:
    ; switch a1 \{ ... \};
    ; #there is only one clause, so we can just fall through

Fun_i64_Bool_4534:

Fun_i64_Bool_4534_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4536
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4535
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4535:
    mov rdi, [rsi + 40]
    jmp lab4537

lab4536:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4537:
    ; jump eq_
    jmp eq_

combine_:
    ; substitute (a0 := a0)(acc := acc)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_4538]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_4538:
    jmp near List_Pair_List_Assign_ConflictSet_4538_Nil
    jmp near List_Pair_List_Assign_ConflictSet_4538_Cons

List_Pair_List_Assign_ConflictSet_4538_Nil:
    ; switch acc \{ ... \};
    lea rcx, [rel List_i64_4539]
    add rcx, rdi
    jmp rcx

List_i64_4539:
    jmp near List_i64_4539_Nil
    jmp near List_i64_4539_Cons

List_i64_4539_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4539_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4541
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4540
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4540:
    mov rdi, [rsi + 40]
    jmp lab4542

lab4541:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4542:
    ; substitute (a4 := a4)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_4538_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4545
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4543
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4543:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4544
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4544:
    jmp lab4546

lab4545:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4546:
    ; substitute (a0 := a0)(acc := acc)(css := css)(p := p);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_4547:

Pair_List_Assign_ConflictSet_4547_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab4550
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab4548
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4548:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab4549
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4549:
    jmp lab4551

lab4550:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab4551:
    ; switch cs \{ ... \};
    lea rcx, [rel ConflictSet_4552]
    add rcx, r13
    jmp rcx

ConflictSet_4552:
    jmp near ConflictSet_4552_Known
    jmp near ConflictSet_4552_Unknown

ConflictSet_4552_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab4554
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r13, [r12 + 56]
    mov r12, [r12 + 48]
    cmp r12, 0
    je lab4553
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4553:
    jmp lab4555

lab4554:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r13, [r12 + 56]
    mov r12, [r12 + 48]

lab4555:
    ; substitute (s := s)(acc := acc)(css := css)(a0 := a0)(cs0 := cs0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; create a2: _Cont = (acc, css, a0, cs0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4567
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4568

lab4567:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4565
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4558
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4556
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4557

lab4556:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4557:

lab4558:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4561
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4559
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4560

lab4559:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4560:

lab4561:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4564
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4562
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4563

lab4562:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4563:

lab4564:
    jmp lab4566

lab4565:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4566:

lab4568:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4580
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4581

lab4580:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4578
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4571
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4569
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4570

lab4569:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4570:

lab4571:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4574
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4572
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4573

lab4572:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4573:

lab4574:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4577
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4575
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4576

lab4575:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4576:

lab4577:
    jmp lab4579

lab4578:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4579:

lab4581:
    ; #load tag
    lea rdi, [rel _Cont_4582]
    ; jump max_level_
    jmp max_level_

_Cont_4582:

_Cont_4582_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4587
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab4583
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4583:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4584
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4584:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4585
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4585:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4586
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4586:
    jmp lab4588

lab4587:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4588:
    ; substitute (x0 := x0)(cs00 := cs0)(css := css)(a0 := a0)(cs0 := cs0)(acc := acc);
    ; #share cs0
    cmp r12, 0
    je lab4589
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4589:
    ; #move variables
    mov r14, rsi
    mov r15, rdi
    mov rsi, r12
    mov rdi, r13
    ; create a3: Bool = (css, a0, cs0, acc)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4601
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4602

lab4601:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4599
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4592
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4590
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4591

lab4590:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4591:

lab4592:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4595
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4593
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4594

lab4593:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4594:

lab4595:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4598
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4596
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4597

lab4596:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4597:

lab4598:
    jmp lab4600

lab4599:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4600:

lab4602:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4614
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4615

lab4614:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4612
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4605
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4603
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4604

lab4603:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4604:

lab4605:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4608
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4606
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4607

lab4606:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4607:

lab4608:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4611
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4609
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4610

lab4609:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4610:

lab4611:
    jmp lab4613

lab4612:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4613:

lab4615:
    ; #load tag
    lea r9, [rel Bool_4616]
    ; jump not_elem_
    jmp not_elem_

Bool_4616:
    jmp near Bool_4616_True
    jmp near Bool_4616_False

Bool_4616_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4621
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4617
    ; ####increment refcount
    add qword [rax + 0], 1

lab4617:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4618
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4618:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4619
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4619:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4620
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4620:
    jmp lab4622

lab4621:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4622:
    ; substitute (a0 := a0)(cs0 := cs0);
    ; #erase acc
    cmp r10, 0
    je lab4625
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab4623
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab4624

lab4623:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab4624:

lab4625:
    ; #erase css
    cmp rax, 0
    je lab4628
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4626
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4627

lab4626:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4627:

lab4628:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; switch cs0 \{ ... \};
    lea rcx, [rel List_i64_4629]
    add rcx, rdi
    jmp rcx

List_i64_4629:
    jmp near List_i64_4629_Nil
    jmp near List_i64_4629_Cons

List_i64_4629_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4629_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4631
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4630
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4630:
    mov rdi, [rsi + 40]
    jmp lab4632

lab4631:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4632:
    ; substitute (a5 := a5)(as1 := as1)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_4616_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4637
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4633
    ; ####increment refcount
    add qword [rax + 0], 1

lab4633:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4634
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4634:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4635
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4635:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4636
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4636:
    jmp lab4638

lab4637:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4638:
    ; substitute (acc := acc)(cs0 := cs0)(a0 := a0)(css := css);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: List[i64] = (a0, css)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4650
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4651

lab4650:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4648
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4641
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4639
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4640

lab4639:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4640:

lab4641:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4644
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4642
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4643

lab4642:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4643:

lab4644:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4647
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4645
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4646

lab4645:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4646:

lab4647:
    jmp lab4649

lab4648:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4649:

lab4651:
    ; #load tag
    lea r9, [rel List_i64_4652]
    ; substitute (cs0 := cs0)(acc := acc)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump union_
    jmp union_

List_i64_4652:
    jmp near List_i64_4652_Nil
    jmp near List_i64_4652_Cons

List_i64_4652_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4655
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4653
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4653:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4654
    ; ####increment refcount
    add qword [rax + 0], 1

lab4654:
    jmp lab4656

lab4655:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab4656:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (css := css)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump combine_
    jmp combine_

List_i64_4652_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4659
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4657
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4657:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4658
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4658:
    jmp lab4660

lab4659:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4660:
    ; substitute (css := css)(a0 := a0)(a6 := a6)(as2 := as2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a6, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4672
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4673

lab4672:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4670
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4663
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4661
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4662

lab4661:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4662:

lab4663:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4666
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4664
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4665

lab4664:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4665:

lab4666:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4669
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4667
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4668

lab4667:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4668:

lab4669:
    jmp lab4671

lab4670:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4671:

lab4673:
    ; #load tag
    mov r9, 5
    ; substitute (css := css)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump combine_
    jmp combine_

ConflictSet_4552_Unknown:
    ; substitute (a0 := a0)(acc := acc);
    ; #erase css
    cmp r8, 0
    je lab4676
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab4674
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab4675

lab4674:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab4675:

lab4676:
    ; #erase s
    cmp r10, 0
    je lab4679
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab4677
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab4678

lab4677:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab4678:

lab4679:
    ; switch acc \{ ... \};
    lea rcx, [rel List_i64_4680]
    add rcx, rdi
    jmp rcx

List_i64_4680:
    jmp near List_i64_4680_Nil
    jmp near List_i64_4680_Cons

List_i64_4680_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_4680_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4682
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4681
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4681:
    mov rdi, [rsi + 40]
    jmp lab4683

lab4682:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab4683:
    ; substitute (a7 := a7)(as3 := as3)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bj__:
    ; substitute (a0 := a0)(t := t);
    ; #erase csp
    cmp rax, 0
    je lab4686
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4684
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4685

lab4684:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4685:

lab4686:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; create f7: Fun2[Pair[List[Assign], ConflictSet], List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_4687]
    ; substitute (f7 := f7)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bj_fold_tree_
    jmp bj_fold_tree_

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_4687:

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_4687_Apply2:
    ; substitute (a1 := a1)(chs := chs)(tp2 := tp2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch tp2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_4688:

Pair_List_Assign_ConflictSet_4688_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4691
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4689
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4689:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4690
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4690:
    jmp lab4692

lab4691:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4692:
    ; switch conf \{ ... \};
    lea rcx, [rel ConflictSet_4693]
    add rcx, r11
    jmp rcx

ConflictSet_4693:
    jmp near ConflictSet_4693_Known
    jmp near ConflictSet_4693_Unknown

ConflictSet_4693_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab4695
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab4694
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4694:
    jmp lab4696

lab4695:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab4696:
    ; let x0: ConflictSet = Known(cs);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4708
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4709

lab4708:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4706
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4699
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4697
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4698

lab4697:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4698:

lab4699:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4702
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4700
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4701

lab4700:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4701:

lab4702:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4705
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4703
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4704

lab4703:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4704:

lab4705:
    jmp lab4707

lab4706:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4707:

lab4709:
    ; #load tag
    mov r11, 0
    ; let x1: Pair[List[Assign], ConflictSet] = Tup(a, x0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4721
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4722

lab4721:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4719
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4712
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4710
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4711

lab4710:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4711:

lab4712:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4715
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4713
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4714

lab4713:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4714:

lab4715:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4718
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4716
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4717

lab4716:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4717:

lab4718:
    jmp lab4720

lab4719:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4720:

lab4722:
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(chs := chs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

ConflictSet_4693_Unknown:
    ; substitute (chs0 := chs)(chs := chs)(a := a)(a1 := a1);
    ; #share chs
    cmp rsi, 0
    je lab4723
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4723:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov rdx, rdi
    ; create a2: List[i64] = (chs, a, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4735
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4736

lab4735:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4733
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4726
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4724
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4725

lab4724:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4725:

lab4726:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4729
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4727
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4728

lab4727:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4728:

lab4729:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4732
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4730
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4731

lab4730:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4731:

lab4732:
    jmp lab4734

lab4733:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4734:

lab4736:
    ; #load tag
    lea rdi, [rel List_i64_4737]
    ; create a3: List[Pair[List[Assign], ConflictSet]] = (a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4749
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4750

lab4749:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4747
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4740
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4738
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4739

lab4738:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4739:

lab4740:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4743
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4741
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4742

lab4741:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4742:

lab4743:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4746
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4744
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4745

lab4744:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4745:

lab4746:
    jmp lab4748

lab4747:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4748:

lab4750:
    ; #load tag
    lea rdi, [rel List_Pair_List_Assign_ConflictSet_4751]
    ; create x4: Fun[Node[Pair[List[Assign], ConflictSet]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_4752]
    ; substitute (x4 := x4)(chs0 := chs0)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bj_map_
    jmp bj_map_

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_4752:

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_4752_Apply:
    ; jump bj_label_
    jmp bj_label_

List_Pair_List_Assign_ConflictSet_4751:
    jmp near List_Pair_List_Assign_ConflictSet_4751_Nil
    jmp near List_Pair_List_Assign_ConflictSet_4751_Cons

List_Pair_List_Assign_ConflictSet_4751_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4754
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab4753
    ; ####increment refcount
    add qword [rax + 0], 1

lab4753:
    jmp lab4755

lab4754:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab4755:
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_bj__1_
    jmp lift_bj__1_

List_Pair_List_Assign_ConflictSet_4751_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4757
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab4756
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4756:
    jmp lab4758

lab4757:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab4758:
    ; substitute (a2 := a2)(a7 := a7)(as1 := as1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Cons(a7, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4770
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4771

lab4770:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4768
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4761
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4759
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4760

lab4759:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4760:

lab4761:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4764
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4762
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4763

lab4762:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4763:

lab4764:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4767
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4765
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4766

lab4765:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4766:

lab4767:
    jmp lab4769

lab4768:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4769:

lab4771:
    ; #load tag
    mov rdi, 5
    ; jump lift_bj__1_
    jmp lift_bj__1_

List_i64_4737:
    jmp near List_i64_4737_Nil
    jmp near List_i64_4737_Cons

List_i64_4737_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4775
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab4772
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4772:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab4773
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4773:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab4774
    ; ####increment refcount
    add qword [rax + 0], 1

lab4774:
    jmp lab4776

lab4775:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab4776:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a := a)(a1 := a1)(chs := chs)(x2 := x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_bj__0_
    jmp lift_bj__0_

List_i64_4737_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4780
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4777
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4777:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4778
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4778:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4779
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4779:
    jmp lab4781

lab4780:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4781:
    ; substitute (a1 := a1)(a := a)(chs := chs)(a6 := a6)(as0 := as0);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x2: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4793
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4794

lab4793:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4791
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4784
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4782
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4783

lab4782:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4783:

lab4784:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4787
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4785
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4786

lab4785:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4786:

lab4787:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4790
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4788
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4789

lab4788:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4789:

lab4790:
    jmp lab4792

lab4791:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4792:

lab4794:
    ; #load tag
    mov r11, 5
    ; substitute (a := a)(a1 := a1)(chs := chs)(x2 := x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_bj__0_
    jmp lift_bj__0_

lift_bj__1_:
    ; let x5: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x3 := x3)(x5 := x5)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump combine_
    jmp combine_

lift_bj__0_:
    ; let cs_: ConflictSet = Known(x2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4806
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4807

lab4806:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4804
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4797
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4795
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4796

lab4795:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4796:

lab4797:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4800
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4798
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4799

lab4798:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4799:

lab4800:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4803
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4801
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4802

lab4801:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4802:

lab4803:
    jmp lab4805

lab4804:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4805:

lab4807:
    ; #load tag
    mov r11, 0
    ; substitute (cs_0 := cs_)(a1 := a1)(chs := chs)(cs_ := cs_)(a := a);
    ; #share cs_
    cmp r10, 0
    je lab4808
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4808:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, r10
    mov rdx, r11
    ; create a5: Bool = (a1, chs, cs_, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4820
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4821

lab4820:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4818
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4811
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4809
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4810

lab4809:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4810:

lab4811:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4814
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4812
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4813

lab4812:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4813:

lab4814:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4817
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4815
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4816

lab4815:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4816:

lab4817:
    jmp lab4819

lab4818:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4819:

lab4821:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4833
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4834

lab4833:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4831
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4824
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4822
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4823

lab4822:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4823:

lab4824:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4827
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4825
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4826

lab4825:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4826:

lab4827:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4830
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4828
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4829

lab4828:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4829:

lab4830:
    jmp lab4832

lab4831:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4832:

lab4834:
    ; #load tag
    lea rdi, [rel Bool_4835]
    ; jump known_conflict_
    jmp known_conflict_

Bool_4835:
    jmp near Bool_4835_True
    jmp near Bool_4835_False

Bool_4835_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4840
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4836
    ; ####increment refcount
    add qword [rax + 0], 1

lab4836:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4837
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4837:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4838
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4838:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4839
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4839:
    jmp lab4841

lab4840:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4841:
    ; substitute (a1 := a1)(a := a)(cs_ := cs_);
    ; #erase chs
    cmp rsi, 0
    je lab4844
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab4842
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab4843

lab4842:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab4843:

lab4844:
    ; #move variables
    mov rsi, r10
    mov rdi, r11
    ; let x6: Pair[List[Assign], ConflictSet] = Tup(a, cs_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4856
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab4857

lab4856:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4854
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4847
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4845
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4846

lab4845:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4846:

lab4847:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4850
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4848
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4849

lab4848:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4849:

lab4850:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4853
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4851
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4852

lab4851:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4852:

lab4853:
    jmp lab4855

lab4854:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4855:

lab4857:
    ; #load tag
    mov rdi, 0
    ; let x7: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x6 := x6)(x7 := x7)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_4835_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4862
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4858
    ; ####increment refcount
    add qword [rax + 0], 1

lab4858:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab4859
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4859:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab4860
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4860:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab4861
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4861:
    jmp lab4863

lab4862:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab4863:
    ; substitute (a1 := a1)(chs := chs)(a := a)(cs_ := cs_);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; let x8: Pair[List[Assign], ConflictSet] = Tup(a, cs_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4875
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4876

lab4875:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4873
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4866
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4864
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4865

lab4864:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4865:

lab4866:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4869
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4867
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4868

lab4867:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4868:

lab4869:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4872
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4870
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4871

lab4870:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4871:

lab4872:
    jmp lab4874

lab4873:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4874:

lab4876:
    ; #load tag
    mov r9, 0
    ; substitute (x8 := x8)(chs := chs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bj_label_:
    ; substitute (a0 := a0)(n := n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_4877:

Node_Pair_List_Assign_ConflictSet_4877_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4880
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4878
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4878:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab4879
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4879:
    jmp lab4881

lab4880:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab4881:
    ; substitute (a0 := a0)(l := l);
    ; #erase cs
    cmp r8, 0
    je lab4884
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab4882
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab4883

lab4882:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab4883:

lab4884:
    ; switch l \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_4885:

Pair_List_Assign_ConflictSet_4885_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab4888
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab4886
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4886:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab4887
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4887:
    jmp lab4889

lab4888:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab4889:
    ; substitute (a1 := a1)(b0 := b0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

bj_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_4890]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_4890:
    jmp near List_Node_Pair_List_Assign_ConflictSet_4890_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_4890_Cons

List_Node_Pair_List_Assign_ConflictSet_4890_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab4893
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4891
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4892

lab4891:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4892:

lab4893:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_4890_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4896
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4894
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4894:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4895
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4895:
    jmp lab4897

lab4896:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4897:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab4898
    ; ####increment refcount
    add qword [rax + 0], 1

lab4898:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[List[Assign], ConflictSet] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4910
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4911

lab4910:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4908
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4901
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4899
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4900

lab4899:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4900:

lab4901:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4904
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4902
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4903

lab4902:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4903:

lab4904:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4907
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4905
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4906

lab4905:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4906:

lab4907:
    jmp lab4909

lab4908:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4909:

lab4911:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_4912]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_List_Assign_ConflictSet_4912:

Pair_List_Assign_ConflictSet_4912_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4916
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4913
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4913:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4914
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4914:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4915
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4915:
    jmp lab4917

lab4916:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4917:
    ; substitute (f := f)(ps := ps)(a0 := a0)(a4 := a4)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a4, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4929
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab4930

lab4929:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4927
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4920
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4918
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4919

lab4918:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4919:

lab4920:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4923
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4921
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4922

lab4921:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4922:

lab4923:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4926
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4924
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4925

lab4924:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4925:

lab4926:
    jmp lab4928

lab4927:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4928:

lab4930:
    ; #load tag
    mov r11, 0
    ; create a2: List[Pair[List[Assign], ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4942
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4943

lab4942:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4940
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4933
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4931
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4932

lab4931:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4932:

lab4933:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4936
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4934
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4935

lab4934:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4935:

lab4936:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4939
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4937
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4938

lab4937:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4938:

lab4939:
    jmp lab4941

lab4940:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4941:

lab4943:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_4944]
    ; jump bj_map_
    jmp bj_map_

List_Pair_List_Assign_ConflictSet_4944:
    jmp near List_Pair_List_Assign_ConflictSet_4944_Nil
    jmp near List_Pair_List_Assign_ConflictSet_4944_Cons

List_Pair_List_Assign_ConflictSet_4944_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab4947
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab4945
    ; ####increment refcount
    add qword [rsi + 0], 1

lab4945:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab4946
    ; ####increment refcount
    add qword [rax + 0], 1

lab4946:
    jmp lab4948

lab4947:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab4948:
    ; let x1: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_4944_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4951
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4949
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4949:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4950
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4950:
    jmp lab4952

lab4951:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4952:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Pair[List[Assign], ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4964
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4965

lab4964:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4962
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4955
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4953
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4954

lab4953:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4954:

lab4955:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4958
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4956
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4957

lab4956:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4957:

lab4958:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4961
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4959
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4960

lab4959:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4960:

lab4961:
    jmp lab4963

lab4962:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4963:

lab4965:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bj_map2_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_4966]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_4966:
    jmp near List_Node_Pair_List_Assign_ConflictSet_4966_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_4966_Cons

List_Node_Pair_List_Assign_ConflictSet_4966_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab4969
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab4967
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab4968

lab4967:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab4968:

lab4969:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_4966_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4972
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab4970
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4970:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab4971
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4971:
    jmp lab4973

lab4972:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab4973:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab4974
    ; ####increment refcount
    add qword [rax + 0], 1

lab4974:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab4986
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab4987

lab4986:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab4984
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4977
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4975
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4976

lab4975:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4976:

lab4977:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4980
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4978
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4979

lab4978:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4979:

lab4980:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab4983
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4981
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4982

lab4981:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4982:

lab4983:
    jmp lab4985

lab4984:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab4985:

lab4987:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_4988]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_4988:

Node_Pair_List_Assign_ConflictSet_4988_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab4992
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab4989
    ; ####increment refcount
    add qword [r12 + 0], 1

lab4989:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab4990
    ; ####increment refcount
    add qword [r10 + 0], 1

lab4990:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab4991
    ; ####increment refcount
    add qword [r8 + 0], 1

lab4991:
    jmp lab4993

lab4992:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab4993:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5005
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5006

lab5005:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5003
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab4996
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4994
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4995

lab4994:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4995:

lab4996:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab4999
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab4997
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab4998

lab4997:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab4998:

lab4999:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5002
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5000
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5001

lab5000:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5001:

lab5002:
    jmp lab5004

lab5003:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5004:

lab5006:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5018
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5019

lab5018:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5016
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5009
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5007
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5008

lab5007:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5008:

lab5009:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5012
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5010
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5011

lab5010:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5011:

lab5012:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5015
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5013
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5014

lab5013:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5014:

lab5015:
    jmp lab5017

lab5016:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5017:

lab5019:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_5020]
    ; jump bj_map2_
    jmp bj_map2_

List_Node_Pair_List_Assign_ConflictSet_5020:
    jmp near List_Node_Pair_List_Assign_ConflictSet_5020_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_5020_Cons

List_Node_Pair_List_Assign_ConflictSet_5020_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5023
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5021
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5021:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5022
    ; ####increment refcount
    add qword [rax + 0], 1

lab5022:
    jmp lab5024

lab5023:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5024:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_5020_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5027
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5025
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5025:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5026
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5026:
    jmp lab5028

lab5027:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5028:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5040
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5041

lab5040:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5038
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5031
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5029
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5030

lab5029:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5030:

lab5031:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5034
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5032
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5033

lab5032:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5033:

lab5034:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5037
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5035
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5036

lab5035:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5036:

lab5037:
    jmp lab5039

lab5038:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5039:

lab5041:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bj_fold_tree_:
    ; substitute (f := f)(a0 := a0)(t := t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_List_Assign_ConflictSet_5042:

Node_Pair_List_Assign_ConflictSet_5042_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5045
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5043
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5043:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5044
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5044:
    jmp lab5046

lab5045:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5046:
    ; substitute (f0 := f)(c := c)(l := l)(a0 := a0)(f := f);
    ; #share f
    cmp rax, 0
    je lab5047
    ; ####increment refcount
    add qword [rax + 0], 1

lab5047:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; create a1: List[Node[Pair[List[Assign], ConflictSet]]] = (l, a0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5059
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5060

lab5059:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5057
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5050
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5048
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5049

lab5048:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5049:

lab5050:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5053
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5051
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5052

lab5051:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5052:

lab5053:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5056
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5054
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5055

lab5054:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5055:

lab5056:
    jmp lab5058

lab5057:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5058:

lab5060:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_5061]
    ; substitute (a1 := a1)(c := c)(f0 := f0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x1: Fun[Node[Pair[List[Assign], ConflictSet]], Node[Pair[List[Assign], ConflictSet]]] = (f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5073
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5074

lab5073:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5071
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5064
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5062
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5063

lab5062:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5063:

lab5064:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5067
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5065
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5066

lab5065:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5066:

lab5067:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5070
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5068
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5069

lab5068:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5069:

lab5070:
    jmp lab5072

lab5071:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5072:

lab5074:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5075]
    ; substitute (x1 := x1)(c := c)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bj_map2_
    jmp bj_map2_

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5075:

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5075_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5077
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5076
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5076:
    jmp lab5078

lab5077:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5078:
    ; substitute (f0 := f0)(x := x)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bj_fold_tree_
    jmp bj_fold_tree_

List_Node_Pair_List_Assign_ConflictSet_5061:
    jmp near List_Node_Pair_List_Assign_ConflictSet_5061_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_5061_Cons

List_Node_Pair_List_Assign_ConflictSet_5061_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5082
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5079
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5079:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5080
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5080:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5081
    ; ####increment refcount
    add qword [rax + 0], 1

lab5081:
    jmp lab5083

lab5082:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5083:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (l := l)(x0 := x0)(a0 := a0)(f := f);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

List_Node_Pair_List_Assign_ConflictSet_5061_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5087
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5084
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5084:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5085
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5085:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5086
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5086:
    jmp lab5088

lab5087:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5088:
    ; substitute (f := f)(a0 := a0)(l := l)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5100
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5101

lab5100:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5098
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5091
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5089
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5090

lab5089:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5090:

lab5091:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5094
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5092
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5093

lab5092:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5093:

lab5094:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5097
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5095
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5096

lab5095:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5096:

lab5097:
    jmp lab5099

lab5098:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5099:

lab5101:
    ; #load tag
    mov r11, 5
    ; substitute (l := l)(x0 := x0)(a0 := a0)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; invoke f Apply2
    ; #there is only one clause, so we can jump there directly
    jmp r11

bj_:
    ; substitute (a0 := a0)(t := t);
    ; #erase csp
    cmp rax, 0
    je lab5104
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab5102
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab5103

lab5102:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab5103:

lab5104:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; create f6: Fun2[Pair[List[Assign], ConflictSet], List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5105]
    ; substitute (f6 := f6)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bj_fold_tree_
    jmp bj_fold_tree_

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5105:

Fun2_Pair_List_Assign_ConflictSet_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_5105_Apply2:
    ; substitute (a1 := a1)(chs := chs)(tp2 := tp2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch tp2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_5106:

Pair_List_Assign_ConflictSet_5106_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5109
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5107
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5107:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5108
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5108:
    jmp lab5110

lab5109:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5110:
    ; switch conf \{ ... \};
    lea rcx, [rel ConflictSet_5111]
    add rcx, r11
    jmp rcx

ConflictSet_5111:
    jmp near ConflictSet_5111_Known
    jmp near ConflictSet_5111_Unknown

ConflictSet_5111_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab5113
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab5112
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5112:
    jmp lab5114

lab5113:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab5114:
    ; let x0: ConflictSet = Known(cs);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5126
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5127

lab5126:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5124
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5117
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5115
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5116

lab5115:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5116:

lab5117:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5120
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5118
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5119

lab5118:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5119:

lab5120:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5123
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5121
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5122

lab5121:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5122:

lab5123:
    jmp lab5125

lab5124:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5125:

lab5127:
    ; #load tag
    mov r11, 0
    ; let x1: Pair[List[Assign], ConflictSet] = Tup(a, x0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5139
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5140

lab5139:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5137
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5130
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5128
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5129

lab5128:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5129:

lab5130:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5133
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5131
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5132

lab5131:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5132:

lab5133:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5136
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5134
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5135

lab5134:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5135:

lab5136:
    jmp lab5138

lab5137:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5138:

lab5140:
    ; #load tag
    mov r9, 0
    ; substitute (x1 := x1)(chs := chs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

ConflictSet_5111_Unknown:
    ; substitute (chs0 := chs)(chs := chs)(a := a)(a1 := a1);
    ; #share chs
    cmp rsi, 0
    je lab5141
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5141:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov rdx, rdi
    ; create a2: List[i64] = (chs, a, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5153
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5154

lab5153:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5151
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5144
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5142
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5143

lab5142:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5143:

lab5144:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5147
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5145
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5146

lab5145:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5146:

lab5147:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5150
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5148
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5149

lab5148:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5149:

lab5150:
    jmp lab5152

lab5151:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5152:

lab5154:
    ; #load tag
    lea rdi, [rel List_i64_5155]
    ; create a3: List[Pair[List[Assign], ConflictSet]] = (a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5167
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5168

lab5167:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5165
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5158
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5156
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5157

lab5156:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5157:

lab5158:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5161
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5159
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5160

lab5159:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5160:

lab5161:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5164
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5162
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5163

lab5162:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5163:

lab5164:
    jmp lab5166

lab5165:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5166:

lab5168:
    ; #load tag
    lea rdi, [rel List_Pair_List_Assign_ConflictSet_5169]
    ; create x4: Fun[Node[Pair[List[Assign], ConflictSet]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_5170]
    ; substitute (x4 := x4)(chs0 := chs0)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bj_map_
    jmp bj_map_

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_5170:

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_5170_Apply:
    ; jump bj_label_
    jmp bj_label_

List_Pair_List_Assign_ConflictSet_5169:
    jmp near List_Pair_List_Assign_ConflictSet_5169_Nil
    jmp near List_Pair_List_Assign_ConflictSet_5169_Cons

List_Pair_List_Assign_ConflictSet_5169_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5172
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab5171
    ; ####increment refcount
    add qword [rax + 0], 1

lab5171:
    jmp lab5173

lab5172:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab5173:
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_bj_1_
    jmp lift_bj_1_

List_Pair_List_Assign_ConflictSet_5169_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5175
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5174
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5174:
    jmp lab5176

lab5175:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5176:
    ; substitute (a2 := a2)(a6 := a6)(as1 := as1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Cons(a6, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5188
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5189

lab5188:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5186
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5179
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5177
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5178

lab5177:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5178:

lab5179:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5182
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5180
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5181

lab5180:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5181:

lab5182:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5185
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5183
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5184

lab5183:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5184:

lab5185:
    jmp lab5187

lab5186:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5187:

lab5189:
    ; #load tag
    mov rdi, 5
    ; jump lift_bj_1_
    jmp lift_bj_1_

List_i64_5155:
    jmp near List_i64_5155_Nil
    jmp near List_i64_5155_Cons

List_i64_5155_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5193
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5190
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5190:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5191
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5191:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5192
    ; ####increment refcount
    add qword [rax + 0], 1

lab5192:
    jmp lab5194

lab5193:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5194:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a := a)(a1 := a1)(chs := chs)(x2 := x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_bj_0_
    jmp lift_bj_0_

List_i64_5155_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5198
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5195
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5195:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5196
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5196:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5197
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5197:
    jmp lab5199

lab5198:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5199:
    ; substitute (a1 := a1)(a := a)(chs := chs)(a5 := a5)(as0 := as0);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x2: List[i64] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5211
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5212

lab5211:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5209
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5202
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5200
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5201

lab5200:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5201:

lab5202:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5205
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5203
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5204

lab5203:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5204:

lab5205:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5208
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5206
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5207

lab5206:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5207:

lab5208:
    jmp lab5210

lab5209:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5210:

lab5212:
    ; #load tag
    mov r11, 5
    ; substitute (a := a)(a1 := a1)(chs := chs)(x2 := x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_bj_0_
    jmp lift_bj_0_

lift_bj_1_:
    ; let x5: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x3 := x3)(x5 := x5)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump combine_
    jmp combine_

lift_bj_0_:
    ; let x6: ConflictSet = Known(x2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5224
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5225

lab5224:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5222
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5215
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5213
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5214

lab5213:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5214:

lab5215:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5218
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5216
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5217

lab5216:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5217:

lab5218:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5221
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5219
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5220

lab5219:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5220:

lab5221:
    jmp lab5223

lab5222:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5223:

lab5225:
    ; #load tag
    mov r11, 0
    ; substitute (chs := chs)(a1 := a1)(a := a)(x6 := x6);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x7: Pair[List[Assign], ConflictSet] = Tup(a, x6);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5237
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5238

lab5237:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5235
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5228
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5226
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5227

lab5226:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5227:

lab5228:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5231
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5229
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5230

lab5229:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5230:

lab5231:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5234
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5232
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5233

lab5232:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5233:

lab5234:
    jmp lab5236

lab5235:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5236:

lab5238:
    ; #load tag
    mov r9, 0
    ; substitute (x7 := x7)(chs := chs)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a1 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

bjbt_:
    ; substitute (csp0 := csp)(t := t)(a0 := a0)(csp := csp);
    ; #share csp
    cmp rax, 0
    je lab5239
    ; ####increment refcount
    add qword [rax + 0], 1

lab5239:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5251
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5252

lab5251:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5249
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5242
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5240
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5241

lab5240:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5241:

lab5242:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5245
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5243
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5244

lab5243:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5244:

lab5245:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5248
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5246
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5247

lab5246:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5247:

lab5248:
    jmp lab5250

lab5249:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5250:

lab5252:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_5253]
    ; jump bt_
    jmp bt_

Node_Pair_List_Assign_ConflictSet_5253:

Node_Pair_List_Assign_ConflictSet_5253_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5256
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5254
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5254:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5255
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5255:
    jmp lab5257

lab5256:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5257:
    ; substitute (csp := csp)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5269
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5270

lab5269:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5267
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5259

lab5258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5259:

lab5260:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5263
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5261
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5262

lab5261:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5262:

lab5263:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5266
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5264
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5265

lab5264:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5265:

lab5266:
    jmp lab5268

lab5267:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5268:

lab5270:
    ; #load tag
    mov r9, 0
    ; substitute (csp := csp)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump bj_
    jmp bj_

bjbt__:
    ; substitute (csp0 := csp)(t := t)(a0 := a0)(csp := csp);
    ; #share csp
    cmp rax, 0
    je lab5271
    ; ####increment refcount
    add qword [rax + 0], 1

lab5271:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5283
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5284

lab5283:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5281
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5274
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5272
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5273

lab5272:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5273:

lab5274:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5277
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5275
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5276

lab5275:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5276:

lab5277:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5280
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5278
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5279

lab5278:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5279:

lab5280:
    jmp lab5282

lab5281:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5282:

lab5284:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_5285]
    ; jump bt_
    jmp bt_

Node_Pair_List_Assign_ConflictSet_5285:

Node_Pair_List_Assign_ConflictSet_5285_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5288
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5286
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5286:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5287
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5287:
    jmp lab5289

lab5288:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5289:
    ; substitute (csp := csp)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5301
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5302

lab5301:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5299
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5292
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5290
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5291

lab5290:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5291:

lab5292:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5295
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5293
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5294

lab5293:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5294:

lab5295:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5298
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5296
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5297

lab5296:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5297:

lab5298:
    jmp lab5300

lab5299:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5300:

lab5302:
    ; #load tag
    mov r9, 0
    ; substitute (csp := csp)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump bj__
    jmp bj__

collect_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_ConflictSet_5303]
    add rcx, rdi
    jmp rcx

List_ConflictSet_5303:
    jmp near List_ConflictSet_5303_Nil
    jmp near List_ConflictSet_5303_Cons

List_ConflictSet_5303_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_5303_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5306
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5304
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5304:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5305
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5305:
    jmp lab5307

lab5306:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5307:
    ; substitute (a0 := a0)(css := css)(conf := conf);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch conf \{ ... \};
    lea rcx, [rel ConflictSet_5308]
    add rcx, r9
    jmp rcx

ConflictSet_5308:
    jmp near ConflictSet_5308_Known
    jmp near ConflictSet_5308_Unknown

ConflictSet_5308_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5310
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5309
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5309:
    jmp lab5311

lab5310:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5311:
    ; substitute (css := css)(a0 := a0)(cs := cs);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: List[i64] = (a0, cs)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5323
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5324

lab5323:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5321
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5314
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5312
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5313

lab5312:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5313:

lab5314:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5317
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5315
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5316

lab5315:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5316:

lab5317:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5320
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5318
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5319

lab5318:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5319:

lab5320:
    jmp lab5322

lab5321:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5322:

lab5324:
    ; #load tag
    lea rdi, [rel List_i64_5325]
    ; jump collect_
    jmp collect_

List_i64_5325:
    jmp near List_i64_5325_Nil
    jmp near List_i64_5325_Cons

List_i64_5325_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5328
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5326
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5326:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5327
    ; ####increment refcount
    add qword [rax + 0], 1

lab5327:
    jmp lab5329

lab5328:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5329:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (cs := cs)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump union_
    jmp union_

List_i64_5325_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5332
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5330
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5330:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5331
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5331:
    jmp lab5333

lab5332:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5333:
    ; substitute (cs := cs)(a0 := a0)(a2 := a2)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5345
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5346

lab5345:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5343
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5336
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5334
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5335

lab5334:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5335:

lab5336:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5339
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5337
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5338

lab5337:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5338:

lab5339:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5342
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5340
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5341

lab5340:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5341:

lab5342:
    jmp lab5344

lab5343:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5344:

lab5346:
    ; #load tag
    mov r9, 5
    ; substitute (cs := cs)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump union_
    jmp union_

ConflictSet_5308_Unknown:
    ; substitute (a0 := a0);
    ; #erase css
    cmp rsi, 0
    je lab5349
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5347
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5348

lab5347:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5348:

lab5349:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

wipe_all_:
    ; substitute (f := f)(a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_ConflictSet_5350]
    add rcx, r9
    jmp rcx

List_ConflictSet_5350:
    jmp near List_ConflictSet_5350_Nil
    jmp near List_ConflictSet_5350_Cons

List_ConflictSet_5350_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab5353
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab5351
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab5352

lab5351:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab5352:

lab5353:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_ConflictSet_5350_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5356
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5354
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5354:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5355
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5355:
    jmp lab5357

lab5356:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5357:
    ; substitute (f0 := f)(c := c)(a0 := a0)(cs := cs)(f := f);
    ; #share f
    cmp rax, 0
    je lab5358
    ; ####increment refcount
    add qword [rax + 0], 1

lab5358:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Bool = (a0, cs, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5370
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5371

lab5370:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5368
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5361
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5359
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5360

lab5359:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5360:

lab5361:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5364
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5362
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5363

lab5362:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5363:

lab5364:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5367
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5365
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5366

lab5365:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5366:

lab5367:
    jmp lab5369

lab5368:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5369:

lab5371:
    ; #load tag
    lea r9, [rel Bool_5372]
    ; substitute (c := c)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Bool_5372:
    jmp near Bool_5372_True
    jmp near Bool_5372_False

Bool_5372_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5376
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5373
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5373:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5374
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5374:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5375
    ; ####increment refcount
    add qword [rax + 0], 1

lab5375:
    jmp lab5377

lab5376:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5377:
    ; substitute (f := f)(cs := cs)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump wipe_all_
    jmp wipe_all_

Bool_5372_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5381
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5378
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5378:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5379
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5379:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5380
    ; ####increment refcount
    add qword [rax + 0], 1

lab5380:
    jmp lab5382

lab5381:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5382:
    ; substitute (a0 := a0);
    ; #erase cs
    cmp rsi, 0
    je lab5385
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5383
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5384

lab5383:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5384:

lab5385:
    ; #erase f
    cmp r8, 0
    je lab5388
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab5386
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab5387

lab5386:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab5387:

lab5388:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

filter_known_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_5389]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_5389:
    jmp near List_List_ConflictSet_5389_Nil
    jmp near List_List_ConflictSet_5389_Cons

List_List_ConflictSet_5389_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_5389_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5392
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5390
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5390:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5391
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5391:
    jmp lab5393

lab5392:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5393:
    ; create x0: Fun[ConflictSet, Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_ConflictSet_Bool_5394]
    ; substitute (x0 := x0)(vs0 := vs)(t1 := t1)(vs := vs)(a0 := a0);
    ; #share vs
    cmp rsi, 0
    je lab5395
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5395:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, r10
    mov r10, rsi
    mov rdx, r11
    mov r11, rdi
    ; create a3: Bool = (t1, vs, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5407
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5408

lab5407:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5405
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5398
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5396
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5397

lab5396:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5397:

lab5398:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5401
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5399
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5400

lab5399:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5400:

lab5401:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5404
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5402
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5403

lab5402:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5403:

lab5404:
    jmp lab5406

lab5405:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5406:

lab5408:
    ; #load tag
    lea r9, [rel Bool_5409]
    ; jump wipe_all_
    jmp wipe_all_

Bool_5409:
    jmp near Bool_5409_True
    jmp near Bool_5409_False

Bool_5409_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5413
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5410
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5410:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5411
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5411:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5412
    ; ####increment refcount
    add qword [rax + 0], 1

lab5412:
    jmp lab5414

lab5413:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5414:
    ; create a1: List[List[ConflictSet]] = (vs, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5426
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5427

lab5426:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5424
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5417
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5415
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5416

lab5415:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5416:

lab5417:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5420
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5418
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5419

lab5418:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5419:

lab5420:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5423
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5421
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5422

lab5421:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5422:

lab5423:
    jmp lab5425

lab5424:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5425:

lab5427:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_5428]
    ; jump filter_known_
    jmp filter_known_

List_List_ConflictSet_5428:
    jmp near List_List_ConflictSet_5428_Nil
    jmp near List_List_ConflictSet_5428_Cons

List_List_ConflictSet_5428_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5431
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5429
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5429:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5430
    ; ####increment refcount
    add qword [rax + 0], 1

lab5430:
    jmp lab5432

lab5431:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5432:
    ; let x1: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (vs := vs)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_5428_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5435
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5433
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5433:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5434
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5434:
    jmp lab5436

lab5435:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5436:
    ; substitute (a0 := a0)(vs := vs)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5448
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5449

lab5448:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5446
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5438

lab5437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5438:

lab5439:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5442
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5440
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5441

lab5440:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5441:

lab5442:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5445
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5443
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5444

lab5443:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5444:

lab5445:
    jmp lab5447

lab5446:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5447:

lab5449:
    ; #load tag
    mov r9, 5
    ; substitute (vs := vs)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_5409_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5453
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5450
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5450:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5451
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5451:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5452
    ; ####increment refcount
    add qword [rax + 0], 1

lab5452:
    jmp lab5454

lab5453:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5454:
    ; substitute (t1 := t1)(a0 := a0);
    ; #erase vs
    cmp rsi, 0
    je lab5457
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5455
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5456

lab5455:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5456:

lab5457:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; jump filter_known_
    jmp filter_known_

Fun_ConflictSet_Bool_5394:

Fun_ConflictSet_Bool_5394_Apply:
    ; jump known_conflict_
    jmp known_conflict_

wipe_null__:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_5458]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_5458:
    jmp near List_List_ConflictSet_5458_Nil
    jmp near List_List_ConflictSet_5458_Cons

List_List_ConflictSet_5458_Nil:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_List_ConflictSet_5458_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5461
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5459
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5459:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5460
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5460:
    jmp lab5462

lab5461:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5462:
    ; substitute (a0 := a0);
    ; #erase l
    cmp rsi, 0
    je lab5465
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5463
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5464

lab5463:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5464:

lab5465:
    ; #erase ls0
    cmp r8, 0
    je lab5468
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab5466
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab5467

lab5466:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab5467:

lab5468:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

wipe_head_:
    ; substitute (a0 := a0)(ls := ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_5469]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_5469:
    jmp near List_List_ConflictSet_5469_Nil
    jmp near List_List_ConflictSet_5469_Cons

List_List_ConflictSet_5469_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_5469_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5472
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5470
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5470:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5471
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5471:
    jmp lab5473

lab5472:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5473:
    ; substitute (a0 := a0)(l := l);
    ; #erase ls0
    cmp r8, 0
    je lab5476
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab5474
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab5475

lab5474:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab5475:

lab5476:
    ; switch l \{ ... \};
    lea rcx, [rel List_ConflictSet_5477]
    add rcx, rdi
    jmp rcx

List_ConflictSet_5477:
    jmp near List_ConflictSet_5477_Nil
    jmp near List_ConflictSet_5477_Cons

List_ConflictSet_5477_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_5477_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5480
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5478
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5478:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5479
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5479:
    jmp lab5481

lab5480:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5481:
    ; substitute (a1 := a1)(as0 := as0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

wipe_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5482]
    add rcx, r9
    jmp rcx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5482:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5482_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5482_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5482_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab5485
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab5483
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab5484

lab5483:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab5484:

lab5485:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5482_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5488
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5486
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5486:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5487
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5487:
    jmp lab5489

lab5488:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5489:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab5490
    ; ####increment refcount
    add qword [rax + 0], 1

lab5490:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5502
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5503

lab5502:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5500
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5493
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5491
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5492

lab5491:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5492:

lab5493:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5496
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5494
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5495

lab5494:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5495:

lab5496:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5499
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5497
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5498

lab5497:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5498:

lab5499:
    jmp lab5501

lab5500:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5501:

lab5503:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_5504]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Node_Pair_List_Assign_ConflictSet_5504:

Node_Pair_List_Assign_ConflictSet_5504_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5508
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5505
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5505:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5506
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5506:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5507
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5507:
    jmp lab5509

lab5508:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5509:
    ; substitute (f := f)(ps := ps)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5521
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5522

lab5521:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5519
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5512
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5510
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5511

lab5510:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5511:

lab5512:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5515
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5513
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5514

lab5513:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5514:

lab5515:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5518
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5516
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5517

lab5516:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5517:

lab5518:
    jmp lab5520

lab5519:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5520:

lab5522:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5534
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5535

lab5534:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5532
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5525
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5523
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5524

lab5523:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5524:

lab5525:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5528
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5526
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5527

lab5526:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5527:

lab5528:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5531
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5529
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5530

lab5529:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5530:

lab5531:
    jmp lab5533

lab5532:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5533:

lab5535:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_5536]
    ; jump wipe_map_
    jmp wipe_map_

List_Node_Pair_List_Assign_ConflictSet_5536:
    jmp near List_Node_Pair_List_Assign_ConflictSet_5536_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_5536_Cons

List_Node_Pair_List_Assign_ConflictSet_5536_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5539
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5537
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5537:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5538
    ; ####increment refcount
    add qword [rax + 0], 1

lab5538:
    jmp lab5540

lab5539:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5540:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_5536_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5543
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5541
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5541:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5542
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5542:
    jmp lab5544

lab5543:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5544:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5556
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5557

lab5556:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5554
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5546

lab5545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5546:

lab5547:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5550
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5548
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5549

lab5548:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5549:

lab5550:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5553
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5551
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5552

lab5551:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5552:

lab5553:
    jmp lab5555

lab5554:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5555:

lab5557:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

wipe_map_tree_:
    ; substitute (f := f)(a0 := a0)(t := t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #there is only one clause, so we can just fall through

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5558:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5558_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5561
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5559
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5559:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5560
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5560:
    jmp lab5562

lab5561:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5562:
    ; substitute (f0 := f)(l := l)(a0 := a0)(c := c)(f := f);
    ; #share f
    cmp rax, 0
    je lab5563
    ; ####increment refcount
    add qword [rax + 0], 1

lab5563:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: Pair[List[Assign], ConflictSet] = (a0, c, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5575
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5576

lab5575:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5573
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5566
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5564
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5565

lab5564:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5565:

lab5566:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5569
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5567
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5568

lab5567:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5568:

lab5569:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5572
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5570
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5571

lab5570:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5571:

lab5572:
    jmp lab5574

lab5573:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5574:

lab5576:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_5577]
    ; substitute (l := l)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

Pair_List_Assign_ConflictSet_5577:

Pair_List_Assign_ConflictSet_5577_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5581
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5578
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5578:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5579
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5579:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5580
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5580:
    jmp lab5582

lab5581:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5582:
    ; substitute (f := f)(c := c)(a0 := a0)(a5 := a5)(b0 := b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5594
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5595

lab5594:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5592
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5585
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5583
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5584

lab5583:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5584:

lab5585:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5588
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5586
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5587

lab5586:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5587:

lab5588:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5591
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5589
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5590

lab5589:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5590:

lab5591:
    jmp lab5593

lab5592:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5593:

lab5595:
    ; #load tag
    mov r11, 0
    ; create a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5607
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5608

lab5607:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5605
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5598
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5596
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5597

lab5596:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5597:

lab5598:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5601
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5599
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5600

lab5599:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5600:

lab5601:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5604
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5602
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5603

lab5602:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5603:

lab5604:
    jmp lab5606

lab5605:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5606:

lab5608:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_5609]
    ; substitute (a2 := a2)(c := c)(f := f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; create x2: Fun[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]], Node[Pair[List[Assign], ConflictSet]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5621
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5622

lab5621:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5619
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5612
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5610
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5611

lab5610:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5611:

lab5612:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5615
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5613
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5614

lab5613:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5614:

lab5615:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5618
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5616
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5617

lab5616:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5617:

lab5618:
    jmp lab5620

lab5619:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5620:

lab5622:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_5623]
    ; substitute (x2 := x2)(c := c)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump wipe_map_
    jmp wipe_map_

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_5623:

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_5623_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5625
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5624
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5624:
    jmp lab5626

lab5625:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5626:
    ; substitute (f := f)(x := x)(a3 := a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump wipe_map_tree_
    jmp wipe_map_tree_

List_Node_Pair_List_Assign_ConflictSet_5609:
    jmp near List_Node_Pair_List_Assign_ConflictSet_5609_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_5609_Cons

List_Node_Pair_List_Assign_ConflictSet_5609_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5629
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5627
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5627:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5628
    ; ####increment refcount
    add qword [rax + 0], 1

lab5628:
    jmp lab5630

lab5629:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5630:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_5609_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5633
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5631
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5631:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5632
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5632:
    jmp lab5634

lab5633:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5634:
    ; substitute (x0 := x0)(a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5646
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5647

lab5646:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5644
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5637
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5635
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5636

lab5635:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5636:

lab5637:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5640
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5638
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5639

lab5638:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5639:

lab5640:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5643
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5641
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5642

lab5641:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5642:

lab5643:
    jmp lab5645

lab5644:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5645:

lab5647:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    ; #there is only one clause, so we can jump there directly
    jmp r9

domain_wipeout_:
    ; substitute (a0 := a0)(t := t)(csp := csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #there is only one clause, so we can just fall through

CSP_5648:

CSP_5648_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5650
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5649
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5649:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab5651

lab5650:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab5651:
    ; substitute (a0 := a0)(t := t);
    ; #erase rel
    cmp r12, 0
    je lab5654
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab5652
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab5653

lab5652:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab5653:

lab5654:
    ; create f8: Fun[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_5655]
    ; substitute (f8 := f8)(t := t)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump wipe_map_tree_
    jmp wipe_map_tree_

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_5655:

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_5655_Apply:
    ; substitute (a1 := a1)(tp2 := tp2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch tp2 \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5656:

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5656_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5659
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5657
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5657:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5658
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5658:
    jmp lab5660

lab5659:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5660:
    ; substitute (a1 := a1)(tbl := tbl)(p := p);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch p \{ ... \};
    ; #there is only one clause, so we can just fall through

Pair_List_Assign_ConflictSet_5661:

Pair_List_Assign_ConflictSet_5661_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5664
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5662
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5662:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5663
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5663:
    jmp lab5665

lab5664:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5665:
    ; substitute (tbl := tbl)(a1 := a1)(as_ := as_)(cs := cs);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a4: List[List[ConflictSet]] = (a1, as_, cs)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5677
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5678

lab5677:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5675
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5668
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5666
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5667

lab5666:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5667:

lab5668:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5671
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5669
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5670

lab5669:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5670:

lab5671:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5674
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5672
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5673

lab5672:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5673:

lab5674:
    jmp lab5676

lab5675:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5676:

lab5678:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_5679]
    ; jump filter_known_
    jmp filter_known_

List_List_ConflictSet_5679:
    jmp near List_List_ConflictSet_5679_Nil
    jmp near List_List_ConflictSet_5679_Cons

List_List_ConflictSet_5679_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5683
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5680
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5680:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5681
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5681:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5682
    ; ####increment refcount
    add qword [rax + 0], 1

lab5682:
    jmp lab5684

lab5683:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5684:
    ; let wiped_domains: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; jump lift_domain_wipeout_0_
    jmp lift_domain_wipeout_0_

List_List_ConflictSet_5679_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5688
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5685
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5685:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5686
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5686:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5687
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5687:
    jmp lab5689

lab5688:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5689:
    ; substitute (cs := cs)(as_ := as_)(a1 := a1)(a8 := a8)(as2 := as2);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let wiped_domains: List[List[ConflictSet]] = Cons(a8, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5701
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5702

lab5701:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5699
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5692
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5690
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5691

lab5690:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5691:

lab5692:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5695
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5693
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5694

lab5693:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5694:

lab5695:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5698
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5696
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5697

lab5696:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5697:

lab5698:
    jmp lab5700

lab5699:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5700:

lab5702:
    ; #load tag
    mov r11, 5
    ; substitute (a1 := a1)(as_ := as_)(cs := cs)(wiped_domains := wiped_domains);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_domain_wipeout_0_
    jmp lift_domain_wipeout_0_

lift_domain_wipeout_0_:
    ; substitute (wiped_domains0 := wiped_domains)(as_ := as_)(cs := cs)(wiped_domains := wiped_domains)(a1 := a1);
    ; #share wiped_domains
    cmp r10, 0
    je lab5703
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5703:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, r10
    mov rdx, r11
    ; create a5: Bool = (as_, cs, wiped_domains, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5715
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5716

lab5715:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5713
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5706
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5704
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5705

lab5704:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5705:

lab5706:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5709
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5707
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5708

lab5707:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5708:

lab5709:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5712
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5710
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5711

lab5710:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5711:

lab5712:
    jmp lab5714

lab5713:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5714:

lab5716:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5728
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5729

lab5728:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5726
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5719
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5717
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5718

lab5717:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5718:

lab5719:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5722
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5720
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5721

lab5720:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5721:

lab5722:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5725
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5723
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5724

lab5723:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5724:

lab5725:
    jmp lab5727

lab5726:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5727:

lab5729:
    ; #load tag
    lea rdi, [rel Bool_5730]
    ; jump wipe_null__
    jmp wipe_null__

Bool_5730:
    jmp near Bool_5730_True
    jmp near Bool_5730_False

Bool_5730_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5735
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5731
    ; ####increment refcount
    add qword [rax + 0], 1

lab5731:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab5732
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5732:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab5733
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5733:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab5734
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5734:
    jmp lab5736

lab5735:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab5736:
    ; substitute (a1 := a1)(as_ := as_)(cs := cs);
    ; #erase wiped_domains
    cmp r8, 0
    je lab5739
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab5737
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab5738

lab5737:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab5738:

lab5739:
    ; #move variables
    mov r8, rsi
    mov rsi, rax
    mov r9, rdi
    mov rdi, rdx
    mov rax, r10
    mov rdx, r11
    ; jump share_domain_wipeout_0_
    jmp share_domain_wipeout_0_

Bool_5730_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5744
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5740
    ; ####increment refcount
    add qword [rax + 0], 1

lab5740:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab5741
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5741:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab5742
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5742:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab5743
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5743:
    jmp lab5745

lab5744:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab5745:
    ; substitute (wiped_domains := wiped_domains)(as_ := as_)(a1 := a1);
    ; #erase cs
    cmp rsi, 0
    je lab5748
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5746
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5747

lab5746:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5747:

lab5748:
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; create a2: List[i64] = (as_, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5760
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5761

lab5760:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5758
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5751
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5749
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5750

lab5749:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5750:

lab5751:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5754
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5752
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5753

lab5752:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5753:

lab5754:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5757
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5755
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5756

lab5755:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5756:

lab5757:
    jmp lab5759

lab5758:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5759:

lab5761:
    ; #load tag
    lea rdi, [rel List_i64_5762]
    ; create a3: List[ConflictSet] = (a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5774
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5775

lab5774:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5772
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5765
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5763
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5764

lab5763:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5764:

lab5765:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5768
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5766
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5767

lab5766:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5767:

lab5768:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5771
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5769
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5770

lab5769:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5770:

lab5771:
    jmp lab5773

lab5772:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5773:

lab5775:
    ; #load tag
    lea rdi, [rel List_ConflictSet_5776]
    ; jump wipe_head_
    jmp wipe_head_

List_ConflictSet_5776:
    jmp near List_ConflictSet_5776_Nil
    jmp near List_ConflictSet_5776_Cons

List_ConflictSet_5776_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5778
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab5777
    ; ####increment refcount
    add qword [rax + 0], 1

lab5777:
    jmp lab5779

lab5778:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab5779:
    ; let x1: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 := x1)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump collect_
    jmp collect_

List_ConflictSet_5776_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5781
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab5780
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5780:
    jmp lab5782

lab5781:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab5782:
    ; substitute (a2 := a2)(a7 := a7)(as1 := as1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x1: List[ConflictSet] = Cons(a7, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5794
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5795

lab5794:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5792
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5785
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5783
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5784

lab5783:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5784:

lab5785:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5788
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5786
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5787

lab5786:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5787:

lab5788:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5791
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5789
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5790

lab5789:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5790:

lab5791:
    jmp lab5793

lab5792:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5793:

lab5795:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 := x1)(a2 := a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump collect_
    jmp collect_

List_i64_5762:
    jmp near List_i64_5762_Nil
    jmp near List_i64_5762_Cons

List_i64_5762_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5798
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab5796
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5796:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab5797
    ; ####increment refcount
    add qword [rax + 0], 1

lab5797:
    jmp lab5799

lab5798:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab5799:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a1 := a1)(as_ := as_)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_domain_wipeout_1_
    jmp lift_domain_wipeout_1_

List_i64_5762_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5802
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5800
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5800:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5801
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5801:
    jmp lab5803

lab5802:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5803:
    ; substitute (a1 := a1)(as_ := as_)(a6 := a6)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5815
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5816

lab5815:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5813
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5806
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5804
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5805

lab5804:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5805:

lab5806:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5809
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5807
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5808

lab5807:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5808:

lab5809:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5812
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5810
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5811

lab5810:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5811:

lab5812:
    jmp lab5814

lab5813:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5814:

lab5816:
    ; #load tag
    mov r9, 5
    ; jump lift_domain_wipeout_1_
    jmp lift_domain_wipeout_1_

lift_domain_wipeout_1_:
    ; let cs_: ConflictSet = Known(x0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5828
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5829

lab5828:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5826
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5819
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5817
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5818

lab5817:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5818:

lab5819:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5822
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5820
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5821

lab5820:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5821:

lab5822:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5825
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5823
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5824

lab5823:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5824:

lab5825:
    jmp lab5827

lab5826:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5827:

lab5829:
    ; #load tag
    mov r9, 0
    ; jump share_domain_wipeout_0_
    jmp share_domain_wipeout_0_

share_domain_wipeout_0_:
    ; substitute (as_ := as_)(cs_ := cs_)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Tup
    ; #there is only one clause, so we can jump there directly
    jmp r9

fc_:
    ; substitute (csp0 := csp)(t := t)(a0 := a0)(csp := csp);
    ; #share csp
    cmp rax, 0
    je lab5830
    ; ####increment refcount
    add qword [rax + 0], 1

lab5830:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a1: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5842
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5843

lab5842:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5840
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5833
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5831
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5832

lab5831:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5832:

lab5833:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5835

lab5834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5835:

lab5836:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5839
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5837
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5838

lab5837:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5838:

lab5839:
    jmp lab5841

lab5840:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5841:

lab5843:
    ; #load tag
    lea r9, [rel Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5844]
    ; substitute (csp00 := csp0)(t := t)(a1 := a1)(csp0 := csp0);
    ; #share csp0
    cmp rax, 0
    je lab5845
    ; ####increment refcount
    add qword [rax + 0], 1

lab5845:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a2: Node[Pair[List[Assign], List[List[ConflictSet]]]] = (a1, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5857
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5858

lab5857:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5855
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5848
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5846
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5847

lab5846:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5847:

lab5848:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5851
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5849
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5850

lab5849:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5850:

lab5851:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5854
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5852
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5853

lab5852:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5853:

lab5854:
    jmp lab5856

lab5855:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5856:

lab5858:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_List_List_ConflictSet_5859]
    ; substitute (csp000 := csp00)(t := t)(a2 := a2)(csp00 := csp00);
    ; #share csp00
    cmp rax, 0
    je lab5860
    ; ####increment refcount
    add qword [rax + 0], 1

lab5860:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; create a3: List[List[ConflictSet]] = (t, a2, csp00)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5872
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5873

lab5872:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5870
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5863
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5861
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5862

lab5861:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5862:

lab5863:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5866
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5864
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5865

lab5864:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5865:

lab5866:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5869
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5867
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5868

lab5867:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5868:

lab5869:
    jmp lab5871

lab5870:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5871:

lab5873:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_5874]
    ; jump empty_table_
    jmp empty_table_

List_List_ConflictSet_5874:
    jmp near List_List_ConflictSet_5874_Nil
    jmp near List_List_ConflictSet_5874_Cons

List_List_ConflictSet_5874_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab5878
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab5875
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5875:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab5876
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5876:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab5877
    ; ####increment refcount
    add qword [rax + 0], 1

lab5877:
    jmp lab5879

lab5878:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab5879:
    ; let x2: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (csp00 := csp00)(x2 := x2)(t := t)(a2 := a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_List_ConflictSet_5874_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5883
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab5880
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5880:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab5881
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5881:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab5882
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5882:
    jmp lab5884

lab5883:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab5884:
    ; substitute (csp00 := csp00)(a2 := a2)(t := t)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x2: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5896
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab5897

lab5896:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5894
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5887
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5885
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5886

lab5885:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5886:

lab5887:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5890
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5888
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5889

lab5888:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5889:

lab5890:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5893
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5891
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5892

lab5891:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5892:

lab5893:
    jmp lab5895

lab5894:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5895:

lab5897:
    ; #load tag
    mov r11, 5
    ; substitute (csp00 := csp00)(x2 := x2)(t := t)(a2 := a2);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

Node_Pair_List_Assign_List_List_ConflictSet_5859:

Node_Pair_List_Assign_List_List_ConflictSet_5859_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5900
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5898
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5898:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5899
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5899:
    jmp lab5901

lab5900:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5901:
    ; substitute (csp0 := csp0)(a1 := a1)(lab1 := lab1)(children1 := children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: Node[Pair[List[Assign], List[List[ConflictSet]]]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5913
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5914

lab5913:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5911
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5904
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5902
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5903

lab5902:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5903:

lab5904:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5907
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5905
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5906

lab5905:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5906:

lab5907:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5910
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5908
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5909

lab5908:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5909:

lab5910:
    jmp lab5912

lab5911:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5912:

lab5914:
    ; #load tag
    mov r9, 0
    ; substitute (csp0 := csp0)(x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lookup_cache_
    jmp lookup_cache_

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5844:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_5844_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab5917
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab5915
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5915:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab5916
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5916:
    jmp lab5918

lab5917:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab5918:
    ; substitute (csp := csp)(a0 := a0)(lab0 := lab0)(children0 := children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5930
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5931

lab5930:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5928
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5921
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5919
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5920

lab5919:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5920:

lab5921:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5924
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5922
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5923

lab5922:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5923:

lab5924:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5927
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5925
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5926

lab5925:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5926:

lab5927:
    jmp lab5929

lab5928:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5929:

lab5931:
    ; #load tag
    mov r9, 0
    ; substitute (csp := csp)(x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump domain_wipeout_
    jmp domain_wipeout_

list_len_:
    ; substitute (a0 := a0)(l := l);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_List_Assign_5932]
    add rcx, rdi
    jmp rcx

List_List_Assign_5932:
    jmp near List_List_Assign_5932_Nil
    jmp near List_List_Assign_5932_Cons

List_List_Assign_5932_Nil:
    ; lit x2 <- 0;
    mov rdi, 0
    ; substitute (x2 := x2)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

List_List_Assign_5932_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5935
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab5933
    ; ####increment refcount
    add qword [r8 + 0], 1

lab5933:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5934
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5934:
    jmp lab5936

lab5935:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5936:
    ; substitute (a0 := a0)(ls := ls);
    ; #erase l0
    cmp rsi, 0
    je lab5939
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab5937
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab5938

lab5937:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab5938:

lab5939:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; lit x0 <- 1;
    mov r9, 1
    ; substitute (ls := ls)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: _Cont = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5951
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5952

lab5951:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5949
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5942
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5940
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5941

lab5940:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5941:

lab5942:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5945
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5943
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5944

lab5943:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5944:

lab5945:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5948
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5946
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5947

lab5946:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5947:

lab5948:
    jmp lab5950

lab5949:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5950:

lab5952:
    ; #load tag
    lea rdi, [rel _Cont_5953]
    ; jump list_len_
    jmp list_len_

_Cont_5953:

_Cont_5953_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab5955
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab5954
    ; ####increment refcount
    add qword [rsi + 0], 1

lab5954:
    jmp lab5956

lab5955:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab5956:
    ; x3 <- x0 + x1;
    mov r11, r9
    add r11, rdx
    ; substitute (x3 := x3)(a0 := a0);
    ; #move variables
    mov rdx, r11
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

try__:
    ; create a1: List[List[Assign]] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5968
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab5969

lab5968:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5966
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5959
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5957
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5958

lab5957:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5958:

lab5959:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5962
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5960
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5961

lab5960:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5961:

lab5962:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5965
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5963
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5964

lab5963:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5964:

lab5965:
    jmp lab5967

lab5966:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5967:

lab5969:
    ; #load tag
    lea r9, [rel List_List_Assign_5970]
    ; create a2: CSP = (algorithm, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab5982
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab5983

lab5982:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5980
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5973
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5971
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5972

lab5971:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5972:

lab5973:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5976
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5974
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5975

lab5974:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5975:

lab5976:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5979
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5977
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5978

lab5977:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5978:

lab5979:
    jmp lab5981

lab5980:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5981:

lab5983:
    ; #load tag
    lea rdi, [rel CSP_5984]
    ; jump queens_
    jmp queens_

CSP_5984:

CSP_5984_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab5987
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab5985
    ; ####increment refcount
    add qword [r12 + 0], 1

lab5985:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab5986
    ; ####increment refcount
    add qword [r10 + 0], 1

lab5986:
    jmp lab5988

lab5987:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab5988:
    ; substitute (a1 := a1)(algorithm := algorithm)(vars0 := vars0)(vals0 := vals0)(rel0 := rel0);
    ; #move variables
    mov rcx, r13
    mov r13, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    mov rax, r12
    mov r12, r8
    mov rsi, r10
    ; let x1: CSP = CSP(vars0, vals0, rel0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6000
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6001

lab6000:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab5998
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab5991
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5989
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5990

lab5989:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5990:

lab5991:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab5994
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5992
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5993

lab5992:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5993:

lab5994:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab5997
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab5995
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab5996

lab5995:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab5996:

lab5997:
    jmp lab5999

lab5998:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab5999:

lab6001:
    ; #load tag
    mov r9, 0
    ; substitute (algorithm := algorithm)(x1 := x1)(a1 := a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_
    jmp search_

List_List_Assign_5970:
    jmp near List_List_Assign_5970_Nil
    jmp near List_List_Assign_5970_Cons

List_List_Assign_5970_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab6003
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab6002
    ; ####increment refcount
    add qword [rax + 0], 1

lab6002:
    jmp lab6004

lab6003:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab6004:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump list_len_
    jmp list_len_

List_List_Assign_5970_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6006
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab6005
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6005:
    jmp lab6007

lab6006:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab6007:
    ; substitute (a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6019
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6020

lab6019:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6017
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6010
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6008
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6009

lab6008:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6009:

lab6010:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6013
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6011
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6012

lab6011:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6012:

lab6013:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6016
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6014
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6015

lab6014:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6015:

lab6016:
    jmp lab6018

lab6017:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6018:

lab6020:
    ; #load tag
    mov rdi, 5
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump list_len_
    jmp list_len_

test_map_:
    ; substitute (f := f)(a0 := a0)(l := l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6021]
    add rcx, r9
    jmp rcx

List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6021:
    jmp near List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6021_Nil
    jmp near List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6021_Cons

List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6021_Nil:
    ; substitute (a0 := a0);
    ; #erase f
    cmp rax, 0
    je lab6024
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab6022
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab6023

lab6022:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab6023:

lab6024:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6021_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6027
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab6025
    ; ####increment refcount
    add qword [r10 + 0], 1

lab6025:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab6026
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6026:
    jmp lab6028

lab6027:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab6028:
    ; substitute (f0 := f)(p := p)(a0 := a0)(ps := ps)(f := f);
    ; #share f
    cmp rax, 0
    je lab6029
    ; ####increment refcount
    add qword [rax + 0], 1

lab6029:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; create a1: _Cont = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6041
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6042

lab6041:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6039
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6032
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6030
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6031

lab6030:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6031:

lab6032:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6035
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6033
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6034

lab6033:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6034:

lab6035:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6038
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6036
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6037

lab6036:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6037:

lab6038:
    jmp lab6040

lab6039:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6040:

lab6042:
    ; #load tag
    lea r9, [rel _Cont_6043]
    ; substitute (p := p)(a1 := a1)(f0 := f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Apply
    ; #there is only one clause, so we can jump there directly
    jmp r9

_Cont_6043:

_Cont_6043_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab6047
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab6044
    ; ####increment refcount
    add qword [r10 + 0], 1

lab6044:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab6045
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6045:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab6046
    ; ####increment refcount
    add qword [rsi + 0], 1

lab6046:
    jmp lab6048

lab6047:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab6048:
    ; substitute (f := f)(ps := ps)(a0 := a0)(x0 := x0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rax, r10
    ; create a2: List[i64] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6060
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6061

lab6060:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6058
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6051
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6049
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6050

lab6049:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6050:

lab6051:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6054
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6052
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6053

lab6052:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6053:

lab6054:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6057
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6055
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6056

lab6055:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6056:

lab6057:
    jmp lab6059

lab6058:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6059:

lab6061:
    ; #load tag
    lea r9, [rel List_i64_6062]
    ; jump test_map_
    jmp test_map_

List_i64_6062:
    jmp near List_i64_6062_Nil
    jmp near List_i64_6062_Cons

List_i64_6062_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab6064
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab6063
    ; ####increment refcount
    add qword [rax + 0], 1

lab6063:
    jmp lab6065

lab6064:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab6065:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_6062_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6067
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab6066
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6066:
    jmp lab6068

lab6067:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab6068:
    ; substitute (x0 := x0)(a0 := a0)(a3 := a3)(as0 := as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6080
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6081

lab6080:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6078
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6071
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6069
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6070

lab6069:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6070:

lab6071:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6074
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6072
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6073

lab6072:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6073:

lab6074:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6077
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6075
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6076

lab6075:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6076:

lab6077:
    jmp lab6079

lab6078:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6079:

lab6081:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x1 := x1)(a0 := a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

test_constraints_nofib_:
    ; substitute (a0 := a0)(n := n);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; create x0: Fun[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]], i64] = (n)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov qword [rbx + 48], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6093
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6094

lab6093:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6091
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6084
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6082
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6083

lab6082:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6083:

lab6084:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6087
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6085
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6086

lab6085:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6086:

lab6087:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6090
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6088
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6089

lab6088:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6089:

lab6090:
    jmp lab6092

lab6091:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6092:

lab6094:
    ; #load tag
    lea rdi, [rel Fun_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_i64_6095]
    ; create x1: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6096]
    ; create x2: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6097]
    ; create x3: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6098]
    ; create x4: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    lea r15, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6099]
    ; create x5: Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    lea rcx, [rel Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6100]
    mov [rsp + 2024], rcx
    ; let x6: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    mov qword [rsp + 2008], 0
    ; let x7: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x5, x6);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6112
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab6113

lab6112:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6110
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6103
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6101
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6102

lab6101:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6102:

lab6103:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6106
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6104
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6105

lab6104:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6105:

lab6106:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6109
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6107
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6108

lab6107:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6108:

lab6109:
    jmp lab6111

lab6110:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6111:

lab6113:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; let x8: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x4, x7);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6125
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab6126

lab6125:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6123
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6116
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6114
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6115

lab6114:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6115:

lab6116:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6119
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6117
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6118

lab6117:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6118:

lab6119:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6122
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6120
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6121

lab6120:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6121:

lab6122:
    jmp lab6124

lab6123:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6124:

lab6126:
    ; #load tag
    mov r15, 5
    ; let x9: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x3, x8);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6138
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab6139

lab6138:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6136
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6128

lab6127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6128:

lab6129:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6131

lab6130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6131:

lab6132:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6135
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6133
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6134

lab6133:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6134:

lab6135:
    jmp lab6137

lab6136:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6137:

lab6139:
    ; #load tag
    mov r13, 5
    ; let x10: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x2, x9);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6151
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab6152

lab6151:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6149
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6142
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6140
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6141

lab6140:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6141:

lab6142:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6145
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6143
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6144

lab6143:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6144:

lab6145:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6148
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6146
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6147

lab6146:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6147:

lab6148:
    jmp lab6150

lab6149:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6150:

lab6152:
    ; #load tag
    mov r11, 5
    ; let x11: List[Fun2[CSP, Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = Cons(x1, x10);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6164
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab6165

lab6164:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6162
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6155
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6153
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6154

lab6153:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6154:

lab6155:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6158
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6156
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6157

lab6156:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6157:

lab6158:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6161
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6159
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6160

lab6159:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6160:

lab6161:
    jmp lab6163

lab6162:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6163:

lab6165:
    ; #load tag
    mov r9, 5
    ; substitute (x0 := x0)(x11 := x11)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump test_map_
    jmp test_map_

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6100:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6100_Apply2:
    ; jump fc_
    jmp fc_

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6099:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6099_Apply2:
    ; jump bjbt__
    jmp bjbt__

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6098:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6098_Apply2:
    ; jump bjbt_
    jmp bjbt_

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6097:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6097_Apply2:
    ; jump bm_
    jmp bm_

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6096:

Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_6096_Apply2:
    ; jump bt_
    jmp bt_

Fun_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_i64_6095:

Fun_Fun2_CSP_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_i64_6095_Apply:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6166
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    jmp lab6167

lab6166:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]

lab6167:
    ; substitute (n := n)(x := x)(a1 := a1);
    ; #move variables
    mov r8, rsi
    mov rsi, rax
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump try__
    jmp try__

head_:
    ; substitute (a0 := a0)(l := l);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_i64_6168]
    add rcx, rdi
    jmp rcx

List_i64_6168:
    jmp near List_i64_6168_Nil
    jmp near List_i64_6168_Cons

List_i64_6168_Nil:
    ; lit x0 <- -1;
    mov rdi, -1
    ; substitute (x0 := x0)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

List_i64_6168_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab6170
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab6169
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6169:
    mov rdi, [rsi + 40]
    jmp lab6171

lab6170:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab6171:
    ; substitute (x := x)(a0 := a0);
    ; #erase xs
    cmp r8, 0
    je lab6174
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab6172
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab6173

lab6172:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab6173:

lab6174:
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

main_loop_:
    ; lit x0 <- 1;
    mov r11, 1
    ; if iters == x0 \{ ... \}
    cmp rdx, r11
    je lab6175
    ; else branch
    ; substitute (n0 := n)(n := n)(a0 := a0)(iters := iters);
    ; #move variables
    mov r11, rdx
    mov rdx, rdi
    ; create a3: List[i64] = (n, a0, iters)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6187
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6188

lab6187:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6185
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6178
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6176
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6177

lab6176:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6177:

lab6178:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6181
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6179
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6180

lab6179:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6180:

lab6181:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6184
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6182
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6183

lab6182:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6183:

lab6184:
    jmp lab6186

lab6185:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6186:

lab6188:
    ; #load tag
    lea rdi, [rel List_i64_6189]
    ; jump test_constraints_nofib_
    jmp test_constraints_nofib_

List_i64_6189:
    jmp near List_i64_6189_Nil
    jmp near List_i64_6189_Cons

List_i64_6189_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab6191
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab6190
    ; ####increment refcount
    add qword [rsi + 0], 1

lab6190:
    mov rdx, [rax + 24]
    jmp lab6192

lab6191:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab6192:
    ; let res: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 := a0)(iters := iters)(n := n);
    ; #erase res
    cmp r10, 0
    je lab6195
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab6193
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab6194

lab6193:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab6194:

lab6195:
    ; #move variables
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump lift_main_loop_1_
    jmp lift_main_loop_1_

List_i64_6189_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6197
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab6196
    ; ####increment refcount
    add qword [r10 + 0], 1

lab6196:
    mov r9, [r8 + 24]
    jmp lab6198

lab6197:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab6198:
    ; substitute (iters := iters)(a0 := a0)(n := n)(a5 := a5)(as1 := as1);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov r12, rsi
    mov rsi, r10
    ; let res: List[i64] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6210
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab6211

lab6210:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6208
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6201
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6199
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6200

lab6199:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6200:

lab6201:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6204
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6202
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6203

lab6202:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6203:

lab6204:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6207
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6205
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6206

lab6205:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6206:

lab6207:
    jmp lab6209

lab6208:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6209:

lab6211:
    ; #load tag
    mov r11, 5
    ; substitute (a0 := a0)(iters := iters)(n := n);
    ; #erase res
    cmp r10, 0
    je lab6214
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab6212
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab6213

lab6212:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab6213:

lab6214:
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump lift_main_loop_1_
    jmp lift_main_loop_1_

lab6175:
    ; then branch
    ; substitute (n := n)(a0 := a0);
    ; #move variables
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; create a2: List[i64] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6226
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6227

lab6226:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6224
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6217
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6215
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6216

lab6215:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6216:

lab6217:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6220
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6218
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6219

lab6218:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6219:

lab6220:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6223
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6221
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6222

lab6221:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6222:

lab6223:
    jmp lab6225

lab6224:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6225:

lab6227:
    ; #load tag
    lea rdi, [rel List_i64_6228]
    ; jump test_constraints_nofib_
    jmp test_constraints_nofib_

List_i64_6228:
    jmp near List_i64_6228_Nil
    jmp near List_i64_6228_Cons

List_i64_6228_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab6230
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab6229
    ; ####increment refcount
    add qword [rax + 0], 1

lab6229:
    jmp lab6231

lab6230:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab6231:
    ; let res: List[i64] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_main_loop_0_
    jmp lift_main_loop_0_

List_i64_6228_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab6233
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab6232
    ; ####increment refcount
    add qword [r8 + 0], 1

lab6232:
    jmp lab6234

lab6233:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab6234:
    ; substitute (a0 := a0)(a4 := a4)(as0 := as0);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; let res: List[i64] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6246
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6247

lab6246:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6244
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6237
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6235
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6236

lab6235:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6236:

lab6237:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6239

lab6238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6239:

lab6240:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6242

lab6241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6242:

lab6243:
    jmp lab6245

lab6244:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6245:

lab6247:
    ; #load tag
    mov rdi, 5
    ; jump lift_main_loop_0_
    jmp lift_main_loop_0_

lift_main_loop_1_:
    ; lit x2 <- 1;
    mov r11, 1
    ; x3 <- iters - x2;
    mov r13, rdi
    sub r13, r11
    ; substitute (x3 := x3)(n := n)(a0 := a0);
    ; #move variables
    mov r8, rax
    mov rdi, r9
    mov r9, rdx
    mov rdx, r13
    ; jump main_loop_
    jmp main_loop_

lift_main_loop_0_:
    ; substitute (res := res)(a0 := a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; create a1: _Cont = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab6259
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab6260

lab6259:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab6257
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab6250
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6248
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6249

lab6248:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6249:

lab6250:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab6253
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6251
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6252

lab6251:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6252:

lab6253:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab6256
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab6254
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab6255

lab6254:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab6255:

lab6256:
    jmp lab6258

lab6257:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab6258:

lab6260:
    ; #load tag
    lea rdi, [rel _Cont_6261]
    ; jump head_
    jmp head_

_Cont_6261:

_Cont_6261_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab6263
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab6262
    ; ####increment refcount
    add qword [rsi + 0], 1

lab6262:
    jmp lab6264

lab6263:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab6264:
    ; println_i64 x1;
    ; #save caller-save registers
    mov r12, rdx
    mov r13, rsi
    mov r14, rdi
    sub rsp, 8
    ; #move argument into place
    mov rdi, rdx
    call println_i64
    ; #restore caller-save registers
    mov rdx, r12
    mov rsi, r13
    mov rdi, r14
    add rsp, 8
    ; substitute (a0 := a0);
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; lit x4 <- 0;
    mov rdi, 0
    ; substitute (x4 := x4)(a0 := a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    ; #there is only one clause, so we can jump there directly
    jmp rdi

cleanup:
    ; free space for register spills
    add rsp, 2048
    ; restore registers
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbp
    pop rbx
    ret