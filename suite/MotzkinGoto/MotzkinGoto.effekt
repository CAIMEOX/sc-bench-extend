import args 

interface Ret {
  def ret(i:Int) : Int 
}

def sum_loop(i:Int,tot:Int,stop:Int) { f : Int => Int } : Int / {Ret} = {
  if (stop < i) {
    do ret(tot)
  }else{
    sum_loop(i + 1, f(i) + tot, stop) { f }
  }
}

def sum(start:Int,stop:Int) { f : Int => Int } : Int / {Ret} = {
  sum_loop(start,0,stop) { f }
}

def motz(n:Int) : Int / Ret = {
  if (n<=1){ 
    do ret(1)
  }else{
    val limit = n - 2
    def product(i: Int): Int = {
      (try { motz(i) } with Ret { def ret(i) = { i } })
      * 
      (try { motz(limit - i) } with Ret { def ret(i) = { i } })
    }
    do ret(
      (try { motz(n - 1) } with Ret { def ret(i) = { i } } ) 
      + 
      ( try { sum(0,limit) { product } } with Ret { def ret(i) = { i } } ) 
      )
  }
}

def main_loop(iters:Int,n:Int) : Unit = {
  val res = try { motz(n) } with Ret { def ret(i) = { i }}
  if (iters==1){
    println(res)
  }else{
    main_loop(iters - 1,n)
  }
}

def main() : Unit = {
  commandLineArgs() match{
    case Cons(iters_str,Cons(n_str,Nil())) => 
      val iters = try { string::toInt(iters_str) } with Exception[WrongFormat] { def raise(_,msg) = { panic(msg) }}
      val n = try { string::toInt(n_str) } with Exception[WrongFormat] { def raise(_,msg) = { panic(msg) }}
      main_loop(iters,n)
    case _ => panic("Expected arguments \"iters\",\"n\"")
  }
}
