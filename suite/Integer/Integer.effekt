import args 

type Either[A,B] {
  Left(a:A)
  Right(b:B)
}

def enum_from_then_to(from:Int,then:Int,to:Int) : List[Int] = {
  if (from<=to){
    Cons(from,enum_from_then_to(then, (2 * then) - from, to))
  }else{
    Nil()
  }
}

def bench_lscomp2(ls:List[Int],t1:List[Int],a:Int,bstart:Int,bstep:Int,blim:Int) {op : (Int,Int) => Either[Int,Bool] } : List[Either[Int,Bool]] = {
  ls match{
    case Nil() => bench_lscomp1(t1,bstart,bstep,blim) {op}
    case Cons(b,t2) => Cons(op(a,b),bench_lscomp2(t2,t1,a,bstart,bstep,blim) { op })
  }
}

def bench_lscomp1(ls:List[Int],bstart:Int,bstep:Int,blim:Int) { op:(Int,Int) => Either[Int,Bool] } : List[Either[Int,Bool]] = {
  ls match{
    case Nil() => Nil()
    case Cons(a,t1) => bench_lscomp2(enum_from_then_to(bstart,bstart + bstep, blim), t1, a, bstart, bstep, blim) {op}
  }
}

def integerbench(astart:Int,astep:Int,alim:Int,bstart:Int,bstep:Int,blim:Int) { op: (Int,Int) => Either[Int,Bool] } : List[Either[Int,Bool]] = {
  bench_lscomp1(enum_from_then_to(astart,astart + astep, alim), bstart, bstep, blim) { op }
}

def runbench(astart:Int,astep:Int,alim:Int,bstart:Int,bstep:Int,blim:Int) { jop : (Int,Int) => Either[Int,Bool] } { iop : (Int,Int) => Either[Int,Bool] } : List[Either[Int,Bool]] = {
  val res1 = integerbench(astart,astep,alim,astart,astep,alim) {iop}
  integerbench(astart,astep,alim,astart,astep,alim) {iop}
}

def runalltests(astart:Int,astep:Int,alim:Int) : List[Either[Int,Bool]] = {
  val z_add: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Left(a + b) }
  val z_sub: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Left(a - b) }
  val z_mul: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Left(a * b) }
  val z_div: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Left(a / b) }
  val z_mod: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Left(mod(a,b)) }
  val z_equal: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Right(a==b) }
  val z_lt: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Right(a<b) }
  val z_leq: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Right(a<=b) }
  val z_gt: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Right(a>b) }
  val z_geq: (Int,Int) => Either[Int,Bool] at {} = box { (a,b) => Right(a>=b) }

  val add = runbench(astart,astep,alim,astart,astep,alim) { z_add } { (a,b) => Left(a + b) }
  val sub = runbench(astart,astep,alim,astart,astep,alim) { z_sub } { (a,b) => Left(a - b) }
  val mul = runbench(astart,astep,alim,astart,astep,alim) { z_mul } { (a,b) => Left(a * b) }
  val div = runbench(astart,astep,alim,astart,astep,alim) { z_div } { (a,b) => Left(a / b) }
  val mod = runbench(astart,astep,alim,astart,astep,alim) { z_mod } { (a,b) => Left(mod(a, b)) }
  val equal = runbench(astart,astep,alim,astart,astep,alim) { z_equal } { (a,b) => Right(a==b) }
  val lt = runbench(astart,astep,alim,astart,astep,alim) { z_lt } { (a,b) => Right(a<b) }
  val leq = runbench(astart,astep,alim,astart,astep,alim) { z_leq } { (a,b) => Right(a<=b) }
  val gt = runbench(astart,astep,alim,astart,astep,alim) { z_gt } { (a,b) => Right(a>b) }
  val geq = runbench(astart,astep,alim,astart,astep,alim) { z_geq } { (a,b) => Right(a>=b) }
  runbench(astart,astep,alim,astart,astep,alim) { z_geq } { (a,b) => Right(a>=b) }
}

def test_integer_nofib(n:Int) : List[Either[Int,Bool]] = {
  runalltests(-2100000000, n, 2100000000)
}

def print_either(e:Either[Int,Bool]) : Unit = {
  e match{
    case Left(i) => println(i)
    case Right(b) => 
      if (b) {
        println("11")
      }else{
        println("00")
      }
  }
}

def main_loop(iters:Int,n:Int) : Unit = {
  val res = test_integer_nofib(n)
  if (iters==1){
    print_either(option::getOrElse(list::headOption(res)){panic("Empty List")})
  }else{
    main_loop(iters - 1,n)
  }
}

def main() : Unit = {
  commandLineArgs() match{
    case Cons(iters_str,Cons(n_str,Nil())) => 
      val iters = try { string::toInt(iters_str) } with Exception[WrongFormat] { def raise(_,msg) = { panic(msg) } }
      val n = try { string::toInt(n_str) } with Exception[WrongFormat] { def raise(_,msg) = { panic(msg) } }
      main_loop(iters,n)
    case _ => panic("Please provide arguments \"iters\",\"n\"")
  }
}
