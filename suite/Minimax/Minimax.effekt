import args 

type Player { 
  X()
  O()
}

type RoseTree[A] {
  Rose(a:A,as:List[RoseTree[A]])
}

def other(p:Player) : Player = {
  p match{
    case X() => O()
    case O() => X()
  }
}

def player_equal(p1:Player,p2:Player) : Bool = {
  (p1,p2) match{
    case (X(),X()) => true
    case (O(),O()) => true
    case _ => false
  }
}

def top[A](t:RoseTree[A]) : A = {
  t match{
    case Rose(p,_) => p
  }
}

def snd[A,B](x:(A,B)) : B = {
  x match{
    case (_,b) => b
  }
}

def head[A](l:List[A]) : A = {
  l match{ 
    case Nil() => panic("Empty List")
    case Cons(a,_) => a
  }
}

def tail[A](l:List[A]) : List[A] = {  
  l match{
    case Nil() => panic("Empty List")
    case Cons(_,as) => as
  }
}

def nth[A](l:List[A],n:Int) : A = {
  l match{
    case Nil() => panic("Emtpy List")
    case Cons(a,as) => if (n==0) { a } else { nth(as,n - 1) }
  }
}

def list_extreme(l:List[Int]) { f:(Int,Int) => Int } : Int = {
  l match{
    case Nil() => panic("Empty List")
    case Cons(i,is_) => list::foldLeft(is_,i){f}
  }
}

def listmax(l:List[Int]) : Int = {
  list_extreme(l) { (a,b) => if (b<a) { a } else { b } }
}

def listmin(l:List[Int]): Int = {
  list_extreme(l) { (a,b) => if (a<b) { a } else { b } }
}

def mk_leaf[A](a:A) : RoseTree[A] = {
  Rose(a,Nil())
}

def exists[A](l:List[A]) { f:A=>Bool } : Bool = {
  l match{
    case Nil() => false 
    case Cons(a,as) => if (f(a)) { true } else { exists(as) {f} }
  }
}

def rows() : List[List[Int]] = {
  Cons(Cons(0, Cons(1, Cons(2, Nil()))),
    Cons(Cons(3, Cons(4, Cons(5, Nil()))), 
      Cons(Cons(6, Cons(7, Cons(8, Nil()))), 
        Nil())))
}

def cols() : List[List[Int]] = {
  Cons(Cons(0, Cons(3, Cons(6, Nil()))),
    Cons(Cons(1, Cons(4, Cons(7, Nil()))),
      Cons(Cons(2, Cons(5, Cons(8, Nil()))), 
        Nil())))
}

def diags() : List[List[Int]] = { 
  Cons(Cons(0, Cons(4, Cons(8, Nil()))), 
    Cons(Cons(2, Cons(4, Cons(6, Nil()))),
      Nil()))

}

def find(l:List[Option[Player]],i:Int):Option[Player] ={
  l match{
    case Nil() => None()
    case Cons(p,ps) => if (i==0) { p } else { find(ps,i - 1) }
  }
}

def player_occupies(p:Player,board:List[Option[Player]],i:Int) : Bool = {
  find(board,i) match{
    case Some(p0) => player_equal(p,p0)
    case None() => false
  }
}

def score(board:List[Option[Player]]) : Int = {
  if (is_win_for(board,X())) {
    1 
  }else if (is_win_for(board,O())) {
    -1
  }else{
    0
  }
}

def put_at(x:Option[Player],xs:List[Option[Player]],i:Int) : List[Option[Player]] = { 
  if (i==0) {
    Cons(x,tail(xs))
  }else if (i>0) {
    Cons(head(xs),put_at(x,tail(xs),i - 1))
  }else{
    Nil()
  }
}

def move_to(board:List[Option[Player]],p:Player,i:Int) : List[Option[Player]] = {
  if (is_occupied(board,i)){
    Nil()
  }else{
    put_at(Some(p),board,i)
  }
}

def all_moves_rec(n:Int,board:List[Option[Player]],acc:List[Int]) : List[Int] = {
  board match{
    case Nil() => list::reverse(acc)
    case Cons(Some(p),more) => all_moves_rec(n + 1,more,acc)
    case Cons(None(),more) => all_moves_rec(n + 1, more, Cons(n,acc))
  }
}

def all_moves(board:List[Option[Player]]) : List[Int] = {
  all_moves_rec(0,board,Nil())
}

def successors(board:List[Option[Player]],p:Player) : List[List[Option[Player]]] = {
  list::map(all_moves(board)) { i => move_to(board,p,i) }
}

def is_occupied(board:List[Option[Player]],i:Int) : Bool ={
  option::isDefined(nth(board,i))
}

def is_full(board:List[Option[Player]]) : Bool = {
  list::all(board) { p => option::isDefined(p) }
}

def is_cat(board:List[Option[Player]]) : Bool = {
  is_full(board) && not(is_win_for(board,X())) && not(is_win_for(board,O()))
}

def has_trip(board:List[Option[Player]],p:Player,l:List[Int]) : Bool = {
  list::all(l) { i => player_occupies(p,board,i) }
}

def has_row(board:List[Option[Player]],p:Player):Bool = {
  exists(rows()) { l => has_trip(board,p,l) }
}

def has_col(board:List[Option[Player]],p:Player): Bool ={
  exists(cols()) { l => has_trip(board,p,l) }
}

def has_diag(board:List[Option[Player]],p:Player): Bool ={
  exists(rows()) { l => has_trip(board,p,l) }
}

def is_win_for(board:List[Option[Player]],p:Player) : Bool = {
  has_row(board,p) || has_col(board,p) || has_diag(board,p)
}

def is_win(board:List[Option[Player]]) : Bool = {
  is_win_for(board,X()) || is_win_for(board,O())
}

def game_over(board:List[Option[Player]]) : Bool ={
  is_win(board) || is_cat(board)
}

def minimax(p:Player,board:List[Option[Player]]) : RoseTree[(List[Option[Player]],Int)] = {
  if (game_over(board)) {
    mk_leaf((board,score(board)))
  }else{
    val trees = list::map(successors(board,p)) { b => minimax(other(p),b) }
    val scores = list::map(trees) {t => snd(top(t)) }
    p match{
      case X() => Rose((board,listmax(scores)),trees)
      case O() => Rose((board,listmin(scores)),trees)
    }
  }
}

def main_loop(iters:Int) : Unit = {
  val res = minimax(X(),empty())
  if (iters==1){
    println(snd(top(res)))
  }else{
    main_loop(iters - 1)
  }
}

def main() : Unit = {
  commandLineArgs() match{
    case Cons(iters_str,Nil()) => 
      val iters = try { string::toInt(iters_str) } with Exception[WrongFormat] { def raise(_,msg) = { panic(msg) } }
      main_loop(iters)
    case _ => panic("Expected argument \"iters\"")
  }
}
