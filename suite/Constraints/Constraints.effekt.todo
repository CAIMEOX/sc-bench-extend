import args
import list

type Assign {
  Assign(varr:Int,value:Int)
}

type CSP {
  CSP(vars:Int,vals:Int,rel: (Assign, Assign) => Bool at {})
}

type Node[A] {
  Node(lab:A,children:List[Node[A]])
}

type ConflictSet {
  Known(vs:List[Int])
  Unknown()
}

def fst[A,B](p:(A,B)) : A = {
  p match {
    case (a,_) => a
  }
}

def label[A](n:Node[A]) : A = {
  n match {
    case Node(p,_) => p
  }
}

def map_tree[A,B](t:Node[A]) { f:A=>B } : Node[B] = {
  t match {
    case Node(l,ls) => Node(f(l),list::map(ls){x => map_tree(x){f}})
  }
}

def fold_tree[A,B](t:Node[A]) {f : (A,List[Node[B]]) => Node[B] } : Node[B] = {
  t match {
    case Node(l,c) => f(l,list::map(c){x => fold_tree(x){f}})
  }
}

def len[A](ls:List[A]) : Int = {
  ls match {
    case Nil() => 0
    case Cons(_,xs) => 1+len(xs)
  }
}

def combine(ls:List[(List[Assign],ConflictSet)],acc:List[Int]) : List[Int] = { panic("TODO") }

def domain_wipeout(csp:CSP,t:Node[((List[Assign],ConflictSet),List[List[ConflictSet]])]) : Node[(List[Assign],ConflictSet)] = { panic("TODO") }

def check_complete(csp:CSP,s:List[Assign]): ConflictSet = {
  panic("TODO")
}

def earliest_inconsistency(csp:CSP,aas:List[Assign]) : Option[(Int,Int)] = { panic("TODO") }

def lookup_cache(csp:CSP,t:Node[(List[Assign],List[List[ConflictSet]])]): Node[((List[Assign],ConflictSet),List[List[ConflictSet]])] = {
  panic("TODO")
}

def cache_checks(csp:CSP,tbl:List[List[ConflictSet]],n:Node[List[Assign]]) : Node[(List[Assign],List[List[ConflictSet]])] = { panic("TODO") }

def known_conflict(c:ConflictSet) : Bool = { panic("TODO") }

def empty_table(csp:CSP) : List[List[ConflictSet]] = { panic("TODO") }

def search(csp:CSP){labeler:(CSP,Node[List[Assign]]) => Node[(List[Assign],ConflictSet)]} : List[List[Assign]] = { panic("TODO")
}

def safe(as1:Assign,as2:Assign): Bool = { panic("TODO") }

def queens(n:Int) : CSP = { 
  CSP(n,n,box { (x,y) => safe(x,y) } )
  CSP(n,n,box{ x => x match { case (a,b) => safe(a,b) } })
}

def bt_f3(csp:CSP, s:List[Assign]) : (List[Assign],ConflictSet) = { 
  earliest_inconsistency(csp,s) match{
    case Some((a,b)) => (s,Known([a,b]))
    case None() => (s,check_complete(csp,s))
  }
}

def bt(csp:CSP,t:Node[List[Assign]]) : Node[(List[Assign],ConflictSet)] = { 
  map_tree(t){ x => bt_f3(csp,x) }
}

def bm(csp:CSP,t:Node[List[Assign]]) : Node[(List[Assign],ConflictSet)] = { 
  map_tree(lookup_cache(csp,cache_checks(csp,empty_table(csp),t))) { x => fst(x) }
}

def bj_f6(acs:(List[Assign],ConflictSet), chs:List[Node[(List[Assign],ConflictSet)]]) : Node[(List[Assign],ConflictSet)] = { 
  acs match{
    case (a,Known(cs)) => Node((a,Known(cs)),chs)
    case (a,Unknown()) => Node((a,Known(combine(list::map(chs){x=>label(x)},Nil()))),chs)
  }
}

def bj(csp:CSP,t:Node[(List[Assign],ConflictSet)]) : Node[(List[Assign],ConflictSet)] = {
  fold_tree(t) { bj_f6 }
}

def bjbt(csp:CSP,t:Node[List[Assign]]) : Node[(List[Assign],ConflictSet)] = {
  bj(csp,bt(csp,t))
}

def bj_f7(acs:(List[Assign],ConflictSet),chs:List[Node[(List[Assign],ConflictSet)]]) : Node[(List[Assign],ConflictSet)] = {
  acs match{
    case (a,Known(cs)) => Node((a,Known(cs)),chs)
    case (a,Unknown()) =>
      val cs_ = Known(combine(list::map(chs){x => label(x)},Nil()))
      if (known_conflict(cs_)) {
        Node((a,cs_),Nil())
      }else{
        Node((a,cs_),chs)
      }
  }
}

def bj_(csp:CSP,t:Node[(List[Assign],ConflictSet)]) : Node[(List[Assign],ConflictSet)] = {
  fold_tree(t){bj_f7}
}

def bjbt_(csp:CSP,t:Node[List[Assign]]) : Node[(List[Assign],ConflictSet)] = { 
  bj_(csp,bt(csp,t))
}

def fc(csp:CSP,t:Node[List[Assign]]) : Node[(List[Assign],ConflictSet)] = { 
  domain_wipeout(csp,lookup_cache(csp,cache_checks(csp,empty_table(csp),t)))
}

def try_(n:Int) { algorithm: (CSP, Node[List[Assign]]) => Node[(List[Assign],ConflictSet)] } : Int = {
  len(search(queens(n)){algorithm})
}

def test_constraints_nofib(n:Int) : List[Int] = { 
  list::map([bt,bm,bjbt,bjbt_,fc]) { x => try_(n) {x} }
}

def main_loop(iters:Int,n:Int) : Unit = {
  val res = test_constraints_nofib(n)
  if (iters==1) {
    val hd = headOption(res).getOrElse { -1 }
    println(hd)
  }else{
    main_loop(iters - 1, n)
  } 
}

def main() : Unit = {
  commandLineArgs() match{
    case Cons(iters_str,Cons(n_str,Nil())) => 
        val iters = try { string::toInt(iters_str) } with Exception[WrongFormat] { def raise(_,msg) = { panic(msg) } }

        val n = try { string::toInt(n_str) } with Exception[WrongFormat] { def raise(_,msg) = { panic(msg) } }
        main_loop(iters,n)
    case _ => panic("Expected Arguments \"iters\" and \"n\"")
  }

}
